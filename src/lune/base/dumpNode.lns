import lune.base.TransUnit;
import lune.base.Parser;

pub class dumpFilter extend TransUnit.Filter {
}

fn dump( prefix: str, depth: int, node: TransUnit.Node, txt: str ) {
    let typeStr = "";
    let expType = node.get_expType();
    if expType and expType ~= TransUnit.typeInfoKind.None {
        typeStr = "(%d:%s:%s)" ( expType.get_typeId(),
                                 expType.getTxt(),
                                 expType.get_kind() );
    }
    print( "%s: %s %s %s"
	   (prefix, TransUnit.getNodeKindName( node.get_kind() ), txt, typeStr ) );
}

fn filter( node: TransUnit.Node, filter: dumpFilter, prefix:str, depth:int ) {
    node.processFilter( dumpFilter, prefix, depth );
}

fn getTxt( token: Parser.Token ): str {
    return token.txt;
}

pub override fn dumpFilter.processNone( 
    node: NoneNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
};
pub override fn dumpFilter.processImport( 
    node: ImportNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_modulePath() );
};
pub override fn dumpFilter.processRoot( 
    node: RootNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
    foreach child, index in node.get_children() {
	filter( child, self, prefix .. "  ", depth + 1 );
    }	
};
pub override fn dumpFilter.processBlock( 
    node: BlockNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
    foreach statement, index in node.get_stmtList() {
	filter( statement, self, prefix .. "  ", depth + 1 );
    }	
};  
pub override fn dumpFilter.processStmtExp( 
    node: StmtExpNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processDeclClass( 
    node: DeclClassNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_name().txt );
    foreach field, index in node.get_fieldList() {
	filter( field, self, prefix .. "  ", depth + 1 );
    }	
};  
pub override fn dumpFilter.processDeclMember( 
    node: DeclMemberNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_name().txt );
    filter( node.get_refType(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processExpMacroExp( 
    node: ExpMacroExpNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
    let stmtList = node.get_stmtList();
    if  stmtList {
        foreach stmt in stmtList {
            filter( stmt, self,  prefix .. "  ", depth + 1 );
        }
    }
};
pub override fn dumpFilter.processDeclMacro( 
    node: DeclMacroNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_expType().getTxt() );
};
pub override fn dumpFilter.processExpMacroStat( 
    node: ExpMacroStatNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_expType().getTxt() );
    foreach node in node.get_expStrList() {
        filter( node, self, prefix .. "  ", depth + 1 );
    }
};
pub override fn dumpFilter.processDeclVar( 
    node: DeclVarNode, prefix: str, depth: int )
{
    let varName = "";
    foreach var, index in node.get_varList() {
        if index > 1 {
	    varName = varName .. ",";
        }
	varName = "%s %s" (varName, var.get_name().txt );
    }
    dump( prefix, depth, node, node.get_unwrap() and "! " or " " .. varName );
    foreach var, index in node.get_varList() {
        if var[ "refType" ] {
            filter(
                var[ "refType" ], self, prefix .. "  ", depth + 1 );
        }
    }
    if node.get_expList() {
	filter( node.get_expList(), self, prefix .. "  ", depth + 1 );
    }
    if node.get_unwrap() {
	filter( node.get_unwrap(), self, prefix .. "  ", depth + 1 );
    }
};  
pub override fn dumpFilter.processDeclArg( 
    node: DeclArgNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_name().txt );
    filter( node.get_argType(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processDeclArgDDD( 
    node: DeclArgDDDNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "..." );
};  
pub override fn dumpFilter.processExpDDD( 
    node: ExpDDDNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "..." );
};

fn dumpFilter.processDeclFuncInfo(
    node: TransUnit.Node, declInfo: TransUnit.DeclFuncInfo, prefix: str, depth: int )
{
    let name = declInfo.get_name();
    dump( prefix, depth, node, name and name.txt or "<anonymous>" );
    let argList:stem[] = declInfo.get_argList();
    foreach arg, index in argList {
	filter( arg, self, prefix .. "  ", depth + 1 );
    }
    let retTypeList:stem[] = declInfo.get_retTypeList();
    foreach refType, index in retTypeList {
	filter( refType, self, prefix .. "  ", depth + 1 );
    }
    if declInfo.get_body() {
	filter( declInfo.get_body(), self, prefix .. "  ", depth + 1 );
    }
}
pub override fn dumpFilter.processDeclFunc( 
    node: DeclFuncNode, prefix: str, depth: int )
{
    self.processDeclFuncInfo( node, node.get_declInfo(), prefix, depth );
};	
pub override fn dumpFilter.processDeclMethod( 
    node: DeclMethodNode, prefix: str, depth: int )
{
    self.processDeclFuncInfo( node, node.get_declInfo(), prefix, depth );
};	
pub override fn dumpFilter.processDeclConstr( 
    node: DeclConstrNode, prefix: str, depth: int )
{
    self.processDeclFuncInfo( node, node.get_declInfo(), prefix, depth );
};

pub override fn dumpFilter.processExpCallSuper( 
    node: ExpCallSuperNode, prefix: str, depth: int )
{
    let typeInfo:TransUnit.TypeInfo = node.get_superType();
    dump( prefix, depth, node, typeInfo.getTxt() );
};
pub override fn dumpFilter.processRefType( 
    node: RefTypeNode, prefix: str, depth: int )
{
    dump( prefix, depth, node,
	  (node.get_refFlag() and "&" or "") ..
	  (node.get_mutFlag() and "mut " or "") );
    filter( node.get_name(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processIf( 
    node: IfNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "");
    let stmtList:IfStmtInfo[] = node.get_stmtList();
    foreach stmt, index in stmtList {
	if stmt[ 'exp' ] {
	    filter( stmt[ 'exp' ], self, prefix .. "  ", depth + 1 );
	}   	
	filter( stmt[ 'block' ], self, prefix .. "  ", depth + 1 );
    }	
};  
pub override fn dumpFilter.processSwitch( 
    node: SwitchNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "");
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
    let caseList = node.get_caseList()@TransUnit.CaseInfo[];
    foreach caseInfo in caseList {
        filter( caseInfo[ 'expList' ], self, prefix .. "  ", depth + 1 );
        filter( caseInfo[ 'block' ], self, prefix .. "  ", depth + 1 );
    }
    filter( node.get_default(), self, prefix .. "  ", depth + 1 );
};
pub override fn dumpFilter.processWhile( 
    node: WhileNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "");
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
    filter( node.get_block(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processRepeat( 
    node: RepeatNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "");
    filter( node.get_block(), self, prefix .. "  ", depth + 1 );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processFor( 
    node: ForNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_val().txt );
    filter( node.get_init(), self, prefix .. "  ", depth + 1 );
    filter( node.get_to(), self, prefix .. "  ", depth + 1 );
    if node.get_delta() {
	filter( node.get_delta(), self, prefix .. "  ", depth + 1 );
    }	
    filter( node.get_block(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processApply( 
    node: ApplyNode, prefix: str, depth: int )
{
    let varNames = "";
    let varList:stem[] = node.get_varList();
    foreach var, index in varList {
	varNames = varNames .. var[ 'txt' ] .. " ";
    }	
    dump( prefix, depth, node, varNames );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
    filter( node.get_block(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processForeach( 
    node: ForeachNode, prefix: str, depth: int )
{
    let index = node.get_key() and node.get_key().txt or "";
    dump( prefix, depth, node, node.get_val().txt .. " " .. index );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
    filter( node.get_block(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processForsort( 
    node: ForsortNode, prefix: str, depth: int )
{
    let index = node.get_key() and node.get_key().txt or "";
    dump( prefix, depth, node, node.get_val().txt .. " " .. index );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
    filter( node.get_block(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processExpCall( 
    node: ExpCallNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
    filter( node.get_func(), self, prefix .. "  ", depth + 1 );
    if node.get_argList() {
	filter( node.get_argList(), self, prefix .. "  ", depth + 1 );
    }	
};  
pub override fn dumpFilter.processExpList( 
    node: ExpListNode, prefix: str, depth: int )

{
    dump( prefix, depth, node, "" );
    let expList: TransUnit.Node[] = node.get_expList();
    foreach exp, index in expList {
	filter( exp, self, prefix .. "  ", depth + 1 );
    }	
};  
pub override fn dumpFilter.processExpOp1( 
    node: ExpOp1Node, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_op().txt );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processExpCast( 
    node: ExpCastNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processExpParen( 
    node: ExpParenNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "()" );
    filter( node.get_exp(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processExpOp2( 
    node: ExpOp2Node, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_op().txt );
    filter( node.get_exp1(), self, prefix .. "  ", depth + 1 );
    filter( node.get_exp2(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processExpNew( 
    node: ExpNewNode, prefix: str, depth: int )

{
    dump( prefix, depth, node, "" );
    filter( node.get_symbol(), self, prefix .. "  ", depth + 1 );
    if node.get_argList() {
	filter( node.get_argList(), self, prefix .. "  ", depth + 1 );
    }
};
pub override fn dumpFilter.processExpRef( 
    node: ExpRefNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_token().txt );
};
pub override fn dumpFilter.processExpRefItem( 
    node: ExpRefItemNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "seq[exp] " .. node.get_expType().getTxt() );
    filter( node.get_val(), self, prefix .. "  ", depth + 1 );
    filter( node.get_index(), self, prefix .. "  ", depth + 1 );
};  
pub override fn dumpFilter.processRefField( 
    node: RefFieldNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_field().txt );
    filter( node.get_prefix(), self, prefix .. "  ", depth + 1 );
};  

pub override fn dumpFilter.processGetField( 
    node: GetFieldNode, prefix: str, depth: int )
{
    dump( prefix, depth, node,
          (node.get_getterTypeInfo() and "get_" or "") .. node.get_field().txt );
    filter( node.get_prefix(), self, prefix .. "  ", depth + 1 );
};

pub override fn dumpFilter.processReturn( 
    node: ReturnNode, prefix: str, depth: int )

{
    dump( prefix, depth, node, "" );
    if node.get_expList() {
        filter( node.get_expList(), self, prefix .. "  ", depth + 1 );
    }
};  
pub override fn dumpFilter.processLiteralList( 
    node: LiteralListNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "[]" );
    if node.get_expList() {
	filter( node.get_expList(), self, prefix .. "  ", depth + 1 );
    }
};  
pub override fn dumpFilter.processLiteralMap( 
    node: LiteralMapNode, prefix: str, depth: int )

{
    dump( prefix, depth, node, "{}" );
    let pairList:TransUnit.PairItem[] = node.get_pairList();
    foreach pair in pairList {
	filter( pair.get_key(), self, prefix .. "  ", depth + 1 );
	filter( pair.get_val(), self, prefix .. "  ", depth + 1 );
    }
};  
pub override fn dumpFilter.processLiteralArray( 
    node: LiteralArrayNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "[@]" );
    if node.get_expList() {
	filter( node.get_expList(), self, prefix .. "  ", depth + 1 );
    }
};  
pub override fn dumpFilter.processLiteralChar( 
    node: LiteralCharNode, prefix: str, depth: int )
{
    dump( prefix, depth, node,
	  string.format( "%s(%s)", node.get_num(), node.get_token().txt ) );
};  
pub override fn dumpFilter.processLiteralInt( 
    node: LiteralIntNode, prefix: str, depth: int )
{
    dump( prefix, depth, node,
	  string.format( "%s(%s)", node.get_num(), node.get_token().txt ) );
};  
pub override fn dumpFilter.processLiteralReal( 
    node: LiteralRealNode, prefix: str, depth: int )
{
    dump( prefix, depth, node,
	  string.format( "%s(%s)", node.get_num(), node.get_token().txt ) );
};  
pub override fn dumpFilter.processLiteralString( 
    node: LiteralStringNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_token().txt );
};  
pub override fn dumpFilter.processLiteralBool( 
    node: LiteralBoolNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_token().txt == "true" );
};  
pub override fn dumpFilter.processLiteralNil( 
    node: LiteralNilNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
};  
pub override fn dumpFilter.processBreak( 
    node: BreakNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, "" );
};  
pub override fn dumpFilter.processLiteralSymbol( 
    node: LiteralSymbolNode, prefix: str, depth: int )
{
    dump( prefix, depth, node, node.get_token().txt );
};  
