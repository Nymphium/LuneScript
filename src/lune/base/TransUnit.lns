import lune.base.Parser;
import lune.base.Util;

pub fn errorLog( message: str ) {
    (io@stem).stderr.write( message .. "\n" );
}

pub fn debugLog() {
    let debugInfo1 = debug.getinfo( 2 );
    let debugInfo2 = debug.getinfo( 3 );
    let debugInfo3 = debug.getinfo( 4 );
    let debugInfo4 = debug.getinfo( 5 );
    errorLog( "-- %s %s" ( debugInfo1[ "short_src" ], debugInfo1[ 'currentline' ] ) );
    errorLog( "-- %s %s" ( debugInfo2[ "short_src" ], debugInfo2[ 'currentline' ] ) );
    errorLog( "-- %s %s" ( debugInfo3[ "short_src" ], debugInfo3[ 'currentline' ] ) );
    errorLog( "-- %s %s" ( debugInfo4[ "short_src" ], debugInfo4[ 'currentline' ] ) );
}


pub let rootTypeId = 1;
let typeIdSeed = rootTypeId + 1;

let rootTypeInfo = nil;

pub proto class TypeInfo;

pub let typeInfoKind:Map<str,TypeInfo> = {};
let builtInTypeMap:Map<str,TypeInfo> = {};
let builtInTypeIdSet:Map<int,bool> = {};

pub let TypeInfoKindRoot = 0;
pub let TypeInfoKindPrim = 1;
pub let TypeInfoKindList = 2;
pub let TypeInfoKindArray = 3;
pub let TypeInfoKindMap = 4;
pub let TypeInfoKindClass = 5;
pub let TypeInfoKindFunc = 6;
pub let TypeInfoKindNilable = 7;
pub let TypeInfoKindMacro = 8;

pub fn isBuiltin( typeId: int ) : bool {
    return builtInTypeIdSet[ typeId ];
}


class OutStream {
    pub fn write( txt: str );
}

pub class TypeInfo {
    pri let externalFlag: bool;
    pri let itemTypeInfoList: TypeInfo[@] { pub };
    pri let retTypeInfoList: TypeInfo[@] { pub };
    pri let parentInfo: TypeInfo { pub };
    pri let typeId: int { pub };
    ''pri let txt: str { pub };
    pri let txt: str;
    pri let kind: int { pub };
    pri let staticFlag: bool { pub };
    pri let accessMode: str { pub };
    '' コンパイラで自動生成された型情報の場合 true。 accessor 等。
    pri let autoFlag: bool { pub };

    '' unwrap 後の TypeInfo
    pri let orgTypeInfo: TypeInfo { pub };
    '' 基底クラス
    pri let baseTypeInfo: TypeInfo { pub };

    pri let nilable: bool { pub };
    '' この型の nilable 版の TypeInfo
    pri let nilableTypeInfo: TypeInfo { pub };
    pri let children: TypeInfo[] { pub };
    
    fn __init( baseTypeInfo: TypeInfo, orgTypeInfo: TypeInfo, 
	    autoFlag: bool, externalFlag: bool, staticFlag: bool, accessMode: str,
            txt: str, parentInfo: TypeInfo, typeId: int, kind: int,
	    itemTypeInfoList: TypeInfo[@], retTypeInfoList: TypeInfo[@] )
    {
        self.baseTypeInfo = baseTypeInfo;
        self.autoFlag = autoFlag;
        self.externalFlag = externalFlag;
        self.staticFlag = staticFlag;
        self.accessMode = accessMode;
	self.txt = txt;
	self.kind = kind;
	self.itemTypeInfoList = itemTypeInfoList or [@];
	self.retTypeInfoList = retTypeInfoList or [@];
	self.orgTypeInfo = orgTypeInfo;
        self.parentInfo = parentInfo;
        self.children = [];

        if rootTypeInfo and not parentInfo {
            debugLog();
            error( "" );
        }

        if kind == TypeInfoKindRoot {
	    self.typeId = typeId;
	    self.nilable = false;
            rootTypeInfo = self;
        }
        elseif not orgTypeInfo {
            if parentInfo {
                table.insert( parentInfo.children, self );
            }
	    self.typeId = typeId + 1;
	    self.nilable = false;
	    self.nilableTypeInfo = new TypeInfo(
		baseTypeInfo, self, autoFlag, externalFlag, staticFlag, accessMode, "",
                parentInfo, typeIdSeed,     
		TypeInfoKindNilable, itemTypeInfoList, retTypeInfoList );
	    typeIdSeed = typeIdSeed + 1;
	}
	else {
	    self.typeId = typeId;
	    self.nilable = true;
	    self.nilableTypeInfo = nil;
	}
    }

    pub fn getParentId(): int {
        return self.parentInfo and self.parentInfo.typeId or rootTypeId;
    }

    pub fn get_baseId(): int {
        return self.baseTypeInfo and self.baseTypeInfo.typeId or rootTypeId;
    }

    pub fn addChild( child:TypeInfo ) {
        table.insert( self.children, child );
    }
    
''     pub serialize( stream: OutStream ) {
''         if self.typeId == rootTypeId {
''             foreach child in self.children {
''                 if child.accessMode == "pub" {
''                     child.serialize( stream );
''                 }
''             }
''             return nil;
''         }
        
''         let parentId = self.getParentId();
'' 	if self.orgTypeInfo {
''             stream.write(
''                 '{ parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }' (
''                     parentId, self.typeId, self.orgTypeInfo.typeId ) );
''             return nil;
'' 	}
	
''         fn serializeTypeInfoList( name: str, list: TypeInfo[@] ): str {
''             let work = name;
'' 	    foreach typeInfo, index in list {
'' 	        if index ~= 1 {
'' 		    work = work .. ", ";
'' 	        }   
'' 	        work = "%s%d" (work, typeInfo.typeId );
'' 	    }
''             return work .. "}, ";
''         }
        
''         let txt = ```{ parentId = %d, typeId = %d, baseId = %d, txt = '%s',
'' staticFlag = %s, accessMode = '%s', kind = %d, ```
''         ( parentId, self.typeId, self.get_baseId(), self.txt,
''           self.staticFlag, self.accessMode, self.kind );


''         stream.write( txt .. serializeTypeInfoList( "itemTypeId = {",
''                                                     self.itemTypeInfoList ) ..
''                       serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList ) ..
''                       "children = {\n" );

''         foreach child in self.children {
''             if child.accessMode == "pub" {
''                 child.serialize( stream );
''             }
''         }

''         stream.write( "} },\n" );
''     }


    pub fn serialize( stream: OutStream ) {
        if self.typeId == rootTypeId {
            return nil;
        }
        
        let parentId = self.getParentId();
	if self.orgTypeInfo {
            stream.write(
                '{ parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }' (
                    parentId, self.typeId, self.orgTypeInfo.typeId ) );
            return nil;
	}
	
        fn serializeTypeInfoList( name: str, list: TypeInfo[@], onlyPub: bool ): str {
            let work = name;
	    foreach typeInfo in list {
                if not onlyPub or typeInfo.accessMode == "pub"  {
                    if #work ~=  #name {
		        work = work .. ", ";
                    }
	            work = "%s%d" (work, typeInfo.typeId );
                }
	    }
            return work .. "}, ";
        }
        
        let txt = ```{ parentId = %d, typeId = %d, baseId = %d, txt = '%s',
staticFlag = %s, accessMode = '%s', kind = %d, ```
        ( parentId, self.typeId, self.get_baseId(), self.txt,
          self.staticFlag, self.accessMode, self.kind );


        stream.write(
            txt .. serializeTypeInfoList( "itemTypeId = {",
                                          self.itemTypeInfoList ) ..
            serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList ) ..
            serializeTypeInfoList( "children = {", self.children, true ) .. "}\n" );
    }


    
    pub fn getTxt() : str {
	if self.orgTypeInfo {
	    return self.orgTypeInfo.getTxt() .. "!";
	}
	if self.kind == TypeInfoKindArray {
            if not self.itemTypeInfoList[1] {
                return "[@]";
            }
	    return self.itemTypeInfoList[1].getTxt() .. "[@]";
	}
	if self.kind == TypeInfoKindList {
            if not self.itemTypeInfoList[1] {
                return "[]";
            }
	    return self.itemTypeInfoList[1].getTxt() .. "[]";
	}
	if self.itemTypeInfoList and #self.itemTypeInfoList > 0 {
	    let txt = self.txt .. "<";
	    foreach typeInfo, index in self.itemTypeInfoList {
		if index ~= 1 {
		    txt = txt .. ",";
		}
		txt = txt .. typeInfo.getTxt();
	    }
	    
	    return txt .. ">";
	}
	if self.txt {
	    return self.txt;
	}
	return "";
    }

    pub fn equals( typeInfo: TypeInfo, depth: int ): bool {
        if not typeInfo {
            return false;
        }
	if not depth {
	    depth = 1;
	}
	if self.typeId == typeInfo.typeId {
	    return true;
	}
	'' プリミティブな設定のチェック
	if ''self.externalFlag ~= typeInfo.externalFlag or
	    self.kind ~= typeInfo.kind or
	    self.staticFlag ~= typeInfo.staticFlag or
	    self.accessMode ~= typeInfo.accessMode or
	    self.autoFlag ~= typeInfo.autoFlag or
	    self.nilable ~= typeInfo.nilable
	{
	    '' errorLog( "%s, %s" ( self.externalFlag, typeInfo.externalFlag ) );
	    '' errorLog( "%s, %s" ( self.kind, typeInfo.kind ) );
	    '' errorLog( "%s, %s" ( self.staticFlag, typeInfo.staticFlag ) );
	    '' errorLog( "%s, %s" ( self.accessMode, typeInfo.accessMode ) );
	    '' errorLog( "%s, %s" ( self.autoFlag, typeInfo.autoFlag ) );
	    '' errorLog( "%s, %s" ( self.nilable, typeInfo.nilable ) );
	    return false;
	}

	if (not self.itemTypeInfoList and typeInfo.itemTypeInfoList or
	     self.itemTypeInfoList and not typeInfo.itemTypeInfoList or
	     not self.retTypeInfoList and typeInfo.retTypeInfoList or
	     self.retTypeInfoList and not typeInfo.retTypeInfoList or	     
	     not self.orgTypeInfo and typeInfo.orgTypeInfo or
	     self.orgTypeInfo and not typeInfo.orgTypeInfo )
	{
	    errorLog( "%s, %s", self.itemTypeInfoList, typeInfo.itemTypeInfoList );
	    errorLog( "%s, %s", self.retTypeInfoList, typeInfo.retTypeInfoList );
	    errorLog( "%s, %s", self.orgTypeInfo, typeInfo.orgTypeInfo );
''	    error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
''					   typeInfo.getTxt(), typeInfo.typeId ) );
	    return false;
	}

    	if self.itemTypeInfoList {
	    if #self.itemTypeInfoList ~= #typeInfo.itemTypeInfoList {
		return false;
	    }
	    foreach item, index in self.itemTypeInfoList {
		if not item.equals( typeInfo.itemTypeInfoList[ index ], depth + 1 ) {
''		    error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
''						   typeInfo.getTxt(), typeInfo.typeId ) );
		    return false;
		}
	    }
	}

    	if self.retTypeInfoList {
	    if #self.retTypeInfoList ~= #typeInfo.retTypeInfoList {
''		error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
''					       typeInfo.getTxt(), typeInfo.typeId ) );
		return false;
	    }
	    foreach item, index in self.retTypeInfoList {
		if not item.equals( typeInfo.retTypeInfoList[ index ], depth + 1 ) {
''		    error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
''						   typeInfo.getTxt(), typeInfo.typeId ) );
		    return false;
		}
	    }
	}

	if self.orgTypeInfo and not self.orgTypeInfo.equals( typeInfo.orgTypeInfo, depth + 1 ) {
''	    error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
''					   typeInfo.getTxt(), typeInfo.typeId ) );
	    return false;
	}

	return true;
    }


    pub static fn cloneToPublic( typeInfo: TypeInfo ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
        return new TypeInfo(
            typeInfo.baseTypeInfo, nil, typeInfo.autoFlag,
            typeInfo.externalFlag, typeInfo.staticFlag,
            "pub", typeInfo.txt, typeInfo.parentInfo, typeIdSeed, typeInfo.kind,
            typeInfo.itemTypeInfoList, typeInfo.retTypeInfoList );
    }
    
    
    
    pub static fn create( baseInfo: TypeInfo,
                       parentInfo: TypeInfo, staticFlag: bool, kind: int, txt: str,
                       itemTypeInfo: TypeInfo[@],
		       retTypeInfoList: TypeInfo[@] ): TypeInfo {
	if kind == TypeInfoKindPrim {
	    return builtInTypeMap[ txt ];
	}
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( baseInfo, nil, false, true, staticFlag, "pub", txt,
                                 parentInfo, typeIdSeed,                      
                                 kind, itemTypeInfo, retTypeInfoList );
	return info;
    }

    pub static fn createBuiltin( idName: str, typeTxt: str, kind: int ): TypeInfo {
        let typeId = typeIdSeed + 1;
        if kind == TypeInfoKindRoot {
            typeId = rootTypeId;
        }
        else {
	    typeIdSeed = typeIdSeed + 1;
        }
	let info = new TypeInfo( nil, nil, false, false, false,
				 "pub", typeTxt, rootTypeInfo, typeId, kind );
	typeInfoKind[ idName ] = info;
	builtInTypeMap[ typeTxt ] = info;
        builtInTypeIdSet[ info.typeId ] = true;
	return info;
    }

    pub static fn createList(
        accessMode: str, parentInfo: TypeInfo, itemTypeInfo: TypeInfo[] ): TypeInfo {
	if not itemTypeInfo or #itemTypeInfo == 0 {
	    error( "illegal list type: %s" (itemTypeInfo) );
	}	
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( nil, nil, false, false, false, accessMode, "",
                             rootTypeInfo, typeIdSeed, TypeInfoKindList, itemTypeInfo  );
    }

    pub static fn createArray(
        accessMode: str, parentInfo: TypeInfo, itemTypeInfo: TypeInfo[] ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( nil, nil, false, false, false, accessMode, "",
                             rootTypeInfo, typeIdSeed, TypeInfoKindArray, itemTypeInfo );              
    }

    pub static fn createMap(
        accessMode: str, parentInfo: TypeInfo,
        keyTypeInfo: TypeInfo, valTypeInfo: TypeInfo ): TypeInfo
    {
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( nil, nil, false, false, false, accessMode, "Map",
                             rootTypeInfo, typeIdSeed, TypeInfoKindMap,
                             [@ keyTypeInfo, valTypeInfo ] );              
    }
    
    pub static fn createClass(
        baseInfo: TypeInfo, parentInfo: TypeInfo, externalFlag: bool,
        accessMode: str, className: str ): TypeInfo
    {
        if className == "str" {
            return builtInTypeMap[ className ]@TypeInfo;
        }
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo(
            baseInfo, nil, false, externalFlag, false, accessMode,
            className, parentInfo, typeIdSeed, TypeInfoKindClass ); 
	return info;
    }

    pub static fn createFunc(
        macroFlag: bool, parentInfo: TypeInfo,
        autoFlag: bool, externalFlag: bool, staticFlag: bool, accessMode: str,
	funcName: str, argTypeList: TypeInfo[@], retTypeInfoList: TypeInfo[@] ): TypeInfo
    {   
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo(
            nil, nil, autoFlag, externalFlag, staticFlag,
            accessMode, funcName, parentInfo, typeIdSeed,
            macroFlag and TypeInfoKindMacro or TypeInfoKindFunc,
            argTypeList or [], retTypeInfoList or [] );
	return info;
    }
}

let typeInfoNone = TypeInfo.createBuiltin( "None", "", TypeInfoKindPrim );
let typeInfoRoot = TypeInfo.createBuiltin( "Root", ":", TypeInfoKindRoot );
let typeInfoStem = TypeInfo.createBuiltin( "Stem", "stem" , TypeInfoKindPrim );
let typeInfoNil = TypeInfo.createBuiltin( "Nil", "nil" , TypeInfoKindPrim );
let typeInfoBool = TypeInfo.createBuiltin( "Bool", "bool" , TypeInfoKindPrim );
let typeInfoInt = TypeInfo.createBuiltin( "Int", "int" , TypeInfoKindPrim );
let typeInfoReal = TypeInfo.createBuiltin( "Real", "real" , TypeInfoKindPrim );
let typeInfoChar = TypeInfo.createBuiltin( "char", "char" , TypeInfoKindPrim );
let typeInfoString = TypeInfo.createBuiltin( "String", "str" , TypeInfoKindClass );
let typeInfoMap = TypeInfo.createBuiltin( "Map", "Map" , TypeInfoKindMap );
let typeInfoList = TypeInfo.createBuiltin( "List", "List" , TypeInfoKindList );
let typeInfoArray = TypeInfo.createBuiltin( "Array", "Array" , TypeInfoKindArray );
let typeInfoForm = TypeInfo.createBuiltin( "Form", "form" , TypeInfoKindFunc );
let typeInfoSymbol = TypeInfo.createBuiltin( "Symbol", "sym" , TypeInfoKindPrim );
let typeInfoStat = TypeInfo.createBuiltin( "Stat", "stat" , TypeInfoKindPrim );


pub class Scope {
    pri let parent: Scope { pub };
    pri let symbol2TypeInfoMap: Map<str,TypeInfo> { pub };
    pri let className2ScopeMap: Map<str,Scope> { pub };
    pri let classFlag: bool;
    pri let inheritList: Scope[];
    fn __init( parent: Scope, classFlag: bool, inheritList: Scope[] ) {
	self.parent = parent;
	self.symbol2TypeInfoMap = {};
	self.className2ScopeMap = {};
        self.inheritList = inheritList;
        self.classFlag = classFlag;
    }
    pub fn add( name:str, typeInfo: TypeInfo ) {
	self.symbol2TypeInfoMap[ name ] = typeInfo;
    }
    pub fn addClass( name:str, typeInfo: TypeInfo, scope: Scope ) {
	self.add( name, typeInfo );
	self.className2ScopeMap[ name ] = scope;
    }

    pub fn getClassScope( name: str ) : Scope {
	let scope = self.className2ScopeMap[ name ];
	if not scope and self.parent {
	    scope = self.parent.getClassScope( name );
	}
	return scope;
    }
    
    pub fn getTypeInfoChild( name: str ) : TypeInfo {
	return self.symbol2TypeInfoMap[ name ];
    }

    pub fn getTypeInfo( name: str ) : TypeInfo {
	let typeInfo = self.symbol2TypeInfoMap[ name ];
	if typeInfo {
	    return typeInfo;
	}
        if self.inheritList {
            foreach scope in self.inheritList {
                typeInfo = scope.getTypeInfo( name );
                if typeInfo {
                    return typeInfo;
                }
            }
        }
	if self.parent {
	    return self.parent.getTypeInfo( name );
	}
	return builtInTypeMap[ name ];
    }

    pub fn getTypeInfoMethod( name: str, includeSelfFlag: bool ) : TypeInfo {
        if self.classFlag {
            let typeInfo: TypeInfo = nil;
            if includeSelfFlag {
	        let typeInfo = self.symbol2TypeInfoMap[ name ];
	        if typeInfo {
	            return typeInfo;
	        }
            }
            if self.inheritList {
                foreach scope in self.inheritList {
                    typeInfo = scope.getTypeInfoMethod( name, true );
                    if typeInfo {
                        return typeInfo;
                    }   
                }   
            }   
        }
	if self.parent {
	    return self.parent.getTypeInfoMethod( name, true );
	}
        return nil;
    }
}

pub class NodePos {
    pri let lineNo: int;
    pri let column: int;
}

pub class Node {
    pri let kind: int { pub };
    pri let pos: NodePos;
    pri let expType: TypeInfo { pub };
    pri let expTypeList: TypeInfo[];
    pri let info: stem {pub};
    pub let filter: form;
}

pub class ImportNode extend Node {
}
pub class RootNode extend Node {
}
pub class RefTypeNode extend Node {
}
pub class IfNode extend Node {
}
pub class SwitchNode extend Node {
}
pub class WhileNode extend Node {
}
pub class RepeatNode extend Node {
}
pub class ForNode extend Node {
}
pub class ApplyNode extend Node {
}
pub class ForeachNode extend Node {
}
pub class ForsortNode extend Node {
}
pub class ReturnNode extend Node {
}
pub class BreakNode extend Node {
}
pub class ExpNewNode extend Node {
}
pub class ExpListNode extend Node {
}
pub class ExpRefNode extend Node {
}
pub class ExpOp2Node extend Node {
}
pub class ExpCastNode extend Node {
}
pub class ExpOp1Node extend Node {
}
pub class ExpRefItemNode extend Node {
}
pub class ExpCallNode extend Node {
}
pub class ExpDDDNode extend Node {
}
pub class ExpParenNode extend Node {
}
pub class BlockNode extend Node {
}
pub class StmtExpNode extend Node {
}
pub class RefFieldNode extend Node {
}
pub class DeclVarNode extend Node {
}
pub class DeclFuncNode extend Node {
}
pub class DeclMethodNode extend Node {
}
pub class DeclConstrNode extend Node {
}
pub class DeclMemberNode extend Node {
}
pub class DeclArgNode extend Node {
}
pub class DeclArgDDDNode extend Node {
}
pub class DeclClassNode extend Node {
}
pub class LiteralNilNode extend Node {
}
pub class LiteralCharNode extend Node {
}
pub class LiteralIntNode extend Node {
}
''
'''
pub class LiteralRealNode extend Node {
}
pub class LiteralArrayNode extend Node {
}
pub class LiteralListNode extend Node {
}
pub class LiteralMapNode extend Node {
}
pub class LiteralStringNode extend Node {
}
pub class LiteralBoolNode extend Node {
}
'''

class NamespaceInfo {
    pub let name: str;
    pub let scope: Scope;
    pub let typeInfo: TypeInfo;
}

pub class TransUnit {
   
    pri let scope: Scope;
    '' 解析中のクラスを保持する
    pri let namespaceList: NamespaceInfo[];
    pri let classList: NamespaceInfo[];
    pri let moduleName2Info: Map<str,stem>;
    pri let parser: Parser.Parser;
    pri let typeId2Scope: Map<int,Scope>;
    pri let typeInfo2ClassNode: Map<TypeInfo,Node>;
    pri let pushbackToken: stem;
    pri let currentToken: stem;
    pri let currentNamespace: str;
    pri let errMessList: str[] { pub };
    
    fn __init() {
	self.scope = new Scope( nil, false );
	self.namespaceList = [ typeInfoRoot ]; 
	self.classList = {};
	self.typeId2Scope = {};
        self.typeInfo2ClassNode = {};
        self.currentToken = nil;
	self.errMessList = {};
    }

    pri fn addErrMess( pos: Parser.Position, mess: str ) {
	table.insert( self.errMessList,
		      "%s:%d:%d: %s" ( self.parser.getStreamName(),
				       pos.lineNo, pos.column, mess ) );
    }
    

    pri fn pushScope( classFlag: bool, inheritList: Scope ): Scope {
	self.scope = new Scope( self.scope, classFlag, inheritList );
	return self.scope;
    }

    pri fn popScope() {
	self.scope = self.scope.get_parent();
    }

    pri fn pushNamespace( name:str, typeInfo: TypeInfo, scope: Scope ) {
        let namespace = new NamespaceInfo( name, scope, typeInfo );
	table.insert( self.namespaceList, namespace );
    }

    pri fn popNamespace() {
	table.remove( self.namespaceList );
    }

    pri fn getCurrentClass() : TypeInfo {
        if #self.classList == 0 {
            return rootTypeInfo;
        }
        let classInfo = self.classList[ #self.classList ];
        return classInfo.typeInfo;
    }

    pri fn getCurrentNamespaceTypeInfo() : TypeInfo {
        return self.namespaceList[ #self.namespaceList ].typeInfo;
    }
    
    pri fn pushClass( baseInfo: TypeInfo,
                   externalFlag: bool, name:str, accessMode:str ): TypeInfo {
        let typeInfo = self.scope.getTypeInfoChild( name );
	if not typeInfo {
            let parentInfo = self.getCurrentNamespaceTypeInfo();
	    typeInfo = TypeInfo.createClass(
                baseInfo, parentInfo, externalFlag, accessMode, name );
            let inheritList:Scope[] = nil;
            if baseInfo {
                inheritList = [ self.typeId2Scope[ baseInfo.get_typeId() ] ];
            }
            
	    let scope = self.pushScope( true, inheritList );
	    scope.get_parent().addClass( name, typeInfo, scope );
	}
	else {
	    self.scope = self.scope.getClassScope( name );
	}
        let namespace = new NamespaceInfo( name, self.scope, typeInfo );
	table.insert( self.namespaceList, namespace);
	table.insert( self.classList, namespace );
	self.typeId2Scope[ typeInfo.get_typeId() ] = self.scope;
	return typeInfo;
    }

    pri fn popClass() {
	self.popScope();
	table.remove( self.namespaceList );
	table.remove( self.classList );
    }
    pri fn addMethod( className: str, methodNode: Node ) {
        let classTypeInfo = self.scope.getTypeInfo( className );
        let classNodeInfo = self.typeInfo2ClassNode[ classTypeInfo ].info;
            
        classNodeInfo.outerMethodSet[ methodNode.info.name.txt ] = true;
        table.insert( classNodeInfo.fieldList, methodNode );
    }

    pri fn analyzeDecl( accessMode: str, staticFlag:
		     bool, firstToken: stem, token: stem ): Node;
    pri fn analyzeDeclVar( accessMode: str, staticFlag: bool, firstToken: stem ): Node;
    pri fn analyzeDeclFunc(
        overrideFlag: bool, accessMode: str, staticFlag: bool,
        classNameToken: Parser.Token,
        firstToken: Parser.Token, name: Parser.Token ) : Node;
    pri fn analyzeDeclClass( classAccessMode: str, classToken: stem ): Node;
    pri fn analyzeExp( skipOp2Flag: bool, opLevel: int ): Node;
    pri fn analyzeStatementList( stmtList: stem[], termTxt: str );
    pri fn analyzeStatement( termTxt: str );
    pri fn analyzeExpSymbol( firstToken: stem, token: stem,
			  mode: str, prefixExp: stem, skipFlag: bool ): Node;
    pri fn analyzeExpList(): Node;
}

let opLevelBase = 0;
let op2levelMap:Map<str,int> = {};
let op1levelMap:Map<str,int> = {};
fn regOpLevel( opnum: int, opList: str[@] ) {
    opLevelBase = opLevelBase + 1;
    if opnum == 1 {
        foreach op in opList {
            op1levelMap[ op ] = opLevelBase;
        }
    }
    else {
        foreach op in opList {
            op2levelMap[ op ] = opLevelBase;
        }
    }
}
regOpLevel( 2, [@ "=" ] );
regOpLevel( 2, [@ "or" ] );
regOpLevel( 2, [@ "and" ] );
regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
regOpLevel( 2, [@ "|" ] );
regOpLevel( 2, [@ "~" ] );
regOpLevel( 2, [@ "&" ] );
regOpLevel( 2, [@ "<<", ">>" ] );
regOpLevel( 2, [@ ".." ] );
regOpLevel( 2, [@ "+", "-" ] );
regOpLevel( 2, [@ "*", "/", "//", "%" ] );
regOpLevel( 1, [@ "`", ",,", ",,," ] );
regOpLevel( 1, [@ "not", "#", "-", "~" ] );
regOpLevel( 1, [@ "^" ] );


let nodeKind2NameMap: Map<int,str> = {};
let nodeKindSeed = 1;
pub let nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
    let kind = nodeKindSeed;
    nodeKindSeed = nodeKindSeed + 1;
    nodeKind2NameMap[ kind ] = name;
    nodeKind[ name ] = kind;
    return kind;
}

let nodeKindNone = regKind( 'None' );
let nodeKindImport = regKind( 'Import' );
let nodeKindRoot = regKind( 'Root' );
let nodeKindRefType = regKind( 'RefType' );
let nodeKindIf = regKind( 'If' );
let nodeKindSwitch = regKind( 'Switch' );
let nodeKindWhile = regKind( 'While' );
let nodeKindRepeat = regKind( 'Repeat' );
let nodeKindFor = regKind( 'For' );
let nodeKindApply = regKind( 'Apply' );
let nodeKindForeach = regKind( 'Foreach' );
let nodeKindForsort = regKind( 'Forsort' );
let nodeKindReturn = regKind( 'Return' );
let nodeKindBreak = regKind( 'Break' );
let nodeKindExpNew = regKind( 'ExpNew' );
let nodeKindExpList = regKind( 'ExpList' );
let nodeKindExpRef = regKind( 'ExpRef' );
let nodeKindExpOp2 = regKind( 'ExpOp2' );
let nodeKindExpCast = regKind( 'ExpCast' );
let nodeKindExpOp1 = regKind( 'ExpOp1' );
let nodeKindExpRefItem = regKind( 'ExpRefItem' );
let nodeKindExpCall = regKind( 'ExpCall' );
let nodeKindExpDDD = regKind( 'ExpDDD' );
let nodeKindExpParen = regKind( 'ExpParen' );
let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); '' macro expand
let nodeKindExpMacroEva = regKind( 'ExpMacroEva' ); '' ,,
let nodeKindExpMacroSym = regKind( 'ExpMacroSym' ); '' ,,,
let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); '' `{}
let nodeKindBlock = regKind( 'Block' );
let nodeKindStmtExp = regKind( 'StmtExp' );
let nodeKindRefField = regKind( 'RefField' );
let nodeKindDeclVar = regKind( 'DeclVar' );
let nodeKindDeclFunc = regKind( 'DeclFunc' );
let nodeKindDeclMethod = regKind( 'DeclMethod' );
let nodeKindDeclConstr = regKind( 'DeclConstr' );
let nodeKindDeclMember = regKind( 'DeclMember' );
let nodeKindDeclArg = regKind( 'DeclArg' );
let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
let nodeKindDeclClass = regKind( 'DeclClass' );
let nodeKindDeclMacro = regKind( 'DeclMacro' );
let nodeKindLiteralNil = regKind( 'LiteralNil' );
let nodeKindLiteralChar = regKind( 'LiteralChar' );
let nodeKindLiteralInt = regKind( 'LiteralInt' );
let nodeKindLiteralReal = regKind( 'LiteralReal' );
let nodeKindLiteralArray = regKind( 'LiteralArray' );
let nodeKindLiteralList = regKind( 'LiteralList' );
let nodeKindLiteralMap = regKind( 'LiteralMap' );
let nodeKindLiteralString = regKind( 'LiteralString' );
let nodeKindLiteralBool = regKind( 'LiteralBool' );


let quotedChar2Code = {};
quotedChar2Code[ 'a' ] = 7;    '' \a
quotedChar2Code[ 'b' ] = 8;    '' \b
quotedChar2Code[ 't' ] = 9;    '' \t
quotedChar2Code[ 'n' ] = 10;   '' \t
quotedChar2Code[ 'v' ] = 11;   '' \v
quotedChar2Code[ 'f' ] = 12;   '' \f 
quotedChar2Code[ 'r' ] = 13;   '' \r
quotedChar2Code[ '\\' ] = ?\\; '' \\
quotedChar2Code[ '"' ] = ?\";  '' "
quotedChar2Code[ "'" ] = ?\';  '' '

pub fn getNodeKindName( kind: int ): str {
    return nodeKind2NameMap[ kind ];
}

pub fn nodeFilter( node: stem, filter: form, ... ) : stem {
    if not filter[ node.kind ] {
	error( string.format( "none filter -- %s",
			      getNodeKindName( node.kind ) ));
    }
    return filter[ node.kind ]( filter, node, ... );
}

fn TransUnit.registBuiltInScope() {
    let builtInInfo: Map<str,Map<str,Map<str,str[]>>> = {
	"": {
            "type": { "ret": ["str"] },
            "error": { "ret": [] },   
            "print": { "ret": [] },
            "tonumber": { "ret": ["int"] },
            "load": { "ret": ["stem", "str"] },
        },           
	"io": {
            "open": { "ret": ["stem"] },
        },      
	"os": {
            "clock": { "ret": ["int"] },
        },      
	"string": {
            "find": { "ret": ["int", "int"] },
            "byte": { "ret": ["int"] },
            "format": { "ret": ["str"] },
            "rep": { "ret": ["str"] },
            "gmatch": { "ret": ["stem"] },
            "gsub": { "ret": ["str"] },
            "sub": { "ret": ["str"] },
        },           
	"str": {
            "find": { "methodFlag": [], "ret": ["int", "int"] },
            "byte": { "methodFlag": [], "ret": ["int"] },
            "format": { "methodFlag": [], "ret": ["str"] },
            "rep": { "methodFlag": [], "ret": ["str"] },
            "gmatch": { "methodFlag": [], "ret": ["stem"] },
            "gsub": { "methodFlag": [], "ret": ["str"] },
            "sub": { "methodFlag": [], "ret": ["str"] },
        },           
	"table": {
            "insert": { "ret": [""] },  
            "remove": { "ret": [""] },
            "unpack": { "ret": ["stem"] },
        },
	"debug": {
            "getinfo": { "ret": ["stem"] },
        },      
	"_luneScript": {
            "loadModule": { "ret": ["stem"] },
        },           
    };

    
    forsort typeInfo, name in builtInTypeMap {
        if typeInfo.kind == TypeInfoKindClass {
	    let scope = self.pushScope( true );
	    scope.get_parent().addClass( name, typeInfo, scope );
            self.popScope();
        }
        else {
	    self.scope.add( name, typeInfo );
        }
    }
    
    forsort name2FuncInfo, name in builtInInfo {
        let parentInfo = typeInfoRoot;
	if name ~= "" {
	    let classTypeInfo = self.pushClass( nil, true, name, "pri" );
            parentInfo = classTypeInfo;
            builtInTypeIdSet[ classTypeInfo.get_typeId() ] = true;
	}
        if not parentInfo {
            error( "parentInfo is nil" );
        }
	forsort info, funcName in name2FuncInfo {
            let retTypeList: TypeInfo[] = {};
            foreach retType in info[ "ret" ] {
                table.insert( retTypeList, builtInTypeMap[ retType ] );
            }
            let typeInfo = TypeInfo.createFunc(
                false, parentInfo, false, true, not info[ "methodFlag" ], "pub",
                funcName, nil, retTypeList );
            builtInTypeIdSet[ typeInfo.get_typeId() ] = true;
	    self.scope.add( funcName, typeInfo );
	}
	if name ~= "" {
	    self.popClass();
	}
    }
}


fn TransUnit.createNode( kind: int, pos: stem, expTypeList: TypeInfo[], info: Map ): Map {
    if not getNodeKindName( kind ) {
	error( string.format( "%d:%d: not found nodeKind", pos.lineNo, pos.column ) );
    }
    return new Node( kind, pos, expTypeList[1], expTypeList, info, nodeFilter );
}

fn TransUnit.error( mess: str ) {
    let pos = { "lineNo": 0, "column": 0 };
    let txt = "";
    if self.currentToken {
	pos = self.currentToken.pos;
	txt = self.currentToken.txt;
    }
    error( string.format( "%s:%d:%d:(%s) %s",
                          self.parser.getStreamName(),
                          pos.lineNo, pos.column, txt, mess ) );
}

fn TransUnit.createNoneNode(): Node {
    return self.createNode( nodeKindNone, { "lineNo": 0, "column": 0 },
                            [ typeInfoNone ], {} );
}

fn TransUnit.getTokenNoErr(): stem {
    if self.pushbackToken {
	self.currentToken = self.pushbackToken;
	self.pushbackToken = nil;
	return self.currentToken;
    }

    let commentList = {};
    let token = nil;
    while true {
	token = self.parser.getToken();
	if not token {
	    break;
	}
	if token.kind ~= Parser.kind.Cmnt {
	    break;
	}
	table.insert( commentList, token );
    }

    if token {
	token.commentList = commentList;
    }
    self.currentToken = token;
    return token;
}


fn TransUnit.getToken( mess: str ): Parser.Token {
    let token = self.getTokenNoErr();
    if not token {
	return Parser.getEofToken();
    }
    self.currentToken = token;
    return self.currentToken;
}

fn TransUnit.pushback() {
    if self.pushbackToken {
	error( string.format( "multiple pushback:%d:%d: %s, %s",
			      self.currentToken.pos.lineNo,
			      self.currentToken.pos.column,
			      self.pushbackToken.txt, self.currentToken.txt ) );
    }
    self.pushbackToken = self.currentToken;
    self.currentToken = nil;
}

fn TransUnit.checkSymbol( token: stem ): stem {
    if token.kind ~= Parser.kind.Symb and
	token.kind ~= Parser.kind.Kywd and
	token.kind ~= Parser.kind.Type
    {
	self.error( "illegal symbol" );
    }
    return token;
}

fn TransUnit.getSymbolToken(): Parser.Token {
    return self.checkSymbol( self.getToken() );
}


fn TransUnit.checkToken( token: stem, txt: str ): stem {
    if not token or token.txt ~= txt {
	self.error( string.format( "not found -- %s", txt ) );
    }
    return token;
}

fn TransUnit.checkNextToken( txt: str ): stem {
    return self.checkToken( self.getToken(), txt );
}


fn TransUnit.analyzeBlock( blockKind: str, scope: Scope ): stem {
    let token = self.checkNextToken( "{" );

    if not scope {
	self.pushScope( false );
    }

    let stmtList = {};
    self.analyzeStatementList( stmtList, "}" );

    self.checkNextToken( "}" );

    if not scope {
	self.popScope();
    }
  
    let node = self.createNode( nodeKindBlock, token.pos, [ typeInfoNone ], 
				{ "kind": blockKind, "stmtList": stmtList } );
    
    return node;
}

class _TypeInfo {
    pub let baseId: int;
    pub let itemTypeId: int[];
    pub let retTypeId: int[];
    pub let parentId: int;
    pub let typeId: int;
    pub let txt: str;
    pub let kind: int;
    pub let staticFlag: bool;
    pub let nilable: bool;
    pub let orgTypeId: int;
    pub let children: int[];
}
class _ModuleInfo {
    pub let _className2InfoMap: Map<str,Map<str,stem>>;
    pub let _typeInfoList: _TypeInfo[];
    pub let _varName2InfoMap: Map<str,stem>;
    pub let _funcName2InfoMap: Map<str,stem>;
}

fn TransUnit.analyzeImport( token: stem ): Node {
    let moduleToken = self.getToken();
    let modulePath = moduleToken.txt;
    let nextToken = {};

    let nameList = [ moduleToken.txt ];
    
    while true {
	nextToken = self.getToken();
	if nextToken.txt == "." {
	    nextToken = self.getToken();
	    moduleToken = nextToken;
	    modulePath = "%s.%s" ( modulePath, moduleToken.txt );
	    table.insert( nameList, moduleToken.txt );
	}
	else {
	    break;
	}
    }

    '' foreach moduleName in nameList {
    '' 	self.pushClass( moduleName );
    '' }
    let moduleTypeInfo = self.pushClass( nil, true, moduleToken.txt, "pub" );

    let moduleInfo: _ModuleInfo = _luneScript.loadModule( modulePath );
    self.moduleName2Info[ modulePath ] = moduleInfo;

    '' 型情報の登録
    let typeId2TypeInfo: Map<int,TypeInfo> = {};
    typeId2TypeInfo[ rootTypeId ] = typeInfoRoot;
    foreach typeInfo in builtInTypeMap@Map<str,TypeInfo> {
        typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
    }

    let typeId2Scope: Map<int,Scope> = {};
    typeId2Scope[ rootTypeId ] = self.scope;
    
    fn registTypeInfo( atomInfo: _TypeInfo ): TypeInfo {
        let newTypeInfo: TypeInfo = nil;
        if not builtInTypeIdSet[ atomInfo.typeId ] {
            
	    if atomInfo.nilable {
		let orgTypeInfo = typeId2TypeInfo[ atomInfo.orgTypeId ];
                newTypeInfo = orgTypeInfo.get_nilableTypeInfo();
                typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
	    }
	    else {
		let itemTypeInfo = {};
		foreach typeId in atomInfo.itemTypeId {
	            table.insert( itemTypeInfo, typeId2TypeInfo[ typeId ] );
		}
		let retTypeInfo = {};
		foreach typeId in atomInfo.retTypeId {
	            table.insert( retTypeInfo, typeId2TypeInfo[ typeId ] );
		}
                let parentInfo = rootTypeInfo;
                if atomInfo.parentId ~= rootTypeId {
                    parentInfo = typeId2TypeInfo[ atomInfo.parentId ];
                }
                let baseInfo = typeId2TypeInfo[ atomInfo.baseId ];

                if atomInfo.kind == TypeInfoKindClass {
                    let parentScope = typeId2Scope[ atomInfo.parentId ];
                    let baseScope = typeId2Scope[ atomInfo.baseId ];

                    let scope = new Scope(
                        parentScope, true, baseScope and [ baseScope ] or nil );

                    newTypeInfo = TypeInfo.createClass(
                        baseInfo, parentInfo, true, "pub", atomInfo.txt );
                    typeId2Scope[ atomInfo.typeId ] = scope;


		    typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
                    
	            parentScope.addClass( atomInfo.txt, newTypeInfo, scope );
                    
                }
                else {
                    newTypeInfo = TypeInfo.create(
                        baseInfo, parentInfo, atomInfo.staticFlag, atomInfo.kind, 
                        atomInfo.txt, itemTypeInfo, retTypeInfo );
                    
		    typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;

                    if atomInfo.kind == TypeInfoKindFunc {
                        typeId2Scope[ atomInfo.parentId ].add(
                            atomInfo.txt, newTypeInfo );

                        let parentScope = typeId2Scope[ atomInfo.parentId ];
                        let scope = new Scope( parentScope, false );

                        typeId2Scope[ atomInfo.typeId ] = scope;
                    }
                }
	    }
        }
        else {
            newTypeInfo = builtInTypeMap[ atomInfo.txt ];
	    typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
        }
        return newTypeInfo;
    }

    '' 初めに child 以外で TypeInfo を登録
    foreach atomInfo in moduleInfo._typeInfoList {
        registTypeInfo( atomInfo );
    }
    '' 次に child を登録
    foreach atomInfo in moduleInfo._typeInfoList {
        if #atomInfo.children > 0 {
            let scope = typeId2Scope[ atomInfo.typeId ];
            foreach childId in atomInfo.children {
                let typeInfo = typeId2TypeInfo[ childId ];
                if typeInfo {
                    scope.add( typeInfo.getTxt(), typeInfo );
                }
            }
        }
    }

    

    '' メンバーの登録
    forsort classInfo, className in moduleInfo._className2InfoMap {
	self.pushClass( nil, true, className, "pub" );
	foreach fieldInfo, fieldName in classInfo {
            let fieldTypeInfo: TypeInfo = nil;
            let typeId = fieldInfo[ "typeId" ];
            fieldTypeInfo = typeId2TypeInfo[ typeId ];
	    self.scope.add( fieldName, fieldTypeInfo );
	}
	self.popClass();
    }

    '' 変数登録
    foreach varInfo, varName in moduleInfo._varName2InfoMap {
	self.scope.add( varName, typeId2TypeInfo[ varInfo[ "typeId" ] ] );
    }

    self.popClass();

    '' foreach moduleName in nameList {
    '' 	self.popClass();
    '' }
    
    self.checkToken( nextToken, ";" );

    return self.createNode( nodeKindImport, token.pos, [ typeInfoNone ], modulePath );
}

fn TransUnit.analyzeIf( token: stem ): stem {
    let list = {};
    table.insert(
	list, { "kind": "if", "exp": self.analyzeExp(),
		"block": self.analyzeBlock( "if" ) } );

    let nextToken = self.getToken();
    if nextToken.txt == "elseif" {
	while nextToken.txt == "elseif" {
	    table.insert(
		list, { "kind": "elseif", "exp": self.analyzeExp(),
			"block": self.analyzeBlock( "elseif" ) } );
	    nextToken = self.getToken();
	}
    }

    if nextToken.txt == "else" {
	table.insert(
	    list, { "kind": "else", "block": self.analyzeBlock( "else" ) } );
    }
    else {
	self.pushback();
    }

    return self.createNode(
	nodeKindIf, token.pos, [ typeInfoNone ], list );
}


fn TransUnit.analyzeSwitch( firstToken: stem ): stem {
    let exp = self.analyzeExp();

    self.checkNextToken( "{" );

    let caseList: stem[] = {};

    let nextToken = self.getToken();
    while ( nextToken.txt == "case" ) {
        self.checkToken( nextToken, "case" );
        let condexpList = self.analyzeExpList();
        let condBock = self.analyzeBlock( "switch" );
        table.insert( caseList, { "expList": condexpList, "block": condBock } );
        nextToken = self.getToken();
    }

    let defaultBlock: Node = nil;
    if nextToken.txt == "default" {
        defaultBlock = self.analyzeBlock( "default" );
    }
    else {
	self.pushback();
    }
    self.checkNextToken( "}" );

    let info: stem = { "exp": exp, "caseList": caseList, "default": defaultBlock };
    
    return self.createNode(
	nodeKindSwitch, firstToken.pos, [ typeInfoNone ], info );
}


fn TransUnit.analyzeWhile( token: stem ): stem {
    let info = { "exp": self.analyzeExp(), "block": self.analyzeBlock( "while" ) };
    return self.createNode(
	nodeKindWhile, token.pos, [ typeInfoNone ], info );
}

fn TransUnit.analyzeRepeat( token: stem ): stem {
    let scope = self.pushScope( false );
    let info = { "block": self.analyzeBlock( "repeat", scope ),
		 "exp": self.analyzeExp() };
    self.popScope();
    let node = self.createNode(
        nodeKindRepeat, token.pos, [ typeInfoNone ], info );
    self.checkNextToken( ";" );
    return node;
}

fn TransUnit.analyzeFor( token: stem ): stem {

    let scope = self.pushScope( false );

    let val = self.getToken();
    if val.kind ~= Parser.kind.Symb {
	self.error( "not symbol" );
    }
    self.checkNextToken( "=" );
    let exp1 = self.analyzeExp();
    self.scope.add( val.txt, exp1.expType );
    self.checkNextToken( "," );
    let exp2 = self.analyzeExp();
    let token = self.getToken();
    let exp3 = nil;
    if token.txt == "," {
	exp3 = self.analyzeExp();
    }
    else {
	self.pushback();
    }

    let info = { "block": self.analyzeBlock( "for", scope ), "val": val,
		 "init": exp1, "to": exp2, "delta": exp3 };
    self.popScope();
    let node = self.createNode( nodeKindFor, token.pos, [ typeInfoNone ], info );
    return node;
}

fn TransUnit.analyzeApply( token: stem ): stem {
    let scope = self.pushScope();
    let varList = {};
    let nextToken = nil;
    repeat {
	let var = self.getToken();
	if var.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	table.insert( varList, var );
	nextToken = self.getToken();
    } nextToken.txt ~= ",";
    self.checkToken( nextToken, "of" );

    let exp = self.analyzeExp();
    if exp.kind ~= nodeKindExpCall {
	self.error( "not call" );
    }

    let block = self.analyzeBlock( "apply", scope );
    self.popScope();

    let info = { "varList": varList, "exp": exp, "block": block };
    return self.createNode( nodeKindApply, token.pos, [ typeInfoNone ], info );
}

fn TransUnit.analyzeForeach( token: stem, sortFlag: bool ): stem {
    let scope = self.pushScope();
    let valSymbol = nil;
    let keySymbol = nil;
    let nextToken = nil;
    for index = 1, 2 {
	let sym = self.getToken();
	if sym.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	if index == 1 {
	    valSymbol = sym;
	}
	else {
	    keySymbol = sym;
	}
	nextToken = self.getToken();
	if nextToken.txt ~= "," {
	    break;
	}
    }
    self.checkToken( nextToken, "in" );

    let exp = self.analyzeExp();
    if not exp.expType {
	self.error( "unknown type of exp -- %d:%d" (token.pos.lineNo, token.pos.column) );
    }
    else {
	let itemTypeInfoList = exp.expType.get_itemTypeInfoList();
	if exp.expType.get_kind() == TypeInfoKindMap {
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 2 ] );
	    if keySymbol {
		self.scope.add( keySymbol.txt, itemTypeInfoList[ 1 ] );
	    }   
	}	
	elseif exp.expType.get_kind() == TypeInfoKindList or
	    exp.expType.get_kind() == TypeInfoKindArray
	{	
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 1 ] );
	    if keySymbol {
		self.scope.add( keySymbol.txt, typeInfoInt );
	    }
	    else {
		self.scope.add( "__index", typeInfoInt );
	    }   
	}
        else {
            self.error( "unknown kind type of exp for foreach-- %d:%d" (exp.pos.lineNo,
                                                                         exp.pos.column) );
        }
    }
	

    let block = self.analyzeBlock( "foreach", scope );

    self.popScope();

    let info = { "val": valSymbol, "key": keySymbol,
		 "exp": exp, "block": block, "sort": sortFlag };
    return self.createNode( sortFlag and nodeKindForsort or nodeKindForeach,
			    token.pos, [ typeInfoNone ], info );	    
}

fn TransUnit.analyzeRefType( accessMode: str ): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let refFlag = false;
    if token.txt == "&" {
	refFlag = true;
	token = self.getToken();
    }
    let mutFlag = false;
    if token.txt == "mut" {
	mutFlag = true;
	token = self.getToken();
    }
    ''let name = self.checkSymbol( token );
    let name: Node = nil;
    let typeInfo = typeInfoStem;
    if self.checkSymbol( token ) {
	name = self.analyzeExpSymbol( firstToken, token, "symbol", token, true );
	typeInfo = name.expType;
    }
    else {
	self.pushback();
    }

    token = self.getToken();
    if token.txt == "!" {
	typeInfo = typeInfo.get_nilableTypeInfo();
	token = self.getToken();
    }
    let arrayMode = "no";
    if token.txt == '[' or token.txt == '[@' {
	if token.txt == '[' {
	    arrayMode = "list";
	    typeInfo = TypeInfo.createList(
                accessMode, self.getCurrentClass(), [ typeInfo ] );
	}
	else {
	    arrayMode = "array";
	    typeInfo = TypeInfo.createArray(
                accessMode, self.getCurrentClass(), [ typeInfo ] );
	}
	token = self.getToken();
	if token.txt ~= ']' {
	    self.pushback();
	    self.checkNextToken( ']' );
	}
    }
    elseif token.txt == "<" {
	let genericList: Node[] = {};
	let nextToken: stem = nil;
	repeat {
	    let typeExp = self.analyzeRefType( accessMode );
		
	    table.insert( genericList, typeExp.expType );
	    nextToken = self.getToken();
	} nextToken.txt ~= ",";
	self.checkToken( nextToken, '>' );
	if typeInfo.kind == TypeInfoKindMap {
	    typeInfo = TypeInfo.createMap(
                accessMode, self.getCurrentClass(),
                genericList[1] or typeInfoStem,
                genericList[2] or typeInfoStem );
	}
	else {
	    self.error( string.format( "not support generic: %s", typeInfo.getTxt() ) );
	}
    }
    else {
	self.pushback();
    }


    return self.createNode(
	nodeKindRefType, firstToken.pos, [ typeInfo ], 
	{ "name": name, "refFlag": refFlag,
	  "mutFlag": mutFlag, "array": arrayMode } );
}

fn TransUnit.analyzeDeclArgList( accessMode:str, argList: Node[] ) : Parser.Token {
    let token: Parser.Token = Parser.noneToken;
    repeat {
	let argName = self.getToken();
	if argName.txt == ")" {
	    token = argName;
	    break;
	}
	elseif argName.txt == "..." {
	    table.insert(
		argList,
		self.createNode(
		    nodeKindDeclArgDDD, argName.pos, [ typeInfoNone ], argName ) );
	}
	else {
	    self.checkSymbol( argName );

	    self.checkNextToken( ":" );
	    let refType = self.analyzeRefType( accessMode );
	    let arg = self.createNode(
                nodeKindDeclArg, argName.pos, refType.expTypeList ,                       
		{ "name": argName, "argType": refType } );
	    self.scope.add( argName.txt, refType.expType );
	    table.insert( argList, arg );
	}
	token = self.getToken();
    } token.txt ~= ",";

    self.checkToken( token, ")" );

    return token;
}

pub fn TransUnit.createAST( parser: str, macroFlag: bool ): Map {

    self.pushNamespace( "", typeInfoRoot, self.scope );
    
    self.registBuiltInScope();

    self.parser = parser;
    self.moduleName2Info = {};

    let ast:Node = nil;
    
    if macroFlag {
        ast = self.analyzeBlock( "macro" );
    }
    else {
        let rootInfo = {};
        rootInfo.children = {};
        ast = self.createNode(
	    nodeKindRoot, { "lineNo": 0, "column": 0 }, [ typeInfoNone ], rootInfo );
        self.analyzeStatementList( rootInfo.children );

        let token = self.getTokenNoErr();
        if token {
	    error( "unknown:%d:%d:(%s) %s"
	           ( token.pos.lineNo, token.pos.column,
		     Parser.getKindTxt( token.kind ), token.txt ) );
        }   
    }

''    if #self.errMessList > 0 {
''	foreach mess in self.errMessList {
''	    errorLog( "error:" .. mess );
''	}
''	error( "has error" );
''    }


    self.popNamespace();

    return ast;
}

fn TransUnit.analyzeMacroStatement() : Node {
}

pub class DeclMacroInfo {
    pri let name: Parser.Token { pub };
    pri let argList: Node[] { pub };
    pri let ast: Node { pub };
    pri let tokenList: Parser.Token[] { pub };
}

fn TransUnit.analyzeDeclMacro( accessMode: str, firstToken: Parser.Token ) : Node
{
    let nameToken = self.getToken();
    self.checkNextToken( "(" );

    let scope = self.pushScope();
    
    let argList: Node[] = {};
    let nextToken = self.analyzeDeclArgList( accessMode, argList );

    self.checkToken( nextToken, ")" );

    self.checkNextToken( "{" );

    let transUnit = new TransUnit();
    let parser = new Parser.WrapParser( self.parser, "decl macro %s" (nameToken.txt) );

    foreach typeInfo, symbol in scope.get_symbol2TypeInfoMap() {
        transUnit.scope.add( symbol, typeInfo );
    }

    let ast = transUnit.createAST( parser, true );

    let tokenList: Parser.Token[] = [];
    let braceCount = 0;

    while true {
        nextToken = self.getToken();
        if nextToken.txt == "{" {
            braceCount = braceCount + 1;
        }
        elseif nextToken.txt == "}" {
            if braceCount == 0 {
                break;
            }
            braceCount = braceCount - 1;
        }
        table.insert( tokenList, nextToken );
    }

    self.popScope();

    let typeInfo = TypeInfo.createFunc(
        true, self.getCurrentNamespaceTypeInfo(), false, false, false, accessMode,
	nameToken.txt, nil, nil );
    self.scope.add( nameToken.txt, typeInfo );












    
    return self.createNode(
	nodeKindDeclMacro, firstToken.pos, [ typeInfo ],
        new DeclMacroInfo( nameToken, argList, ast, tokenList ) );
}


fn TransUnit.analyzeDeclProto( accessMode: str, firstToken: Parser.Token ) : Node
{
    self.checkNextToken( "class" );

    let name = self.getToken();
    
    let nextToken = self.getToken();
    let baseRef:Node = nil;
    if nextToken.txt == "extend" {
        baseRef = self.analyzeRefType( accessMode );
        nextToken = self.getToken();
    }

    self.checkToken( nextToken, ";" );

    self.pushClass(
        baseRef and baseRef.get_expType() or nil, false, name.txt, accessMode );
    self.popClass();

    return self.createNoneNode();
}

fn TransUnit.analyzeDecl(
    accessMode: str, staticFlag: bool, firstToken: stem, token: stem ): stem
{
    let staticFlag = false;

    if not staticFlag {
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
    }
    let overrideFlag = false;
    if token.txt == "override" {
	overrideFlag = true;
	token = self.getToken();
    }

    if token.txt == "let" {
	return self.analyzeDeclVar( accessMode, staticFlag, firstToken );
    }
    elseif token.txt == "fn" {
	return self.analyzeDeclFunc(
            overrideFlag, accessMode, staticFlag, nil, firstToken, nil );
    }
    elseif token.txt == "class" {
	return self.analyzeDeclClass( accessMode, firstToken );
    }
    elseif token.txt == "proto" {
        return self.analyzeDeclProto( accessMode, firstToken );
    }
    elseif token.txt == "macro" {
        return self.analyzeDeclMacro( accessMode, firstToken );
    }

    return nil;
}

fn TransUnit.analyzeDeclMember(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem {
    let varName = self.getSymbolToken();
    let token = self.getToken();
    let refType = self.analyzeRefType( accessMode );
    token = self.getToken();

    let getterMode = "none";
    let setterMode = "none";
    if token.txt == "{" {
        let nextToken = self.getToken();
        if nextToken.txt == "pub" or nextToken.txt == "pri" {
            getterMode = nextToken.txt;
            nextToken = self.getToken();
            if nextToken.txt == "," {
                nextToken = self.getToken();
                if nextToken.txt == "pub" or nextToken.txt == "pri" {
                    setterMode = nextToken.txt;
                    nextToken = self.getToken();
                }   
            }
        }
        self.checkToken( nextToken, "}" );
        token = self.getToken();
    }
    
    '' accessor
    self.checkToken( token, ";" );

    self.scope.add( varName.txt, refType.expType );

    let info = {
        "name": varName, "refType": refType,
	"staticFlag": staticFlag, "accessMode": accessMode,
        "getterMode": getterMode, "setterMode": setterMode
    };
	
    return self.createNode(
	nodeKindDeclMember, firstToken.pos, refType.expTypeList, info );
}

fn TransUnit.analyzeDeclMethod(
    overrideFlag: bool, accessMode: str, staticFlag: bool,
    className: Parser.Token, firstToken: Parser.Token, name: Parser.Token ): stem
{
    let node = self.analyzeDeclFunc(
        overrideFlag, accessMode, staticFlag, className, name, name );
    return node;
}

fn TransUnit.analyzeDeclClass( classAccessMode: str, firstToken: stem ): stem {
    let name = self.getToken();

    let nextToken = self.getToken();

    let baseRef:Node = nil;
    if nextToken.txt == "extend" {
        baseRef = self.analyzeRefType( classAccessMode );
        nextToken = self.getToken();
    }
    self.checkToken( nextToken, "{" );
    

    let classTypeInfo = self.pushClass(
        baseRef and baseRef.get_expType() or nil, false, name.txt, classAccessMode );

    let fieldList:Node[] = {};
    let memberList:Node[] = [];
    let methodName2Node: Map<str,Node> = {};
    let node = self.createNode(
	nodeKindDeclClass, firstToken.pos, [ classTypeInfo ],
        
	{ "accessMode": classAccessMode, "name": name, "fieldList": fieldList,
          "memberList": memberList, "scope": self.scope,
          "outerMethodSet": {}
        } );
    self.typeInfo2ClassNode[ classTypeInfo ] = node;


    while true {
	let token = self.getToken();
	if token.txt == "}" {
	    break;
	}
	let accessMode = "pri";
	if token.txt == "pub" or token.txt == "pro" or
	    token.txt == "pri" or token.txt == "global"
	{
	    accessMode = token.txt;
	    token = self.getToken();
	}
	let staticFlag = false;
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
        let overrideFlag = false;
	if token.txt == "override" {
	    overrideFlag = true;
	    token = self.getToken();
	}
        
	if token.txt == "let" {
            let memberNode = self.analyzeDeclMember( accessMode, staticFlag, token );
	    table.insert( fieldList, memberNode );
            table.insert( memberList, memberNode );
	}
	elseif token.txt == "fn" {
            let nameToken = self.getToken();
            let methodNode = self.analyzeDeclMethod(
                overrideFlag, accessMode, staticFlag, name, token, nameToken );
	    table.insert( fieldList, methodNode );
	}
	else {
            '' let methodNode = self.analyzeDeclMethod(
	    ''     accessMode, staticFlag, name, token, token );
	    '' table.insert( fieldList, methodNode );
            self.error( "illegal field" );
        }
    }

    let parentInfo = classTypeInfo;

    '' accessor の生成
    foreach memberNode in memberList {
        let memberType = memberNode.expType;
        if memberNode.expType.accessMode ~= "pub" {
            memberType = TypeInfo.cloneToPublic( memberType );
        }
        let memberName = memberNode.info.name;
        let getterName = "get_" .. memberName.txt;
        let accessMode = memberNode.info.getterMode;
        if accessMode ~= "none" and not self.scope.getTypeInfo( getterName )
        {
            let retTypeInfo = TypeInfo.createFunc(
                false, parentInfo, true, false, false, "pub",
                getterName, nil, [ memberType ] );
            self.scope.add( getterName, retTypeInfo );
        }
        let setterName = "set_" .. memberName.txt;
        let accessMode = memberNode.info.setterMode;
        if memberNode.info.setterMode ~= "none" and
            not self.scope.getTypeInfo( setterName )
        {       
            self.scope.add( setterName,
                            TypeInfo.createFunc(
                                false, parentInfo, true, false, false, "pub",
                                setterName, nil, [ memberType ]
                            ));
        }
    }
    
    self.popClass();

    return node;
}

pub class DeclFuncInfo {
    pri let className: Parser.Token { pub };
    pri let name: Parser.Token { pub };
    pri let argList: Node[] { pub };
    pri let staticFlag: bool { pub };
    pri let accessMode: str { pub };
    pri let body: Node { pub };
    pri let retTypeList: TypeInfo[] { pub };
    pri let retTypeInfoList: TypeInfo[] { pub };
}

fn TransUnit.analyzeDeclFunc(
    overrideFlag: bool, accessMode: str, staticFlag: bool, classNameToken: stem,
    firstToken: stem, name: stem ) : stem
{
    let argList = {};
    let token = self.getToken();
    if not name {
	if token.txt ~= "(" {
	    name = self.checkSymbol( token );
	    token = self.getToken();
	}
    }
    else {
	self.checkSymbol( name );
    }
    let needPopFlag = false;
    if token.txt == "." {
        needPopFlag = true;
	classNameToken = name;

	self.pushClass( nil, false, name.txt, "pub" );
	
	name = self.getSymbolToken();
	token = self.getToken();
    }

    let kind = nodeKindDeclConstr;
    if classNameToken {
	if name.txt == "__init" {
	    kind = nodeKindDeclConstr;
	}
	else {
	    kind = nodeKindDeclMethod;
	}
    }
    else {
	kind = nodeKindDeclFunc;
        if not staticFlag {
            staticFlag = true;
        }
    }

    if overrideFlag {
        '' オーバーライドの型チェック
        let overrideType = self.scope.getTypeInfoMethod( name.txt );
        if not overrideType {
            self.error( "not found override -- " .. name.txt );
        }
        if overrideType.get_accessMode() ~= accessMode {
            self.error( "missmatch override accessMode -- %s,%s,%s"
                        ( name.txt, overrideType.get_accessMode(), accessMode ) );
        }
        if overrideType.get_staticFlag() ~= staticFlag {
            self.error( "missmatch override staticFlag -- " .. name.txt );
        }
        if overrideType.get_kind() ~= TypeInfoKindFunc {
            self.error( "missmatch override kind -- %s, %d"
                        ( name.txt, overrideType.get_kind() ) );
        }
    }
    elseif name and self.scope.getTypeInfoMethod( name.txt ) {
        '' override 宣言していないのに、オーバーライドしている場合エラー
        self.error( "missmatch override --" .. name.txt );
    }
        

    self.checkToken( "(" );

    let scope = self.pushScope();

    token = self.analyzeDeclArgList( accessMode, argList );

    self.checkToken( token, ")" );

    token = self.getToken();
    let retTypeList = {};
    let retTypeInfoList = {};
    if token.txt == ":" {
	repeat {
	    let refType = self.analyzeRefType( accessMode );
	    table.insert( retTypeList, refType );
	    table.insert( retTypeInfoList, refType.expType );
	    token = self.getToken();
	} token.txt ~= ",";
    }


    let typeInfo = TypeInfo.createFunc(
        false, self.getCurrentNamespaceTypeInfo(),
        false, false, staticFlag, accessMode,
	name and name.txt or "", nil, retTypeInfoList );
    if name {
	scope.get_parent().add( name.txt, typeInfo );
    }

    if not needPopFlag {
        self.pushNamespace( name and name.txt or "", typeInfo, scope );
    }

    let node:Node = nil;
    let info = nil;
    if token.txt == ";" {
	node = self.createNoneNode();
    }
    else {
        self.pushback();
        let body = self.analyzeBlock( "func", scope );
        info = new DeclFuncInfo(
            classNameToken, name, argList, staticFlag, accessMode,
            body, retTypeList, retTypeInfoList );
        node = self.createNode( kind, firstToken.pos, [ typeInfo ], info );
    }

    if not needPopFlag {
        self.popNamespace();
    }
    
    self.popScope();

    if needPopFlag {
        self.addMethod( classNameToken.txt, node );
	self.popClass();
    }

    return node;
}

fn TransUnit.analyzeDeclVar(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem
{
    let unwrapFlag = false;
    let token = self.getToken();
    if token.txt == "!" {
	unwrapFlag = true;
    }
    else {
	self.pushback();
    }
    
    let typeInfoList : TypeInfo[] = {};
	
    let varList = {};
    repeat {
	let varName = self.getSymbolToken();
	token = self.getToken();
	let typeInfo = typeInfoNone;
	let refType = nil;
	if token.txt == ":" {
	    refType = self.analyzeRefType( accessMode );
	    typeInfo = refType.expType;
	    token = self.getToken();
	}
	table.insert( varList, { "name": varName, "refType": refType } );
	table.insert( typeInfoList, typeInfo );
    } token.txt ~= ",";

    let expList = nil;
    if token.txt == "=" {
	expList = self.analyzeExpList();
	if not expList {
	    self.error( "expList is nil" );
	}	
    }
    if expList {
        let nodeList: Node[] = expList.info;
        foreach exp, index in nodeList {
            if not typeInfoList[ index ] or typeInfoList[ index ] == typeInfoNone {
		typeInfoList[ index ] = exp[ "expType" ];
	    }
	}
    }

    let unwrapBlock: Node = nil;
    if unwrapFlag {
	unwrapBlock = self.analyzeBlock( "let!" );

	foreach typeInfo, index in typeInfoList {
	    if typeInfo.get_nilable() {
		typeInfoList[ index ] = typeInfo.get_orgTypeInfo();
	    }
	}
    }
    
    self.checkNextToken( ";" );

    let declVarInfo = { "accessMode": accessMode,
			"varList": varList, "expList": expList,
			"typeInfoList": typeInfoList, "unwrap": unwrapBlock }; 


    
    let node = self.createNode(
	nodeKindDeclVar, firstToken.pos, [ typeInfoNone ], declVarInfo );


    foreach typeInfo, index in typeInfoList {
	self.scope.add( varList[ index ].name.txt, typeInfo );
    }
    return node;
}

fn TransUnit.analyzeExpList(): Node {
    let expList = {};
    let firstExp = nil;
    repeat {
	let exp = self.analyzeExp();
	if not firstExp {
	    firstExp = exp;
	}
	table.insert( expList, exp );
	let token = self.getToken();
    } token.txt ~= ",";

    self.pushback();

    return self.createNode(
        nodeKindExpList, firstExp.pos, [ typeInfoNone ], expList );
}

fn TransUnit.analyzeListConst( token: stem ): stem {
    let nextToken = self.getToken();
    let expList = nil;
    let itemTypeInfo = typeInfoNone;
    if nextToken.txt ~= "]" {
	self.pushback();
	expList = self.analyzeExpList();
	self.checkNextToken( "]" );
        let nodeList: Node[] = expList.info;
	foreach exp in nodeList {
	    if itemTypeInfo == typeInfoNone {
		itemTypeInfo = exp[ "expType" ];
	    }
	    elseif itemTypeInfo ~= exp[ "expType" ] {
		itemTypeInfo = typeInfoStem;
	    }
	}
    }
    let kind = nodeKindLiteralArray;
    let typeInfo = typeInfoNone;
    if token.txt == '[' {
	kind = nodeKindLiteralList;
	typeInfo = [ TypeInfo.createList( "pri", self.getCurrentClass(), [ itemTypeInfo ] ) ];
    }
    else {
	typeInfo = [ TypeInfo.createArray( "pri", self.getCurrentClass(), [ itemTypeInfo ] ) ];
    }
    return self.createNode( kind, token.pos, typeInfo, expList );
}

fn TransUnit.analyzeMapConst( token: stem ): stem {
    let nextToken = nil;
    let map = {};
    let pairList = {};
    let keyTypeInfo = typeInfoNone;
    let valTypeInfo = typeInfoNone;
    repeat {
	nextToken = self.getToken();
	if nextToken.txt == "}" {
	    break;
	}
	self.pushback();

	let key = self.analyzeExp();
	if key.expType ~= keyTypeInfo {
	    if keyTypeInfo ~= typeInfoNone {
		keyTypeInfo = typeInfoStem;
	    }
	    else {
		keyTypeInfo = key.expType;
	    }
	}
	self.checkNextToken( ":" );
	let val = self.analyzeExp();
	if val.expType ~= valTypeInfo {
	    if valTypeInfo ~= typeInfoNone {
		valTypeInfo = typeInfoStem;
	    }
	    else {
		valTypeInfo = val.expType;
	    }
	}
	
	table.insert( pairList, { "key": key, "val": val } );
	map[ key ] = val;
	nextToken = self.getToken();
    } nextToken.txt ~= ",";

    let typeInfo = TypeInfo.createMap(
        "pri", self.getCurrentClass(), keyTypeInfo, valTypeInfo );

    self.checkToken( nextToken, "}" );
    return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ], 
			    { "map": map, "pairList": pairList } );
}

fn TransUnit.analyzeExpRefItem( token: stem, exp: stem ): stem {
    let indexExp = self.analyzeExp();
    self.checkNextToken( "]" );

    let info = { "val": exp, "index": indexExp };
    let typeInfo = typeInfoStem;
    if exp.expType {
	if exp.expType.kind == TypeInfoKindMap {
	    typeInfo = exp.expType.get_itemTypeInfoList()[2];
	}	
	elseif exp.expType.kind == TypeInfoKindArray or
	    exp.expType.kind == TypeInfoKindArray
	{	
	    typeInfo = exp.expType.get_itemTypeInfoList()[1];
	}
    }
    
    return self.createNode( nodeKindExpRefItem, token.pos, [ typeInfo ], info );
}

fn TransUnit.analyzeExpCont( firstToken: stem, exp: stem, skipFlag: bool ): stem {
    let nextToken = self.getToken();

    if not skipFlag {
	repeat {
	    let matchFlag = false;
	    if nextToken.txt == "[" {
		matchFlag = true;
		exp = self.analyzeExpRefItem( nextToken, exp );
		nextToken = self.getToken();
	    }   
	    if nextToken.txt == "(" {
		matchFlag = true;
		let work = self.getToken();
		let expList = nil;
		if work.txt ~= ")" {
		    self.pushback();
		    expList = self.analyzeExpList();
		    self.checkNextToken( ")" );
		}
		let info = { "func": exp, "argList": expList };

                let kind = nodeKindExpCall;
                if exp.expType.get_kind() == TypeInfoKindMacro {
                    kind = nodeKindExpMacroExp;

                    foreach exp in expList.info@Node[] {
                        let kind = exp.kind;
                        if kind ~= nodeKindLiteralNil and
                            kind ~= nodeKindLiteralChar and
                            kind ~= nodeKindLiteralInt and
                            kind ~= nodeKindLiteralReal and
                            kind ~= nodeKindLiteralArray and
                            kind ~= nodeKindLiteralList and
                            kind ~= nodeKindLiteralMap and
                            kind ~= nodeKindLiteralString and
                            kind ~= nodeKindLiteralBool
                        {   
                            self.error( "Macro arguments must be literal value." );
                        }   
                    }   
                }
		exp = self.createNode(
		    kind, firstToken.pos,
                    exp.expType.get_retTypeInfoList(), info );
		nextToken = self.getToken();
	    }   
	} not matchFlag;
    }

    if nextToken.txt == "." {
	return self.analyzeExpSymbol(
	    firstToken, self.getToken(), "field", exp, skipFlag );
    }

    self.pushback();
    return exp;

}

fn TransUnit.analyzeExpSymbol(
    firstToken: stem, token: stem, mode: str, prefixExp: Node, skipFlag: bool ): stem {
    let exp = nil;

    if mode == "field" {
	let info = { "field": token, "prefix": prefixExp };
	let typeInfo = typeInfoNone;
	if not prefixExp.expType {
	    self.error( "unknown prefix type: " .. getNodeKindName( prefixExp.kind ) );
	}
	if prefixExp.expType.get_kind() == TypeInfoKindClass {
	    let classScope = self.typeId2Scope[ prefixExp.expType.get_typeId() ];
	    let className = prefixExp.expType.getTxt();
	    if not classScope {
		self.error( "not found field: %s, %s" ( className,
                                                        prefixExp.expType ) );
	    }
	    typeInfo = classScope.getTypeInfo( token.txt );
	    if not typeInfo {
                print( "hoge", classScope.symbol2TypeInfoMap );
                foreach name in classScope.symbol2TypeInfoMap {
                    print( "hoge", name );
                }
		self.error( string.format(
		    "not found field typeInfo: %s.%s %s",
		    className, token.txt, classScope) );
	    }
	}
	exp = self.createNode(
            nodeKindRefField, firstToken.pos, [ typeInfo ], info );
    }
    elseif mode == "symbol" {
	let typeInfo = self.scope.getTypeInfo( token.txt );
	if not typeInfo and token.txt == "self" {
	    let namespaceInfo = self.classList[#self.classList];
	    typeInfo = namespaceInfo.typeInfo;
	}
	if not typeInfo {
	    self.error( "not found type -- " .. token.txt );
	}
	exp = self.createNode( nodeKindExpRef, firstToken.pos,
                               [ typeInfo ], token );         
    }
    elseif mode == "fn" {
	exp = self.analyzeDeclFunc( false, "pri", false, nil, token, nil );
    }
    else {
	self.error( "illegal mode", mode );
    }

    return self.analyzeExpCont( firstToken, exp, skipFlag );
}

fn TransUnit.analyzeExpOp2( firstToken: stem, exp: stem, prevOpLevel: int ): stem, int
{
    while true {
        let nextToken = self.getToken();
        let opLevel = prevOpLevel;
        let opTxt = nextToken.txt;
        
        if opTxt == "@" {
	    let castType = self.analyzeRefType( "pri" );
	    exp = self.createNode(
                nodeKindExpCast, firstToken.pos, castType.expTypeList, exp );
        }   
        elseif nextToken.kind == Parser.kind.Ope {
	    if Parser.isOp2( opTxt ) {
                opLevel = op2levelMap[ opTxt ];
                if not opLevel {
                    error( string.format( "unknown op -- %s %s",
                                          opTxt, prevOpLevel ) );       
                }   
                if prevOpLevel and opLevel <= prevOpLevel {
                    self.pushback();
                    return exp;
                }   
                
	        let exp2 = self.analyzeExp( false, opLevel );
	        let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };
		let opTxt = nextToken.txt;

		'' if not exp.expType or not exp2.expType {
		''     self.error( "illegal exp or exp2 %s, %s, %s , %s,%d:%d"
		'' 		( exp.expType, exp2.expType,
                ''                   nextToken.txt, self.parser.getStreamName(), 
		'' 		  nextToken.pos.lineNo,	nextToken.pos.column) );
		'' }

		let expType = typeInfoNone;
		switch opTxt {
		    case "or", "and" {
			if exp.expType.equals( exp2.expType ) {
			    expType = exp.expType;
			}
			else {
			    expType = typeInfoStem;
			}
		    }
		    case "<", ">", "<=", ">=", "~=", "==", "not" {
			expType = typeInfoBool;
		    }
		    case "^", "|", "~", "&", "<<", ">>", "#" {
			expType = typeInfoInt;
		    }
		    case ".." {
			expType = typeInfoString;
		    }
		    case "+", "-", "*", "/", "//", "%" {
			if exp.expType == typeInfoReal or exp2.expType == typeInfoReal
			{
			    expType = typeInfoReal;
			}
			else {
			    expType = typeInfoInt;
			}
		    }
		    case "=" {
			'' if not exp.expType.equals( exp2.expType ) {
			''     self.addErrMess(
			'' 	nextToken.pos,			
			'' 	"unmatch type %s %s" ( exp.expType.getTxt(),
			'' 			       exp2.expType.getTxt() ) );
			'' }
		    }
		    default {
			self.error( "unknown op " .. opTxt );
		    }
		}
                
	        exp = self.createNode(
                    nodeKindExpOp2, firstToken.pos, [ expType ], info );
	    }   
	    else {
	        self.error( "illegal op" );
	    }   
        }   
        else {
	    self.pushback();
	    return exp;
        }
    }
    return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}

pub class LiteralStringInfo {
    pri let token: Parser.Token {pub};
    pri let argList: Node[] {pub};
}

fn TransUnit.analyzeExpMacroStat( firstToken: Parser.Token ) {
    let expStrList: Node = [];

    self.checkNextToken( "{" );

    let braceCount = 0;
    while true {
        let token = self.getToken();

        if token.txt == ",,," {
            let exp = self.analyzeExp( true, op1levelMap[ token.txt ] );
            exp = self.createNode( nodeKindExpOp1, firstToken.pos, [ typeInfoString ], 
			           { "op": token, "exp": exp } );   
            table.insert( expStrList,  exp );
        }
        elseif token.txt == "{" {
            braceCount = braceCount + 1;
        }
        elseif token.txt == "}" {
            if braceCount == 0 {
                break;
            }
            braceCount = braceCount - 1;
        }
        else {
            let newToken = new Parser.Token(
                token.kind, string.format( "'%s'", token.txt ), token.pos );
            let literalStr = self.createNode(
                nodeKindLiteralString, token.pos, [ typeInfoString ],
                new LiteralStringInfo( newToken, nil ) );
            table.insert( expStrList, literalStr );
        }
    }

    return self.createNode(
        nodeKindExpMacroStat, firstToken.pos, [ typeInfoStat ], expStrList );
}


fn TransUnit.analyzeExp( skipOp2Flag: bool, prevOpLevel: int ): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let exp = nil;

    if token.kind == Parser.kind.Dlmt {
	if token.txt == "..." {
	    return self.createNode(
                nodeKindExpDDD, firstToken.pos, [ typeInfoNone ], token );
	}

	if token.txt == '[' or token.txt == '[@' {
	    return self.analyzeListConst( token );
	}
	if token.txt == '{' {
	    return self.analyzeMapConst( token );
	}
	if token.txt == "(" {
	    exp = self.analyzeExp();
	    self.checkNextToken( ")" );
	    exp = self.createNode(
                nodeKindExpParen, firstToken.pos, exp.expTypeList, exp );
	    exp = self.analyzeExpCont( firstToken, exp, false );
	}
    }

    if token.txt == "new" {
	''let nextToken = self.getToken();
	''exp = self.analyzeExpSymbol(
	''  firstToken, nextToken, "symbol", nextToken, true );
	exp = self.analyzeRefType( "pri" );
      
	self.checkNextToken( "(" );
	let nextToken = self.getToken();
	let argList: stem = nil;
	if nextToken.txt ~= ")" {
	    self.pushback();
	    argList = self.analyzeExpList();
	    self.checkNextToken( ")" );
	}	
	exp = self.createNode( nodeKindExpNew, firstToken.pos, exp.expTypeList,
			       { "symbol": exp, "argList": argList } );
	exp = self.analyzeExpCont( firstToken, exp, false );
    }

    if token.kind == Parser.kind.Ope and Parser.isOp1( token.txt ) {
	'' 単項演算
        if token.txt == "`" {
            exp = self.analyzeExpMacroStat( token );
        }
        else {
	    exp = self.analyzeExp( true, op1levelMap[ token.txt] );
	    let typeInfo = typeInfoNone;
            switch ( token.txt ) {
	        case "-" {
	            if exp.expType ~= typeInfoInt and exp.expType ~= typeInfoReal {
		        self.addErrMess(
		            token.pos, 'unmatch type for "-" -- %s' ( exp.expType.getTxt() ) );
	            }   
	            typeInfo = exp.expType;
	        }   
                case "#" {
	            typeInfo = typeInfoInt;
	        }   
                case "not" {
	            typeInfo = typeInfoBool;
	        }   
                case ",," {
	            typeInfo = exp.expType;
	        }   
                case ",,," {
                    if exp.expType ~= typeInfoString {
                        self.error( "unmatch ,,, type, need string type" );
                    }   
	            typeInfo = typeInfoSymbol;
	        }   
                case "`" {
                    typeInfo = typeInfoNone;
                }   
                case "not" {
	            typeInfo = typeInfoBool;
	        }   
                default {
	            self.error( "unknown op1" );
                }   
	    }   
	    
	    exp = self.createNode( nodeKindExpOp1, firstToken.pos, [ typeInfo ], 
			           { "op": token, "exp": exp } );   
	    return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
        }
    }


    if token.kind == Parser.kind.Int {
	exp = self.createNode( nodeKindLiteralInt, firstToken.pos, [ typeInfoInt ], 
			       { "token": token, "num": tonumber( token.txt ) } );
    }
    elseif token.kind == Parser.kind.Real {
	exp = self.createNode( nodeKindLiteralReal, firstToken.pos, [ typeInfoReal ], 
			       { "token": token, "num": tonumber( token.txt ) } );
    }
    elseif token.kind == Parser.kind.Char {
	let num = 0;
	if #(token.txt) == 1 {
	    num = token.txt.byte( 1 );
	}
	else {
	    num = quotedChar2Code[ token.txt.sub( 2, 2 ) ];
	}
	exp = self.createNode( nodeKindLiteralChar, firstToken.pos, [ typeInfoChar ], 
			       { "token": token, "num": num } );
    }
    elseif token.kind == Parser.kind.Str {
	let nextToken = self.getToken();
	let formatArgList:Node = [];
	if nextToken.txt == "(" {
	    repeat {
		let arg = self.analyzeExp();
		table.insert( formatArgList, arg );
		nextToken = self.getToken();
	    } nextToken.txt ~= ",";
	    self.checkToken( nextToken, ")" );
	    nextToken = self.getToken();
	}
	exp = self.createNode(
            nodeKindLiteralString, firstToken.pos, [ typeInfoString ],
            new LiteralStringInfo( token, formatArgList ) );
	token = nextToken;
	if token.txt == "[" {
	    exp = self.analyzeExpRefItem( token, exp );
	}
	else {
	    self.pushback();
	}
    }
    elseif token.txt == "fn" {
	exp = self.analyzeExpSymbol( firstToken, token, "fn", token, false );
    }
    elseif token.kind == Parser.kind.Symb {
	exp = self.analyzeExpSymbol( firstToken, token, "symbol", token, false );
    }
    elseif token.kind == Parser.kind.Type {
	exp = self.createNode( nodeKindExpRef, firstToken.pos, [ typeInfoNone ], token );
    }
    elseif token.txt == "true" or token.txt == "false" {
	exp = self.createNode(
            nodeKindLiteralBool, firstToken.pos, [ typeInfoBool ], token );
    }
    elseif token.txt == "nil" {
	exp = self.createNode(
            nodeKindLiteralNil, firstToken.pos, [ typeInfoNil ] , token );
    }

    if not exp {
	self.error( "illegal exp" );
    }

    if skipOp2Flag {
	return exp;
    }

    return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}


fn TransUnit.analyzeStatement( termTxt: str ): Node {
    let token = self.getTokenNoErr();
    if not token {
	return nil;
    }

    let statement = self.analyzeDecl( "pri", false, token, token );

    if not statement {
	if token.txt == termTxt {
	    self.pushback();
	    return nil;
	}
	elseif token.txt == "pub" or token.txt == "pro" or
	    token.txt == "pri" or token.txt == "global" or token.txt == "static"
	{
	    let accessMode = (token.txt ~= "static") and token.txt or "pri";
	    let staticFlag = (token.txt == "static");

	    let nextToken = nil;
	    if token.txt ~= "static" {
		nextToken = self.getToken();
	    }
	    else {
		nextToken = token;
	    }
	    statement = self.analyzeDecl( accessMode, staticFlag, token, nextToken );
	}
	elseif token.txt == "{" {
	    self.pushback();
	    statement = self.analyzeBlock( "{" );
	}
	elseif token.txt == "if" {
	    statement = self.analyzeIf( token );
	}
        elseif token.txt == "switch" {
            statement = self.analyzeSwitch( token );
        }
	elseif token.txt == "while" {
	    statement = self.analyzeWhile( token );
	}
	elseif token.txt == "repeat" {
	    statement = self.analyzeRepeat( token );
	}
	elseif token.txt == "for" {
	    statement = self.analyzeFor( token );
	}
	elseif token.txt == "apply" {
	    statement = self.analyzeApply( token );
	}
	elseif token.txt == "foreach" {
	    statement = self.analyzeForeach( token, false );
	}
	elseif token.txt == "forsort" {
	    statement = self.analyzeForeach( token, true );
	}
	elseif token.txt == "return" {
            let nextToken = self.getToken();

            let expList: Node = nil;
            if nextToken.txt ~= ";" {
                self.pushback();
		expList = self.analyzeExpList();
		self.checkNextToken( ";" );
            }
	    statement = self.createNode(
		nodeKindReturn, token.pos, [ typeInfoNone ], expList );
	}
	elseif token.txt == "break" {
	    self.checkNextToken( ";" );
	    statement = self.createNode(
		nodeKindBreak, token.pos, [ typeInfoNone ], nil );}
	elseif token.txt == "import" {
	    statement = self.analyzeImport( token );
	}
	else {
	    self.pushback();
	    let exp = self.analyzeExp();
	    self.checkNextToken( ";" );
	    statement = self.createNode(
		nodeKindStmtExp, self.currentToken.pos, [ typeInfoNone ], exp );
	}
    }

    return statement;
}


fn TransUnit.analyzeStatementList( stmtList: stem[], termTxt: str ) {
    while true {
	let statement = self.analyzeStatement( termTxt );
	if not statement {
	    break;
	}
	table.insert( stmtList, statement );
    }
}
