import lune.base.Parser;

fn debugLog() {
    let debugInfo1 = debug.getinfo( 2 );
    let debugInfo2 = debug.getinfo( 3 );
    let debugInfo3 = debug.getinfo( 4 );
    print( "--", debugInfo1[ "short_src" ], debugInfo1[ 'currentline' ] );
    print( "--", debugInfo2[ "short_src" ], debugInfo2[ 'currentline' ] );
    print( "--", debugInfo3[ "short_src" ], debugInfo3[ 'currentline' ] );
}

let typeIdSeed = 0;

pub let typeInfo = {};
let builtInTypeMap = {};

pub let TypeInfoKindPrim = 1;
pub let TypeInfoKindList = 2;
pub let TypeInfoKindArray = 3;
pub let TypeInfoKindMap = 4;
pub let TypeInfoKindClass = 5;
pub let TypeInfoKindFunc = 6;

class TypeInfo {
    pri let externalFlag: bool;
    pri let itemTypeInfoList: TypeInfo[@] { pub };
    pri let retTypeInfoList: TypeInfo[@] { pub };
    pri let typeId: int { pub };
    pri let txt: str { pub };
    pri let kind: int { pub };
    pri let staticFlag: bool { pub };
    pri let accessMode: str { pub };
    '' コンパイラで自動生成された型情報の場合 true。 accessor 等。
    pri let autoFlag: bool { pub };
    __init( autoFlag: bool, externalFlag: bool, staticFlag: bool, accessMode: str,
            txt: str, typeId: int, kind: int,
	    itemTypeInfoList: TypeInfo[@], retTypeInfoList: TypeInfo[@] )
    {
        self.autoFlag = autoFlag;
        self.externalFlag = externalFlag;
        self.staticFlag = staticFlag;
        self.accessMode = accessMode;
	self.txt = txt;
	self.typeId = typeId;
	self.kind = kind;
	self.itemTypeInfoList = itemTypeInfoList or [@];
	self.retTypeInfoList = retTypeInfoList or [@];
	return self;
    }

    pub serialize() {
        fn serializeTypeInfoList( name: str, list: TypeInfo[@] ) {
            let work = name;
	    foreach typeInfo, index in list {
	        if index ~= 1 {
		    work = work .. ", ";
	        }   
	        work = "%s%d" (work, typeInfo.typeId );
	    }
            return work .. "}, ";
        }
        
        let txt = ```{ typeId = %d, txt = '%s', staticFlag = %s, accessMode = '%s',
kind = %d, ``` ( self.typeId, self.txt, self.staticFlag,
                 self.accessMode, self.kind );

	
	return txt .. serializeTypeInfoList( "itemTypeId = {", self.itemTypeInfoList ) ..
            serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList ) .. "}";
    }

    pub getTxt() : str {
	if self.kind == TypeInfoKindArray {
	    return self.itemTypeInfoList[1].getTxt() .. "[@]";
	}
	if self.kind == TypeInfoKindList {
	    return self.itemTypeInfoList[1].getTxt() .. "[]";
	}
	if self.itemTypeInfoList and #self.itemTypeInfoList > 0 {
	    let txt = self.txt .. "<";
	    foreach typeInfo, index in self.itemTypeInfoList {
		if index ~= 1 {
		    txt = txt .. ",";
		}
		txt = txt .. typeInfo.getTxt();
	    }
	    
	    return txt .. ">";
	}
	if self.txt {
	    return self.txt;
	}
	return "";
    }

    pub static create( staticFlag: bool, kind: int, txt: str,
		       itemTypeInfo: TypeInfo[@], retTypeInfoList: TypeInfo[@] ) {
	if kind == TypeInfoKindPrim {
	    return builtInTypeMap[ txt ];
	}
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( false, true, staticFlag, "pub", txt, typeIdSeed,
                                 kind, itemTypeInfo, retTypeInfoList );
	return info;
    }
	

    
    pub static createBuiltin( idName: str, typeTxt: str, kind: int ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( false, false, false, "pub", typeTxt, typeIdSeed, kind );
	typeInfo[ idName ] = info;
	builtInTypeMap[ typeTxt ] = info;
	return info;
    }

    pub static createList( itemTypeInfo: TypeInfo ): TypeInfo {
	if not itemTypeInfo or #itemTypeInfo == 0 {
	    error( "illegal list type: %s" (itemTypeInfo) );
	}	
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( false, false, false, "pub", nil,
                             typeIdSeed, TypeInfoKindList, itemTypeInfo );
    }

    pub static createArray( itemTypeInfo: TypeInfo ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( false, false, false, "pub", nil,
                             typeIdSeed, TypeInfoKindArray, itemTypeInfo );
    }

    pub static createMap( keyTypeInfo: TypeInfo, valTypeInfo: TypeInfo ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( false, false, false, "pub", "Map", typeIdSeed,
                             TypeInfoKindMap, [@ keyTypeInfo, valTypeInfo ] );
    }
    
    pub static createClass(
        externalFlag: bool, accessMode: str, className: str ): TypeInfo
    {   
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( false, externalFlag, false, accessMode, className,
                                 typeIdSeed, TypeInfoKindClass ); 
	return info;
    }

    pub static createFunc(
        autoFlag: bool, externalFlag: bool, staticFlag: bool, accessMode: str,
	funcName: str, argTypeList: TypeInfo[@], retTypeInfoList: TypeInfo[@] ): TypeInfo
    {   
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( autoFlag, externalFlag, staticFlag, accessMode,
                                 funcName, typeIdSeed, TypeInfoKindFunc,    
				 argTypeList or [], retTypeInfoList or [] );	    
	return info;
    }
}

let typeInfoNone = TypeInfo.createBuiltin( "None", "", TypeInfoKindPrim );
let typeInfoStem = TypeInfo.createBuiltin( "Stem", "stem" , TypeInfoKindPrim );
let typeInfoNil = TypeInfo.createBuiltin( "Nil", "nil" , TypeInfoKindPrim );
let typeInfoBool = TypeInfo.createBuiltin( "Bool", "bool" , TypeInfoKindPrim );
let typeInfoInt = TypeInfo.createBuiltin( "Int", "int" , TypeInfoKindPrim );
let typeInfoReal = TypeInfo.createBuiltin( "Real", "real" , TypeInfoKindPrim );
let typeInfoChar = TypeInfo.createBuiltin( "char", "char" , TypeInfoKindPrim );
let typeInfoString = TypeInfo.createBuiltin( "String", "str" , TypeInfoKindPrim );
let typeInfoMap = TypeInfo.createBuiltin( "Map", "Map" , TypeInfoKindMap );
let typeInfoList = TypeInfo.createBuiltin( "List", "List" , TypeInfoKindList );
let typeInfoArray = TypeInfo.createBuiltin( "Array", "Array" , TypeInfoKindArray );
let typeInfoForm = TypeInfo.createBuiltin( "Form", "form" , TypeInfoKindFunc );


class Scope {
    pri let parent: Scope { pub };
    pri let symbol2TypeInfoMap: Map<str,TypeInfo> { pub };
    pri let className2ScopeMap: Map<str,Scope> { pub };
    __init( parent: Scope ) {
	self.parent = parent;
	self.symbol2TypeInfoMap = {};
	self.className2ScopeMap = {};
	return self;
    }
    pub add( name:str, typeInfo: TypeInfo ) {
	self.symbol2TypeInfoMap[ name ] = typeInfo;
    }
    pub addClass( name:str, typeInfo: TypeInfo, scope: Scope ) {
	self.add( name, typeInfo );
	self.className2ScopeMap[ name ] = scope;
    }

    pub getClassScope( name: str ) : Scope {
	let scope = self.className2ScopeMap[ name ];
	if not scope and self.parent {
	    scope = self.parent.getClassScope( name );
	}
	return scope;
    }
    
    pub getTypeInfoChild( name: str ) : TypeInfo {
	return self.symbol2TypeInfoMap[ name ];
    }


    pub getTypeInfo( name: str ) : TypeInfo {
	let node = self.symbol2TypeInfoMap[ name ];
	if node {
	    return node;
	}
	if self.parent {
	    return self.parent.getTypeInfo( name );
	}
	return builtInTypeMap[ name ];
    }
}

pub class NodePos {
    pri let lineNo: int;
    pri let column: int;
}

pub class Node {
    pri let kind: int { pub };
    pri let pos: NodePos;
    pri let expType: TypeInfo { pub };
    pri let expTypeList: TypeInfo[];
    pri let info: stem {pub};
    pub let filter: form;


}

class ClassInfo {
    pri let name: str;
    pri let scope: Scope;
    pri let typeInfo: TypeInfo;
}

pub class TransUnit {
   
    pri let scope: Scope;
    '' 解析中のクラスを保持する
    pri let classList: ClassInfo[];
    pri let moduleName2Info: Map;
    pri let parser: Parser.Parser;
    pri let typeInfo2Scope: Map<TypeInfo,Scope>;
    pri let typeInfo2ClassNode: Map<TypeInfo,Node>;
    pri let pushbackToken: stem;
    pri let currentToken: stem;
    pri let currentNamespace: str;
    __init() {
	self.scope = new Scope( nil );
	self.classList = {};
	self.typeInfo2Scope = {};
        self.typeInfo2ClassNode = {};
	return self;
    }

    pri pushScope(): Scope {
	self.scope = new Scope( self.scope );
	return self.scope;
    }

    pri popScope() {
	self.scope = self.scope.get_parent();
    }

    pri pushClass( externalFlag: bool, name:str ): TypeInfo {
	let typeInfo = self.scope.getTypeInfoChild( name );
	if not typeInfo {
	    typeInfo = TypeInfo.createClass( externalFlag, "pub", name );
	    let scope = self.pushScope();
	    scope.get_parent().addClass( name, typeInfo, scope );
	}
	else {
	    self.scope = self.scope.getClassScope( name );
	}
	table.insert( self.classList,
                      new ClassInfo( name, self.scope, typeInfo ) );
	self.typeInfo2Scope[ typeInfo ] = self.scope;
	return typeInfo;
    }

    pri popClass() {
	self.popScope();
	table.remove( self.classList );
    }
    pri addMethod( className: str, methodNode: Node ) {
        let classTypeInfo = self.scope.getTypeInfo( className );
        let classNodeInfo = self.typeInfo2ClassNode[ classTypeInfo ].info;
            
        classNodeInfo.outerMethodSet[ methodNode.info.name.txt ] = true;
        table.insert( classNodeInfo.fieldList, methodNode );
    }

    pri analyzeDecl( accessMode: str, staticFlag:
		     bool, firstToken: stem, token: stem ): Node;
    pri analyzeDeclVar( accessMode: str, staticFlag: bool, firstToken: stem ): Node;
    pri analyzeDeclFunc(
        accessMode: str, staticFlag: bool, classNameToken: Parser.Token,
        firstToken: Parser.Token, name: Parser.Token ) : Node;
    pri analyzeDeclClass( classAccessMode: str, classToken: stem ): Node;
    pri analyzeExp( skipOp2Flag: bool, opLevel: int ): Node;
    pri analyzeStatement( stmtList: stem[], termTxt: str );
    pri analyzeExpSymbol( firstToken: stem, token: stem,
			  mode: str, prefixExp: stem, skipFlag: bool ): Node;
    pri analyzeExpList(): Node;
}

let opLevelBase = 0;
let op2levelMap:Map<str,int> = {};
let op1levelMap:Map<str,int> = {};
fn regOpLevel( opnum: int, opList: str[@] ) {
    opLevelBase = opLevelBase + 1;
    if opnum == 1 {
        foreach op in opList {
            op1levelMap[ op ] = opLevelBase;
        }
    }
    else {
        foreach op in opList {
            op2levelMap[ op ] = opLevelBase;
        }
    }
}
regOpLevel( 2, [@ "=" ] );
regOpLevel( 2, [@ "or" ] );
regOpLevel( 2, [@ "and" ] );
regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
regOpLevel( 2, [@ "|" ] );
regOpLevel( 2, [@ "~" ] );
regOpLevel( 2, [@ "&" ] );
regOpLevel( 2, [@ "<<", ">>" ] );
regOpLevel( 2, [@ ".." ] );
regOpLevel( 2, [@ "+", "-" ] );
regOpLevel( 2, [@ "*", "/", "//", "%" ] );
regOpLevel( 1, [@ "not", "#", "-", "~" ] );
regOpLevel( 1, [@ "^" ] );


let nodeKind2NameMap: Map<int,str> = {};
let nodeKindSeed = 1;
pub let nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
    let kind = nodeKindSeed;
    nodeKindSeed = nodeKindSeed + 1;
    nodeKind2NameMap[ kind ] = name;
    nodeKind[ name ] = kind;
    return kind;
}

let nodeKindNone = regKind( 'None' );
let nodeKindImport = regKind( 'Import' );
let nodeKindRoot = regKind( 'Root' );
let nodeKindRefType = regKind( 'RefType' );
let nodeKindIf = regKind( 'If' );
let nodeKindSwitch = regKind( 'Switch' );
let nodeKindWhile = regKind( 'While' );
let nodeKindRepeat = regKind( 'Repeat' );
let nodeKindFor = regKind( 'For' );
let nodeKindApply = regKind( 'Apply' );
let nodeKindForeach = regKind( 'Foreach' );
let nodeKindForsort = regKind( 'Forsort' );
let nodeKindReturn = regKind( 'Return' );
let nodeKindBreak = regKind( 'Break' );
let nodeKindExpNew = regKind( 'ExpNew' );
let nodeKindExpList = regKind( 'ExpList' );
let nodeKindExpRef = regKind( 'ExpRef' );
let nodeKindExpOp2 = regKind( 'ExpOp2' );
let nodeKindExpCast = regKind( 'ExpCast' );
let nodeKindExpOp1 = regKind( 'ExpOp1' );
let nodeKindExpRefItem = regKind( 'ExpRefItem' );
let nodeKindExpCall = regKind( 'ExpCall' );
let nodeKindExpDDD = regKind( 'ExpDDD' );
let nodeKindExpParen = regKind( 'ExpParen' );
let nodeKindBlock = regKind( 'Block' );
let nodeKindStmtExp = regKind( 'StmtExp' );
let nodeKindRefField = regKind( 'RefField' );
let nodeKindDeclVar = regKind( 'DeclVar' );
let nodeKindDeclFunc = regKind( 'DeclFunc' );
let nodeKindDeclMethod = regKind( 'DeclMethod' );
let nodeKindDeclConstr = regKind( 'DeclConstr' );
let nodeKindDeclMember = regKind( 'DeclMember' );
let nodeKindDeclArg = regKind( 'DeclArg' );
let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
let nodeKindDeclClass = regKind( 'DeclClass' );
let nodeKindLiteralNil = regKind( 'LiteralNil' );
let nodeKindLiteralChar = regKind( 'LiteralChar' );
let nodeKindLiteralInt = regKind( 'LiteralInt' );
let nodeKindLiteralReal = regKind( 'LiteralReal' );
let nodeKindLiteralArray = regKind( 'LiteralArray' );
let nodeKindLiteralList = regKind( 'LiteralList' );
let nodeKindLiteralMap = regKind( 'LiteralMap' );
let nodeKindLiteralString = regKind( 'LiteralString' );
let nodeKindLiteralBool = regKind( 'LiteralBool' );


let quotedChar2Code = {};
quotedChar2Code[ 'a' ] = 7;    '' \a
quotedChar2Code[ 'b' ] = 8;    '' \b
quotedChar2Code[ 't' ] = 9;    '' \t
quotedChar2Code[ 'n' ] = 10;   '' \t
quotedChar2Code[ 'v' ] = 11;   '' \v
quotedChar2Code[ 'f' ] = 12;   '' \f 
quotedChar2Code[ 'r' ] = 13;   '' \r
quotedChar2Code[ '\\' ] = ?\\; '' \\
quotedChar2Code[ '"' ] = ?\";  '' "
quotedChar2Code[ "'" ] = ?\';  '' '

pub fn getNodeKindName( kind: int ): str {
    return nodeKind2NameMap[ kind ];
}

pub fn nodeFilter( node: stem, filter: form, ... ) : stem {
    if not filter[ node.kind ] {
	error( string.format( "none filter -- %s",
			      getNodeKindName( node.kind ) ));
    }
    return filter[ node.kind ]( filter, node, ... );
}

fn TransUnit.registBuiltInScope() {
    let builtInInfo: Map<str,Map<str,Map<str,str[]>>> = {
	"": {
            "error": { "ret": [] },   
            "print": { "ret": [] },
            "tonumber": { "ret": ["int"] },
        },           
	"io": {
            "open": { "ret": ["stem"] },
        },      
	"string": {
            "find": { "ret": ["int", "int"] },
            "byte": { "ret": ["int"] },
            "format": { "ret": ["str"] },
            "rep": { "ret": ["str"] },
            "gmatch": { "ret": ["stem"] },
            "gsub": { "ret": ["str"] },
        },           
	"str": {
            "find": { "methodFlag": [], "ret": ["int", "int"] },
            "byte": { "methodFlag": [], "ret": ["int"] },
            "format": { "methodFlag": [], "ret": ["str"] },
            "rep": { "methodFlag": [], "ret": ["str"] },
            "gmatch": { "methodFlag": [], "ret": ["stem"] },
            "gsub": { "methodFlag": [], "ret": ["str"] },
            "sub": { "methodFlag": [], "ret": ["str"] },
        },           
	"table": {
            "insert": { "ret": [""] },  
            "remove": { "ret": [""] },
        },
	"debug": {
            "getinfo": { "ret": ["stem"] },
        },      
	"_luneScript": {
            "loadModule": { "ret": ["stem"] },
        },           
    };
    
    forsort name2FuncInfo, name in builtInInfo {
	if name ~= "" {
	    self.pushClass( true, name );
	}
	forsort info, funcName in name2FuncInfo {
            let retTypeList: TypeInfo[] = {};
            foreach retType in info[ "ret" ] {
                table.insert( retTypeList, builtInTypeMap[ retType ] );
            }
	    self.scope.add(
                funcName,
                TypeInfo.createFunc(
                    false, true, not info[ "methodFlag" ], "pub",
                    funcName, nil, retTypeList ) );
	}
	if name ~= "" {
	    self.popClass();
	}
    }
}


fn TransUnit.createNode( kind: int, pos: stem, expTypeList: TypeInfo[], info: Map ): Map {
    if not getNodeKindName( kind ) {
	error( string.format( "%d:%d: not found nodeKind", pos.lineNo, pos.column ) );
    }
    return new Node( kind, pos, expTypeList[1], expTypeList, info, nodeFilter );
}

fn TransUnit.error( mess: str ) {
    let pos = { "lineNo": 0, "column": 0 };
    let txt = "";
    if self.currentToken {
	pos = self.currentToken.pos;
	txt = self.currentToken.txt;
    }
    error( string.format( "%d:%d:(%s) %s", pos.lineNo, pos.column, txt, mess ) );
}

fn TransUnit.createNoneNode(): stem {
    return self.createNode( nodeKindNone, { "lineNo": 0, "column": 0 },
                            [ typeInfoNone ], {} );
}

fn TransUnit.getTokenNoErr(): stem {
    if self.pushbackToken {
	self.currentToken = self.pushbackToken;
	self.pushbackToken = nil;
	return self.currentToken;
    }

    let commentList = {};
    let token = nil;
    while true {
	token = self.parser.getToken();
	if not token {
	    break;
	}
	if token.kind ~= Parser.kind.Cmnt {
	    break;
	}
	table.insert( commentList, token );
    }

    if token {
	token.commentList = commentList;
    }
    self.currentToken = token;
    return token;
}


fn TransUnit.getToken( mess: str ): stem {
    let token = self.getTokenNoErr();
    if not token {
	return Parser.getEofToken();
    }
    self.currentToken = token;
    return self.currentToken;
}

fn TransUnit.pushback() {
    if self.pushbackToken {
	error( string.format( "multiple pushback:%d:%d: %s, %s",
			      self.currentToken.pos.lineNo,
			      self.currentToken.pos.column,
			      self.pushbackToken.txt, self.currentToken.txt ) );
    }
    self.pushbackToken = self.currentToken;
    self.currentToken = nil;
}

fn TransUnit.checkSymbol( token: stem ): stem {
    if token.kind ~= Parser.kind.Symb and
	token.kind ~= Parser.kind.Kywd and
	token.kind ~= Parser.kind.Type
    {
	self.error( "illegal symbol" );
    }
    return token;
}

fn TransUnit.getSymbolToken(): Parser.Token {
    return self.checkSymbol( self.getToken() );
}


fn TransUnit.checkToken( token: stem, txt: str ): stem {
    if not token or token.txt ~= txt {
	self.error( string.format( "not found -- %s", txt ) );
    }
    return token;
}

fn TransUnit.checkNextToken( txt: str ): stem {
    return self.checkToken( self.getToken(), txt );
}


fn TransUnit.analyzeBlock( blockKind: str, scope: Scope ): stem {
    let token = self.checkNextToken( "{" );

    if not scope {
	self.pushScope();
    }

    let stmtList = {};
    self.analyzeStatement( stmtList, "}" );

    self.checkNextToken( "}" );

    if not scope {
	self.popScope();
    }

    let node = self.createNode( nodeKindBlock, token.pos, [ typeInfoNone ], 
				{ "kind": blockKind, "stmtList": stmtList } );
    
    return node;
}


fn TransUnit.analyzeDecl(
    accessMode: str, staticFlag: bool, firstToken: stem, token: stem ): stem
{
    let staticFlag = false;

    if not staticFlag {
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
    }

    if token.txt == "let" {
	return self.analyzeDeclVar( accessMode, staticFlag, firstToken );
    }
    elseif token.txt == "fn" {
	return self.analyzeDeclFunc( accessMode, staticFlag, nil, token, nil );
    }
    elseif token.txt == "class" {
	return self.analyzeDeclClass( accessMode, token );
    }

    return nil;
}

class _TypeInfo {
    pub let itemTypeId: int[];
    pub let retTypeId: int[];
    pub let typeId: int;
    pub let txt: str;
    pub let kind: int;
    pub let staticFlag: bool;
}
class _ModuleInfo {
    pub let _className2InfoMap: Map<str,Map<str,stem>>;
    pub let _typeInfoList: _TypeInfo[];
    pub let _varName2InfoMap: Map<str,stem>;
    pub let _funcName2InfoMap: Map<str,stem>;
}

fn TransUnit.analyzeImport( token: stem ) {
    let moduleToken = self.getToken();
    let modulePath = moduleToken.txt;
    let nextToken = {};

    let nameList = [ moduleToken.txt ];
    
    while true {
	nextToken = self.getToken();
	if nextToken.txt == "." {
	    nextToken = self.getToken();
	    moduleToken = nextToken;
	    modulePath = "%s.%s" ( modulePath, moduleToken.txt );
	    table.insert( nameList, moduleToken.txt );
	}
	else {
	    break;
	}
    }

    '' foreach moduleName in nameList {
    '' 	self.pushClass( moduleName );
    '' }
    let moduleTypeInfo = self.pushClass( true, moduleToken.txt );

    let moduleInfo: _ModuleInfo = _luneScript.loadModule( modulePath );
    self.moduleName2Info[ modulePath ] = moduleInfo;

    '' 型情報の登録
    let typeId2TypeInfo: Map<int,TypeInfo> = {};
    foreach typeInfo in moduleInfo._typeInfoList {
        if typeInfo.kind ~= TypeInfoKindPrim {
	    let itemTypeInfo = {};
	    foreach typeId in typeInfo.itemTypeId {
	        table.insert( itemTypeInfo, typeId2TypeInfo[ typeId ] );
	    }
	    let retTypeInfo = {};
	    foreach typeId in typeInfo.retTypeId {
	        table.insert( retTypeInfo, typeId2TypeInfo[ typeId ] );
	    }
	    typeId2TypeInfo[ typeInfo.typeId ] = TypeInfo.create(
                typeInfo.staticFlag, typeInfo.typeId,
                typeInfo.txt, itemTypeInfo, retTypeInfo );
        }
        else {
	    typeId2TypeInfo[ typeInfo.typeId ] = builtInTypeMap[ typeInfo.txt ];
        }
    }

    '' クラスの登録
    foreach classInfo, className in moduleInfo._className2InfoMap {
	self.pushClass( true, className );
	foreach fieldInfo, fieldName in classInfo {
            let fieldTypeInfo: TypeInfo = nil;
            if fieldInfo.methodFlag {
                '' メソッド登録
	        '' let retTypeInfo:TypeInfo[] = {};
	        '' foreach typeId in fieldInfo.retTypeId@int[] {
	        ''     table.insert( retTypeInfo, typeId2TypeInfo[ typeId ] );
	        '' }   
                '' fieldTypeInfo = TypeInfo.createFunc(
                ''     false, true, fieldInfo.staticFlag, fieldInfo.accessMode,
                ''     fieldName, nil, retTypeInfo );
                fieldTypeInfo = typeId2TypeInfo[ fieldInfo[ "typeId" ] ];
            }
            else {
                '' メンバー登録
                fieldTypeInfo = typeId2TypeInfo[ fieldInfo[ "typeId" ] ];
            }
	    self.scope.add( fieldName, fieldTypeInfo );
	}
	self.popClass();
    }

    '' 変数登録
    foreach varInfo, varName in moduleInfo._varName2InfoMap {
	self.scope.add( varName, typeId2TypeInfo[ varInfo[ "typeId" ] ] );
    }

    '' 関数登録
    foreach funcInfo, funcName in moduleInfo._funcName2InfoMap {
	self.scope.add( funcName, typeId2TypeInfo[ funcInfo[ "typeId" ] ] );
    }
    
    self.popClass();

    '' foreach moduleName in nameList {
    '' 	self.popClass();
    '' }
    
    self.checkToken( nextToken, ";" );
    
    return self.createNode( nodeKindImport, token.pos, [ typeInfoNone ], modulePath );
}

fn TransUnit.analyzeIf( token: stem ): stem {
    let list = {};
    table.insert(
	list, { "kind": "if", "exp": self.analyzeExp(),
		"block": self.analyzeBlock( "if" ) } );

    let nextToken = self.getToken();
    if nextToken.txt == "elseif" {
	while nextToken.txt == "elseif" {
	    table.insert(
		list, { "kind": "elseif", "exp": self.analyzeExp(),
			"block": self.analyzeBlock( "elseif" ) } );
	    nextToken = self.getToken();
	}
    }

    if nextToken.txt == "else" {
	table.insert(
	    list, { "kind": "else", "block": self.analyzeBlock( "else" ) } );
    }
    else {
	self.pushback();
    }

    return self.createNode(
	nodeKindIf, token.pos, [ typeInfoNone ], list );
}


fn TransUnit.analyzeSwitch( firstToken: stem ): stem {
    let exp = self.analyzeExp();

    self.checkNextToken( "{" );

    let caseList: stem[] = {};

    let nextToken = self.getToken();
    while ( nextToken.txt == "case" ) {
        self.checkToken( nextToken, "case" );
        let condexpList = self.analyzeExpList();
        let condBock = self.analyzeBlock( "switch" );
        table.insert( caseList, { "expList": condexpList, "block": condBock } );
        nextToken = self.getToken();
    }

    let defaultBlock: Node = nil;
    if nextToken.txt == "default" {
        defaultBlock = self.analyzeBlock( "default" );
    }
    self.checkNextToken( "}" );

    let info: stem = { "exp": exp, "caseList": caseList, "default": defaultBlock };
    
    return self.createNode(
	nodeKindSwitch, firstToken.pos, [ typeInfoNone ], info );
}


fn TransUnit.analyzeWhile( token: stem ): stem {
    let info = { "exp": self.analyzeExp(), "block": self.analyzeBlock( "while" ) };
    return self.createNode(
	nodeKindWhile, token.pos, [ typeInfoNone ], info );
}

fn TransUnit.analyzeRepeat( token: stem ): stem {
    let scope = self.pushScope();
    let info = { "block": self.analyzeBlock( "repeat", scope ),
		 "exp": self.analyzeExp() };
    self.popScope();
    let node = self.createNode(
        nodeKindRepeat, token.pos, [ typeInfoNone ], info );
    self.checkNextToken( ";" );
    return node;
}

fn TransUnit.analyzeFor( token: stem ): stem {

    let scope = self.pushScope();

    let val = self.getToken();
    if val.kind ~= Parser.kind.Symb {
	self.error( "not symbol" );
    }
    self.checkNextToken( "=" );
    let exp1 = self.analyzeExp();
    self.scope.add( val.txt, exp1.expType );
    self.checkNextToken( "," );
    let exp2 = self.analyzeExp();
    let token = self.getToken();
    let exp3 = nil;
    if token.txt == "," {
	exp3 = self.analyzeExp();
    }
    else {
	self.pushback();
    }

    let info = { "block": self.analyzeBlock( "for", scope ), "val": val,
		 "init": exp1, "to": exp2, "delta": exp3 };
    self.popScope();
    let node = self.createNode( nodeKindFor, token.pos, [ typeInfoNone ], info );
    return node;
}

fn TransUnit.analyzeApply( token: stem ): stem {
    let scope = self.pushScope();
    let varList = {};
    let nextToken = nil;
    repeat {
	let var = self.getToken();
	if var.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	table.insert( varList, var );
	nextToken = self.getToken();
    } nextToken.txt ~= ",";
    self.checkToken( nextToken, "of" );

    let exp = self.analyzeExp();
    if exp.kind ~= nodeKindExpCall {
	self.error( "not call" );
    }

    let block = self.analyzeBlock( "apply", scope );
    self.popScope();

    let info = { "varList": varList, "exp": exp, "block": block };
    return self.createNode( nodeKindApply, token.pos, [ typeInfoNone ], info );
}

fn TransUnit.analyzeForeach( token: stem, sortFlag: bool ): stem {
    let scope = self.pushScope();
    let valSymbol = nil;
    let keySymbol = nil;
    let nextToken = nil;
    for index = 1, 2 {
	let sym = self.getToken();
	if sym.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	if index == 1 {
	    valSymbol = sym;
	}
	else {
	    keySymbol = sym;
	}
	nextToken = self.getToken();
	if nextToken.txt ~= "," {
	    break;
	}
    }
    self.checkToken( nextToken, "in" );

    let exp = self.analyzeExp();
    if not exp.expType {
	self.error( "unknown type of exp" );
    }
    else {
	let itemTypeInfoList = exp.expType.get_itemTypeInfoList();
	if exp.expType.get_kind() == TypeInfoKindMap {
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 2 ] );
	    if keySymbol {
		self.scope.add( keySymbol.txt, itemTypeInfoList[ 1 ] );
	    }   
	}	
	elseif exp.expType.get_kind() == TypeInfoKindList or
	    exp.expType.get_kind() == TypeInfoKindArray
	{	
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 1 ] );
	    if keySymbol {
		self.scope.add( keySymbol.txt, typeInfoInt );
	    }
	    else {
		self.scope.add( "__index", typeInfoInt );
	    }   
	}
        else {
            self.error( "unknown kind type of exp for foreach-- %d:%d" (exp.pos.lineNo,
                                                                         exp.pos.column) );
        }
    }
	

    let block = self.analyzeBlock( "foreach", scope );

    self.popScope();

    let info = { "val": valSymbol, "key": keySymbol,
		 "exp": exp, "block": block, "sort": sortFlag };
    return self.createNode( sortFlag and nodeKindForsort or nodeKindForeach,
			    token.pos, [ typeInfoNone ], info );	    
}

fn TransUnit.analyzeRefType(): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let refFlag = false;
    if token.txt == "&" {
	refFlag = true;
	token = self.getToken();
    }
    let mutFlag = false;
    if token.txt == "mut" {
	mutFlag = true;
	token = self.getToken();
    }
    ''let name = self.checkSymbol( token );
    let name: Node = nil;
    let typeInfo = typeInfoStem;
    if self.checkSymbol( token ) {
	name = self.analyzeExpSymbol( firstToken, token, "symbol", token, true );
	typeInfo = name.expType;
    }
    else {
	self.pushback();
    }
    let arrayMode = "no";
    token = self.getToken();
    if token.txt == '[' or token.txt == '[@' {
	if token.txt == '[' {
	    arrayMode = "list";
	    typeInfo = TypeInfo.createList( [ typeInfo ] );
	}
	else {
	    arrayMode = "array";
	    typeInfo = TypeInfo.createArray( [ typeInfo ] );
	}
	token = self.getToken();
	if token.txt ~= ']' {
	    self.pushback();
	    self.checkNextToken( ']' );
	}
    }
    elseif token.txt == "<" {
	let genericList: Node[] = {};
	let nextToken: stem = nil;
	repeat {
	    let typeExp = self.analyzeRefType();
		
	    table.insert( genericList, typeExp.expType );
	    nextToken = self.getToken();
	} nextToken.txt ~= ",";
	self.checkToken( nextToken, '>' );
	if typeInfo.kind == TypeInfoKindMap {
	    typeInfo = TypeInfo.createMap( genericList[1],genericList[2] );
	}
	else {
	    self.error( string.format( "not support generic: %s", typeInfo.getTxt() ) );
	}
    }
    else {
	self.pushback();
    }


    return self.createNode(
	nodeKindRefType, firstToken.pos, [ typeInfo ], 
	{ "name": name, "refFlag": refFlag, "mutFlag": mutFlag, "array": arrayMode } );
}


fn TransUnit.analyzeDeclMember(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem {
    let varName = self.getSymbolToken();
    let token = self.getToken();
    let refType = self.analyzeRefType();
    token = self.getToken();

    let getterMode = "none";
    let setterMode = "none";
    if token.txt == "{" {
        let nextToken = self.getToken();
        if nextToken.txt == "pub" or nextToken.txt == "pri" {
            getterMode = nextToken.txt;
            nextToken = self.getToken();
            if nextToken.txt == "," {
                nextToken = self.getToken();
                if nextToken.txt == "pub" or nextToken.txt == "pri" {
                    setterMode = nextToken.txt;
                    nextToken = self.getToken();
                }   
            }
        }
        self.checkToken( nextToken, "}" );
        token = self.getToken();
    }
    
    '' accessor
    self.checkToken( token, ";" );

    self.scope.add( varName.txt, refType.expType );

    let info = {
        "name": varName, "refType": refType.expType,
	"staticFlag": staticFlag, "accessMode": accessMode,
        "getterMode": getterMode, "setterMode": setterMode
    };
	
    return self.createNode(
	nodeKindDeclMember, firstToken.pos, refType.expTypeList, info );
}

fn TransUnit.analyzeDeclMethod(
    accessMode: str, staticFlag: bool,
    className: Parser.Token, firstToken: Parser.Token, name: Parser.Token ): stem
{
    let node = self.analyzeDeclFunc( accessMode, staticFlag, className, name, name );
    return node;
}

fn TransUnit.analyzeDeclClass( classAccessMode: str, classToken: stem ): stem {
    let name = self.getToken();
    self.checkNextToken( "{" );

    let classTypeInfo = self.pushClass( false, name.txt );

    let fieldList:Node[] = {};
    let memberList:Node[] = [];
    let methodName2Node: Map<str,Node> = {};
    let node = self.createNode(
	nodeKindDeclClass, classToken.pos, [ classTypeInfo ],
        
	{ "accessMode": classAccessMode, "name": name, "fieldList": fieldList,
          "memberList": memberList, "scope": self.scope,
          "outerMethodSet": {}
        } );
    self.typeInfo2ClassNode[ classTypeInfo ] = node;


    while true {
	let token = self.getToken();
	if token.txt == "}" {
	    break;
	}
	let accessMode = "pri";
	if token.txt == "pub" or token.txt == "pro" or
	    token.txt == "pri" or token.txt == "global"
	{
	    accessMode = token.txt;
	    token = self.getToken();
	}
	let staticFlag = false;
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
	if token.txt == "let" {
            let memberNode = self.analyzeDeclMember( accessMode, staticFlag, token );
	    table.insert( fieldList, memberNode );
            table.insert( memberList, memberNode );
	}
	else {
            let methodNode = self.analyzeDeclMethod(
		accessMode, staticFlag, name, token, token );
	    table.insert( fieldList, methodNode );
	}
    }


    '' accessor の生成
    foreach memberNode in memberList {
        let memberName = memberNode.info.name;
        let getterName = "get_" .. memberName.txt;
        let accessMode = memberNode.info.getterMode;
        if accessMode ~= "none" and not self.scope.getTypeInfo( getterName )
        {
            self.scope.add( getterName,
                            TypeInfo.createFunc(
                                true, false, false, accessMode, getterName, nil,
                                [ memberNode.expType ] ));
        }
        let setterName = "set_" .. memberName.txt;
        let accessMode = memberNode.info.setterMode;
        if memberNode.info.setterMode ~= "none" and
            not self.scope.getTypeInfo( setterName )
        {       
            self.scope.add( setterName,
                            TypeInfo.createFunc(
                                true, false, false, accessMode, setterName, nil,
                                [ memberNode.expType ]
                            ));
        }
    }
    
    self.popClass();

    return node;
}

fn TransUnit.analyzeDeclFunc(
    accessMode: str, staticFlag: bool, classNameToken: stem,
    firstToken: stem, name: stem ) : stem
{
    let argList = {};
    let token = self.getToken();
    if not name {
	if token.txt ~= "(" {
	    name = self.checkSymbol( token );
	    token = self.getToken();
	}
    }
    else {
	self.checkSymbol( name );
    }
    let needPopFlag = false;
    if token.txt == "." {
        needPopFlag = true;
	classNameToken = name;

	self.pushClass( false, name.txt );
	
	name = self.getSymbolToken();
	token = self.getToken();
    }

    self.checkToken( "(" );

    let kind = nodeKindDeclConstr;
    if classNameToken {
	if name.txt == "__init" {
	    kind = nodeKindDeclConstr;
	}
	else {
	    kind = nodeKindDeclMethod;
	}
    }
    else {
	kind = nodeKindDeclFunc;
        if not staticFlag {
            staticFlag = true;
        }
    }

    let scope = self.pushScope();
    repeat {
	let argName = self.getToken();
	if argName.txt == ")" {
	    token = argName;
	    break;
	}
	elseif argName.txt == "..." {
	    table.insert(
		argList,
		self.createNode(
		    nodeKindDeclArgDDD, argName.pos, [ typeInfoNone ], argName ) );
	}
	else {
	    self.checkSymbol( argName );

	    self.checkNextToken( ":" );
	    let refType = self.analyzeRefType();
	    let arg = self.createNode(
                nodeKindDeclArg, argName.pos, refType.expTypeList ,                       
		{ "name": argName, "argType": refType } );
	    self.scope.add( argName.txt, refType.expType );
	    table.insert( argList, arg );
	}
	token = self.getToken();
    } token.txt ~= ",";

    self.checkToken( token, ")" );

    token = self.getToken();
    let retTypeList = {};
    let retTypeInfoList = {};
    if token.txt == ":" {
	repeat {
	    let refType = self.analyzeRefType();
	    table.insert( retTypeList, refType );
	    table.insert( retTypeInfoList, refType.expType );
	    token = self.getToken();
	} token.txt ~= ",";
    }

    let typeInfo = TypeInfo.createFunc(
        false, false, staticFlag, accessMode,
	name and name.txt or "", nil, retTypeInfoList );
    if name {
	scope.get_parent().add( name.txt, typeInfo );
    }

    let node:Node = nil;
    let info = nil;
    if token.txt == ";" {
	node = self.createNoneNode();
    }
    else {
        self.pushback();
        let body = self.analyzeBlock( "func", scope );
        info = { "name": name, "argList": argList, "staticFlag": staticFlag,
		 "body": body, "accessMode": accessMode,
                 "className": classNameToken,
		 "retTypeList": retTypeList, "retTypeInfoList": retTypeInfoList };

        node = self.createNode( kind, firstToken.pos, [ typeInfo ], info );
    }
    self.popScope();

    if needPopFlag {
        self.addMethod( classNameToken.txt, node );
	self.popClass();
    }

    return node;
}

fn TransUnit.analyzeDeclVar(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem
{

    let typeInfoList : TypeInfo[] = {};
	
    let varList = {};
    let token = nil;
    repeat {
	let varName = self.getSymbolToken();
	token = self.getToken();
	let typeInfo = typeInfoNone;
	let refType = nil;
	if token.txt == ":" {
	    refType = self.analyzeRefType();
	    typeInfo = refType.expType;
	    token = self.getToken();
	}
	table.insert( varList, { "name": varName, "refType": refType } );
	table.insert( typeInfoList, typeInfo );
    } token.txt ~= ",";

    let expList = nil;
    if token.txt == "=" {
	expList = self.analyzeExpList();
	if not expList {
	    self.error( "expList is nil" );
	}	
    }
    if expList {
        let nodeList: Node[] = expList.info;
        foreach exp, index in nodeList {
            if not typeInfoList[ index ] or typeInfoList[ index ] == typeInfoNone {
		typeInfoList[ index ] = exp[ "expType" ];
	    }
	}
    }

    self.checkNextToken( ";" );

    let declVarInfo = { "accessMode": accessMode,
			"varList": varList, "expList": expList,
			"typeInfoList": typeInfoList }; 
    let node = self.createNode(
	nodeKindDeclVar, firstToken.pos, [ typeInfoNone ], declVarInfo );


    foreach typeInfo, index in typeInfoList {
	self.scope.add( varList[ index ].name.txt, typeInfo );
    }
    return node;
}

fn TransUnit.analyzeExpList(): Node {
    let expList = {};
    let firstExp = nil;
    repeat {
	let exp = self.analyzeExp();
	if not firstExp {
	    firstExp = exp;
	}
	table.insert( expList, exp );
	let token = self.getToken();
    } token.txt ~= ",";

    self.pushback();

    return self.createNode(
        nodeKindExpList, firstExp.pos, [ typeInfoNone ], expList );
}

fn TransUnit.analyzeListConst( token: stem ): stem {
    let nextToken = self.getToken();
    let expList = nil;
    let itemTypeInfo = typeInfoNone;
    if nextToken.txt ~= "]" {
	self.pushback();
	expList = self.analyzeExpList();
	self.checkNextToken( "]" );
        let nodeList: Node[] = expList.info;
	foreach exp in nodeList {
	    if itemTypeInfo == typeInfoNone {
		itemTypeInfo = exp[ "expType" ];
	    }
	    elseif itemTypeInfo ~= exp[ "expType" ] {
		itemTypeInfo = typeInfoStem;
	    }
	}
    }
    let kind = nodeKindLiteralArray;
    if token.txt == '[' {
	kind = nodeKindLiteralList;
    }
    return self.createNode(
	kind, token.pos, [ TypeInfo.createList( [ itemTypeInfo ] ) ], expList );
}

fn TransUnit.analyzeMapConst( token: stem ): stem {
    let nextToken = nil;
    let map = {};
    let pairList = {};
    let keyTypeInfo = typeInfoNone;
    let valTypeInfo = typeInfoNone;
    repeat {
	nextToken = self.getToken();
	if nextToken.txt == "}" {
	    break;
	}
	self.pushback();

	let key = self.analyzeExp();
	if key.expType ~= keyTypeInfo {
	    if keyTypeInfo ~= typeInfoNone {
		keyTypeInfo = typeInfoStem;
	    }
	    else {
		keyTypeInfo = key.expType;
	    }
	}
	self.checkNextToken( ":" );
	let val = self.analyzeExp();
	if val.expType ~= valTypeInfo {
	    if valTypeInfo ~= typeInfoNone {
		valTypeInfo = typeInfoStem;
	    }
	    else {
		valTypeInfo = val.expType;
	    }
	}
	
	table.insert( pairList, { "key": key, "val": val } );
	map[ key ] = val;
	nextToken = self.getToken();
    } nextToken.txt ~= ",";

    let typeInfo = TypeInfo.createMap( keyTypeInfo, valTypeInfo );

    self.checkToken( nextToken, "}" );
    return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ], 
			    { "map": map, "pairList": pairList } );
}

fn TransUnit.analyzeExpRefItem( token: stem, exp: stem ): stem {
    let indexExp = self.analyzeExp();
    self.checkNextToken( "]" );

    let info = { "val": exp, "index": indexExp };
    let typeInfo = typeInfoStem;
    if exp.expType {
	if exp.expType.kind == TypeInfoKindMap {
	    typeInfo = exp.expType.get_itemTypeInfoList()[2];
	}	
	elseif exp.expType.kind == TypeInfoKindArray or
	    exp.expType.kind == TypeInfoKindArray
	{	
	    typeInfo = exp.expType.get_itemTypeInfoList()[1];
	}
    }
    
    return self.createNode( nodeKindExpRefItem, token.pos, [ typeInfo ], info );
}

fn TransUnit.analyzeExpCont( firstToken: stem, exp: stem, skipFlag: bool ): stem {
    let nextToken = self.getToken();

    if not skipFlag {
	repeat {
	    let matchFlag = false;
	    if nextToken.txt == "[" {
		matchFlag = true;
		exp = self.analyzeExpRefItem( nextToken, exp );
		nextToken = self.getToken();
	    }   
	    if nextToken.txt == "(" {
		matchFlag = true;
		let work = self.getToken();
		let expList = nil;
		if work.txt ~= ")" {
		    self.pushback();
		    expList = self.analyzeExpList();
		    self.checkNextToken( ")" );
		}	
		let info = { "func": exp, "argList": expList };

		exp = self.createNode(
		    nodeKindExpCall, firstToken.pos,
                    exp.expType.get_retTypeInfoList(), info );
                    ''[ exp.expType ], info );
                    ''[ typeInfoStem ], info );
		nextToken = self.getToken();
	    }   
	} not matchFlag;
    }

    if nextToken.txt == "." {
	return self.analyzeExpSymbol(
	    firstToken, self.getToken(), "field", exp, skipFlag );
    }

    self.pushback();
    return exp;

}

fn TransUnit.analyzeExpSymbol(
    firstToken: stem, token: stem, mode: str, prefixExp: Node, skipFlag: bool ): stem {
    let exp = nil;

    if mode == "field" {
	let info = { "field": token, "prefix": prefixExp };
	let typeInfo = typeInfoNone;
	if not prefixExp.expType {
	    self.error( "unknown prefix type: " .. getNodeKindName( prefixExp.kind ) );
	}
	if prefixExp.expType.get_kind() == TypeInfoKindClass {
	    let classScope = self.typeInfo2Scope[ prefixExp.expType ];
	    let className = prefixExp.expType.get_txt();
	    if not classScope {
		self.error( "not found field: " .. className );
	    }
	    typeInfo = classScope.getTypeInfo( token.txt );
	    if not typeInfo {
                print( "hoge", classScope.symbol2TypeInfoMap );
                foreach name in classScope.symbol2TypeInfoMap {
                    print( "hoge", name );
                }
		self.error( string.format(
		    "not found field typeInfo: %s.%s %s",
		    className, token.txt, classScope) );
	    }
	}
	exp = self.createNode(
            nodeKindRefField, firstToken.pos, [ typeInfo ], info );
    }
    elseif mode == "symbol" {
	let typeInfo = self.scope.getTypeInfo( token.txt );
	if not typeInfo and token.txt == "self" {
	    let classInfo = self.classList[#self.classList];
	    typeInfo = classInfo.typeInfo;
	}
	if not typeInfo {
	    self.error( "not found type -- " .. token.txt );
	}
	exp = self.createNode( nodeKindExpRef, firstToken.pos,
                               [ typeInfo ], token );         
    }
    elseif mode == "fn" {
	exp = self.analyzeDeclFunc( "pri", false, nil, token, nil );
    }
    else {
	self.error( "illegal mode", mode );
    }

    return self.analyzeExpCont( firstToken, exp, skipFlag );
}

fn TransUnit.analyzeExpOp2( firstToken: stem, exp: stem, prevOpLevel: int ): stem, int {

    while true {
        let nextToken = self.getToken();
        let opLevel = prevOpLevel;
        let opTxt = nextToken.txt;
        
        if opTxt == "@" {
	    let castType = self.analyzeRefType();
	    exp = self.createNode(
                nodeKindExpCast, firstToken.pos, castType.expTypeList, exp );
        }   
        elseif nextToken.kind == Parser.kind.Ope {
	    if Parser.isOp2( opTxt ) {
                opLevel = op2levelMap[ opTxt ];
                if not opLevel {
                    error( string.format( "unknown op -- %s %s",
                                          opTxt, prevOpLevel ) );       
                }   
                if prevOpLevel and opLevel <= prevOpLevel {
                    self.pushback();
                    return exp;
                }   
                
	        let exp2 = self.analyzeExp( false, opLevel );
	        let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };

'' regOpLevel( 2, [@ "or" ] );
'' regOpLevel( 2, [@ "and" ] );
'' regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
'' regOpLevel( 2, [@ "|" ] );
'' regOpLevel( 2, [@ "~" ] );
'' regOpLevel( 2, [@ "&" ] );
'' regOpLevel( 2, [@ "<<", ">>" ] );
'' regOpLevel( 2, [@ ".." ] );
'' regOpLevel( 2, [@ "+", "-" ] );
'' regOpLevel( 2, [@ "*", "/", "//", "%" ] );
'' regOpLevel( 1, [@ "not", "#", "-", "~" ] );
'' regOpLevel( 1, [@ "^" ] );
                
	        exp = self.createNode(
                    nodeKindExpOp2, firstToken.pos, [ typeInfoNone ], info );
	    }   
	    else {
	        self.error( "illegal op" );
	    }   
        }   
        else {
	    self.pushback();
	    return exp;
        }
    }
    return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}

fn TransUnit.analyzeExp( skipOp2Flag: bool, prevOpLevel: int ): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let exp = nil;

    if token.kind == Parser.kind.Dlmt {
	if token.txt == "..." {
	    return self.createNode(
                nodeKindExpDDD, firstToken.pos, [ typeInfoNone ], token );
	}

	if token.txt == '[' or token.txt == '[@' {
	    return self.analyzeListConst( token );
	}
	if token.txt == '{' {
	    return self.analyzeMapConst( token );
	}
	if token.txt == "(" {
	    exp = self.analyzeExp();
	    self.checkNextToken( ")" );
	    exp = self.createNode(
                nodeKindExpParen, firstToken.pos, exp.expTypeList, exp );
	    exp = self.analyzeExpCont( firstToken, exp, false );
	}
    }

    if token.txt == "new" {
	let nextToken = self.getToken();
	exp = self.analyzeExpSymbol(
	    firstToken, nextToken, "symbol", nextToken, true );
      
	self.checkNextToken( "(" );
	nextToken = self.getToken();
	let argList: stem = nil;
	if nextToken.txt ~= ")" {
	    self.pushback();
	    argList = self.analyzeExpList();
	    self.checkNextToken( ")" );
	}	
	exp = self.createNode( nodeKindExpNew, firstToken.pos, exp.expTypeList,
			       { "symbol": exp, "argList": argList } );
	exp = self.analyzeExpCont( firstToken, exp, false );
    }

    if token.kind == Parser.kind.Ope and Parser.isOp1( token.txt ) {
	'' 単項演算
	exp = self.analyzeExp( true, op1levelMap[ token.txt] );
	let typeInfo = typeInfoNone;
	if token.txt == "-" {
	    typeInfo = exp.expType;
	}	
	elseif token.txt == "#" {
	    typeInfo = typeInfoInt;
	}
	elseif token.txt == "not" {
	    typeInfo = typeInfoBool;
	}
	else {
	    self.error( "unknown op1" );
	}
	    
	exp = self.createNode( nodeKindExpOp1, firstToken.pos, [ typeInfo ], 
			       { "op": token, "exp": exp } );   
	return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
    }


    if token.kind == Parser.kind.Int {
	exp = self.createNode( nodeKindLiteralInt, firstToken.pos, [ typeInfoInt ], 
			       { "token": token, "num": tonumber( token.txt ) } );
    }
    elseif token.kind == Parser.kind.Real {
	exp = self.createNode( nodeKindLiteralReal, firstToken.pos, [ typeInfoReal ], 
			       { "token": token, "num": tonumber( token.txt ) } );
    }
    elseif token.kind == Parser.kind.Char {
	let num = 0;
	if #(token.txt) == 1 {
	    num = token.txt.byte( 1 );
	}
	else {
	    num = quotedChar2Code[ token.txt.sub( 2, 2 ) ];
	}
	exp = self.createNode( nodeKindLiteralChar, firstToken.pos, [ typeInfoChar ], 
			       { "token": token, "num": num } );
    }
    elseif token.kind == Parser.kind.Str {
	let nextToken = self.getToken();
	let formatArgList = {};
	if nextToken.txt == "(" {
	    repeat {
		let arg = self.analyzeExp();
		table.insert( formatArgList, arg );
		nextToken = self.getToken();
	    } nextToken.txt ~= ",";
	    self.checkToken( nextToken, ")" );
	    nextToken = self.getToken();
	}
	exp = self.createNode(
            nodeKindLiteralString, firstToken. os, [ typeInfoString ],            
	    { "token": token, "argList": formatArgList } );
	token = nextToken;
	if token.txt == "[" {
	    exp = self.analyzeExpRefItem( token, exp );
	}
	else {
	    self.pushback();
	}
    }
    elseif token.txt == "fn" {
	exp = self.analyzeExpSymbol( firstToken, token, "fn", token, false );
    }
    elseif token.kind == Parser.kind.Symb {
	exp = self.analyzeExpSymbol( firstToken, token, "symbol", token, false );
    }
    elseif token.kind == Parser.kind.Type {
	exp = self.createNode( nodeKindExpRef, firstToken.pos, [ typeInfoNone ], token );
    }
    elseif token.txt == "true" or token.txt == "false" {
	exp = self.createNode(
            nodeKindLiteralBool, firstToken.pos, [ typeInfoBool ], token );
    }
    elseif token.txt == "nil" {
	exp = self.createNode(
            nodeKindLiteralNil, firstToken.pos, [ typeInfoNil ] , token );
    }

    if not exp {
	self.error( "illegal exp" );
    }

    if skipOp2Flag {
	return exp;
    }

    return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}

pub fn TransUnit.createAST( parser: str ): Map {

    self.registBuiltInScope();

    let rootInfo = {};
    rootInfo.childlen = {};
    let ast = self.createNode(
	nodeKindRoot, { "lineNo": 0, "column": 0 }, [ typeInfoNone ], rootInfo );
    self.parser = parser;
    self.moduleName2Info = {};
    self.analyzeStatement( rootInfo.childlen );

    let token = self.getTokenNoErr();
    if token {
	error( string.format( "unknown:%d:%d:(%s) %s",
			      token.pos.lineNo, token.pos.column,
			      Parser.getKindTxt( token.kind ), token.txt ) );
    }

    return ast;
}

fn TransUnit.analyzeStatement( stmtList: stem[], termTxt: str ) {
    while true {
	let token = self.getTokenNoErr();
	if not token {
	    break;
	}

	let statement = self.analyzeDecl( "pri", false, token, token );

	if not statement {
	    if token.txt == termTxt {
		self.pushback();
		break;
	    }
	    elseif token.txt == "pub" or token.txt == "pro" or
		token.txt == "pri" or token.txt == "global" or token.txt == "static"
	    {
		let accessMode = (token.txt ~= "static") and token.txt or "pri";
		let staticFlag = (token.txt == "static");

		let nextToken = nil;
		if token.txt ~= "static" {
		    nextToken = self.getToken();
		}
		else {
		    nextToken = token;
		}
		statement = self.analyzeDecl( accessMode, staticFlag, token, nextToken );
	    }
	    elseif token.txt == "{" {
		self.pushback();
		statement = self.analyzeBlock( "{" );
	    }
	    elseif token.txt == "if" {
		statement = self.analyzeIf( token );
	    }
            elseif token.txt == "switch" {
                statement = self.analyzeSwitch( token );
            }
	    elseif token.txt == "while" {
		statement = self.analyzeWhile( token );
	    }
	    elseif token.txt == "repeat" {
		statement = self.analyzeRepeat( token );
	    }
	    elseif token.txt == "for" {
		statement = self.analyzeFor( token );
	    }
	    elseif token.txt == "apply" {
		statement = self.analyzeApply( token );
	    }
	    elseif token.txt == "foreach" {
		statement = self.analyzeForeach( token, false );
	    }
	    elseif token.txt == "forsort" {
		statement = self.analyzeForeach( token, true );
	    }
	    elseif token.txt == "return" {
		let expList = self.analyzeExpList();
		self.checkNextToken( ";" );
		statement = self.createNode(
		    nodeKindReturn, token.pos, [ typeInfoNone ], expList );
	    }
	    elseif token.txt == "break" {
		self.checkNextToken( ";" );
		statement = self.createNode(
		    nodeKindBreak, token.pos, [ typeInfoNone ], nil );}
	    elseif token.txt == "import" {
		statement = self.analyzeImport( token );
	    }
	    else {
		self.pushback();
		let exp = self.analyzeExp();
		self.checkNextToken( ";" );
		statement = self.createNode(
		    nodeKindStmtExp, self.currentToken.pos, [ typeInfoNone ], exp );
	    }
	}

	if not statement {
	    break;
	}
	table.insert( stmtList, statement );
    }
}
