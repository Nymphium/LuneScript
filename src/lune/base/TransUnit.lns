import lune.base.Parser;
import lune.base.Util;

pub let rootTypeId = 1;
let typeIdSeed = rootTypeId + 1;

pub proto class TypeInfo;

let rootTypeInfo = nil;

pub let typeInfoKind:Map<str,TypeInfo> = {};
let builtInTypeMap:Map<str,TypeInfo> = {};
let builtInTypeIdSet:Map<int,bool> = {};

pub let TypeInfoKindRoot = 0;
pub let TypeInfoKindModule = 1;
pub let TypeInfoKindPrim = 2;
pub let TypeInfoKindList = 3;
pub let TypeInfoKindArray = 4;
pub let TypeInfoKindMap = 5;
pub let TypeInfoKindClass = 6;
pub let TypeInfoKindFunc = 7;
pub let TypeInfoKindMethod = 8;
pub let TypeInfoKindNilable = 9;
pub let TypeInfoKindMacro = 10;

pub fn isBuiltin( typeId: int ) : bool {
    return builtInTypeIdSet[ typeId ];
}


class OutStream {
    pub fn write( txt: str );
}

pub class TypeInfo {
    pri let externalFlag: bool;
    pri let itemTypeInfoList: TypeInfo[@] { pub };
    pri let retTypeInfoList: TypeInfo[@] { pub };
    pri let parentInfo: TypeInfo { pub };
    pri let typeId: int { pub };
    ''pri let txt: str { pub };
    pri let txt: str;
    pri let kind: int { pub };
    pri let staticFlag: bool { pub };
    pri let accessMode: str { pub };
    '' コンパイラで自動生成された型情報の場合 true。 accessor 等。
    pri let autoFlag: bool { pub };

    '' unwrap 後の TypeInfo
    pri let orgTypeInfo: TypeInfo { pub };
    '' 基底クラス
    pri let baseTypeInfo: TypeInfo { pub };

    pri let nilable: bool { pub };
    '' この型の nilable 版の TypeInfo
    pri let nilableTypeInfo: TypeInfo { pub };
    pri let children: TypeInfo[] { pub };

    fn __init( baseTypeInfo: TypeInfo, orgTypeInfo: TypeInfo,
	       autoFlag: bool, externalFlag: bool, staticFlag: bool, accessMode: str,
               txt: str, parentInfo: TypeInfo, typeId: int, kind: int,
	       itemTypeInfoList: TypeInfo[@], retTypeInfoList: TypeInfo[@] )
    {
        self.baseTypeInfo = baseTypeInfo;
        self.autoFlag = autoFlag;
        self.externalFlag = externalFlag;
        self.staticFlag = staticFlag;
        self.accessMode = accessMode;
        self.txt = txt;
        self.kind = kind;
        self.itemTypeInfoList = itemTypeInfoList or [@];
        self.retTypeInfoList = retTypeInfoList or [@];
        self.orgTypeInfo = orgTypeInfo;
        self.parentInfo = parentInfo;
        self.children = [];

        if rootTypeInfo and not parentInfo {
            Util.debugLog();
            error( "" );
        }

        if kind == TypeInfoKindRoot {
	    self.typeId = typeId;
            self.nilable = false;
            rootTypeInfo = self;
        }
        elseif not orgTypeInfo {
            if parentInfo {
                table.insert( parentInfo.children, self );
            }
	    self.typeId = typeId + 1;
	    self.nilable = false;
	    self.nilableTypeInfo = new TypeInfo(
	        baseTypeInfo, self, autoFlag, externalFlag, staticFlag, accessMode, "",
                parentInfo, typeIdSeed,
	        TypeInfoKindNilable, itemTypeInfoList, retTypeInfoList );
	    typeIdSeed = typeIdSeed + 1;
        }
        else {
	    self.typeId = typeId;
            self.nilable = true;
            self.nilableTypeInfo = nil;
        }
    }

    pub fn getParentId(): int {
        return self.parentInfo and self.parentInfo.typeId or rootTypeId;
    }

    pub fn get_baseId(): int {
        return self.baseTypeInfo and self.baseTypeInfo.typeId or rootTypeId;
    }

    pub fn serialize( stream: OutStream ) {
        if self.typeId == rootTypeId {
            return nil;
        }

        let parentId = self.getParentId();
	if self.orgTypeInfo {
            stream.write(
                '{ parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }' (
                    parentId, self.typeId, self.orgTypeInfo.typeId ) );
            return nil;
	}

        fn serializeTypeInfoList( name: str, list: TypeInfo[@], onlyPub: bool ): str {
            let work = name;
	    foreach typeInfo in list {
                if not onlyPub or typeInfo.accessMode == "pub"  {
                    if #work ~=  #name {
		        work = work .. ", ";
                    }
	            work = "%s%d" (work, typeInfo.typeId );
                }
	    }
            return work .. "}, ";
        }

        let txt = ```{ parentId = %d, typeId = %d, baseId = %d, txt = '%s',
        staticFlag = %s, accessMode = '%s', kind = %d, ```
        ( parentId, self.typeId, self.get_baseId(), self.txt,
          self.staticFlag, self.accessMode, self.kind );

        stream.write(
            txt .. serializeTypeInfoList( "itemTypeId = {",
                                          self.itemTypeInfoList ) ..
            serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList ) ..
            serializeTypeInfoList( "children = {", self.children, true ) .. "}\n" );
    }



    pub fn getTxt() : str {
	if self.orgTypeInfo {
	    return self.orgTypeInfo.getTxt() .. "!";
	}
	if self.kind == TypeInfoKindArray {
            if not self.itemTypeInfoList[1] {
                return "[@]";
            }
	    return self.itemTypeInfoList[1].getTxt() .. "[@]";
	}
	if self.kind == TypeInfoKindList {
            if not self.itemTypeInfoList[1] {
                return "[]";
            }
	    return self.itemTypeInfoList[1].getTxt() .. "[]";
	}
	if self.itemTypeInfoList and #self.itemTypeInfoList > 0 {
	    let txt = self.txt .. "<";
	    foreach typeInfo, index in self.itemTypeInfoList {
		if index ~= 1 {
		    txt = txt .. ",";
		}
		txt = txt .. typeInfo.getTxt();
	    }

	    return txt .. ">";
	}
	if self.txt {
	    return self.txt;
	}
	return "";
    }

    pub fn equals( typeInfo: TypeInfo, depth: int ): bool {
        if not typeInfo {
            return false;
        }
	if not depth {
	    depth = 1;
	}
	if self.typeId == typeInfo.typeId {
	    return true;
	}
	'' プリミティブな設定のチェック
	if ''self.externalFlag ~= typeInfo.externalFlag or
	self.kind ~= typeInfo.kind or
	    self.staticFlag ~= typeInfo.staticFlag or
	    self.accessMode ~= typeInfo.accessMode or
	    self.autoFlag ~= typeInfo.autoFlag or
	    self.nilable ~= typeInfo.nilable
	{
	    '' errorLog( "%s, %s" ( self.externalFlag, typeInfo.externalFlag ) );
	    '' errorLog( "%s, %s" ( self.kind, typeInfo.kind ) );
	    '' errorLog( "%s, %s" ( self.staticFlag, typeInfo.staticFlag ) );
	    '' errorLog( "%s, %s" ( self.accessMode, typeInfo.accessMode ) );
	    '' errorLog( "%s, %s" ( self.autoFlag, typeInfo.autoFlag ) );
	    '' errorLog( "%s, %s" ( self.nilable, typeInfo.nilable ) );
	    return false;
	}

	if (not self.itemTypeInfoList and typeInfo.itemTypeInfoList or
	     self.itemTypeInfoList and not typeInfo.itemTypeInfoList or
	     not self.retTypeInfoList and typeInfo.retTypeInfoList or
	     self.retTypeInfoList and not typeInfo.retTypeInfoList or
	     not self.orgTypeInfo and typeInfo.orgTypeInfo or
	     self.orgTypeInfo and not typeInfo.orgTypeInfo )
	{
	    Util.errorLog( "%s, %s", self.itemTypeInfoList, typeInfo.itemTypeInfoList );
	    Util.errorLog( "%s, %s", self.retTypeInfoList, typeInfo.retTypeInfoList );
	    Util.errorLog( "%s, %s", self.orgTypeInfo, typeInfo.orgTypeInfo );
            ''          error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
            ''      				   typeInfo.getTxt(), typeInfo.typeId ) );
	    return false;
	}

    	if self.itemTypeInfoList {
	    if #self.itemTypeInfoList ~= #typeInfo.itemTypeInfoList {
		return false;
	    }
	    foreach item, index in self.itemTypeInfoList {
		if not item.equals( typeInfo.itemTypeInfoList[ index ], depth + 1 ) {
                    ''		    error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
                    ''      					   typeInfo.getTxt(), typeInfo.typeId ) );
		    return false;
		}
	    }
	}

    	if self.retTypeInfoList {
	    if #self.retTypeInfoList ~= #typeInfo.retTypeInfoList {
                ''		error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
                ''	        			       typeInfo.getTxt(), typeInfo.typeId ) );
	        return false;
	    }
	    foreach item, index in self.retTypeInfoList {
		if not item.equals( typeInfo.retTypeInfoList[ index ], depth + 1 ) {
                    ''		    error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
                    ''      					   typeInfo.getTxt(), typeInfo.typeId ) );
		    return false;
		}
	    }
	}

	if self.orgTypeInfo and not self.orgTypeInfo.equals( typeInfo.orgTypeInfo, depth + 1 ) {
            ''	    error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
            ''      				   typeInfo.getTxt(), typeInfo.typeId ) );
	    return false;
	}

	return true;
    }


    pub static fn cloneToPublic( typeInfo: TypeInfo ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
        return new TypeInfo(
            typeInfo.baseTypeInfo, nil, typeInfo.autoFlag,
            typeInfo.externalFlag, typeInfo.staticFlag,
            "pub", typeInfo.txt, typeInfo.parentInfo, typeIdSeed, typeInfo.kind,
            typeInfo.itemTypeInfoList, typeInfo.retTypeInfoList );
    }



    pub static fn create(
        baseInfo: TypeInfo,
        parentInfo: TypeInfo, staticFlag: bool, kind: int, txt: str,
        itemTypeInfo: TypeInfo[@],
	retTypeInfoList: TypeInfo[@] ): TypeInfo {
	    if kind == TypeInfoKindPrim {
	        return builtInTypeMap[ txt ];
	    }
	    typeIdSeed = typeIdSeed + 1;
	    let info = new TypeInfo( baseInfo, nil, false, true, staticFlag, "pub", txt,
                                     parentInfo, typeIdSeed,
                                     kind, itemTypeInfo, retTypeInfoList );
	    return info;
        }

    pub static fn createBuiltin( idName: str, typeTxt: str, kind: int ): TypeInfo {
        let typeId = typeIdSeed + 1;
        if kind == TypeInfoKindRoot {
            typeId = rootTypeId;
        }
        else {
	    typeIdSeed = typeIdSeed + 1;
        }
	let info = new TypeInfo( nil, nil, false, false, false,
	                         "pub", typeTxt, rootTypeInfo, typeId, kind );
	typeInfoKind[ idName ] = info;
	builtInTypeMap[ typeTxt ] = info;
        builtInTypeIdSet[ info.typeId ] = true;
	return info;
    }

    pub static fn createList(
        accessMode: str, parentInfo: TypeInfo, itemTypeInfo: TypeInfo[] ): TypeInfo {
	    if not itemTypeInfo or #itemTypeInfo == 0 {
	        error( "illegal list type: %s" (itemTypeInfo) );
	    }
	    typeIdSeed = typeIdSeed + 1;
	    return new TypeInfo( nil, nil, false, false, false, accessMode, "",
                                 rootTypeInfo, typeIdSeed, TypeInfoKindList, itemTypeInfo  );
        }

    pub static fn createArray(
        accessMode: str, parentInfo: TypeInfo, itemTypeInfo: TypeInfo[] ): TypeInfo {
	    typeIdSeed = typeIdSeed + 1;
            return new TypeInfo( nil, nil, false, false, false, accessMode, "",
                                 rootTypeInfo, typeIdSeed, TypeInfoKindArray, itemTypeInfo );
        }

    pub static fn createMap(
        accessMode: str, parentInfo: TypeInfo,
        keyTypeInfo: TypeInfo, valTypeInfo: TypeInfo ): TypeInfo
    {
	typeIdSeed = typeIdSeed + 1;
        return new TypeInfo( nil, nil, false, false, false, accessMode, "Map",
                             rootTypeInfo, typeIdSeed, TypeInfoKindMap,
                             [@ keyTypeInfo, valTypeInfo ] );
    }

    pub static fn createClass(
        baseInfo: TypeInfo, parentInfo: TypeInfo, externalFlag: bool,
        accessMode: str, className: str ): TypeInfo
    {
        if className == "str" {
            return builtInTypeMap[ className ]@TypeInfo;
        }
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo(
            baseInfo, nil, false, externalFlag, false, accessMode,
            className, parentInfo, typeIdSeed, TypeInfoKindClass );
	return info;
    }

    pub static fn createFunc(
        kind: int, parentInfo: TypeInfo,
        autoFlag: bool, externalFlag: bool, staticFlag: bool, accessMode: str,
	funcName: str, argTypeList: TypeInfo[@], retTypeInfoList: TypeInfo[@] ): TypeInfo
    {
	typeIdSeed = typeIdSeed + 1;
        let info = new TypeInfo(
            nil, nil, autoFlag, externalFlag, staticFlag,
            accessMode, funcName, parentInfo, typeIdSeed,
            kind, argTypeList or [], retTypeInfoList or [] );
        return info;
    }
}

let typeInfoRoot = TypeInfo.createBuiltin( "Root", ":", TypeInfoKindRoot );
let typeInfoNone = TypeInfo.createBuiltin( "None", "", TypeInfoKindPrim );
let typeInfoStem = TypeInfo.createBuiltin( "Stem", "stem" , TypeInfoKindPrim );
let typeInfoNil = TypeInfo.createBuiltin( "Nil", "nil" , TypeInfoKindPrim );
let typeInfoBool = TypeInfo.createBuiltin( "Bool", "bool" , TypeInfoKindPrim );
let typeInfoInt = TypeInfo.createBuiltin( "Int", "int" , TypeInfoKindPrim );
let typeInfoReal = TypeInfo.createBuiltin( "Real", "real" , TypeInfoKindPrim );
let typeInfoChar = TypeInfo.createBuiltin( "char", "char" , TypeInfoKindPrim );
let typeInfoString = TypeInfo.createBuiltin( "String", "str" , TypeInfoKindClass );
let typeInfoMap = TypeInfo.createBuiltin( "Map", "Map" , TypeInfoKindMap );
let typeInfoList = TypeInfo.createBuiltin( "List", "List" , TypeInfoKindList );
let typeInfoArray = TypeInfo.createBuiltin( "Array", "Array" , TypeInfoKindArray );
let typeInfoForm = TypeInfo.createBuiltin( "Form", "form" , TypeInfoKindFunc );
let typeInfoSymbol = TypeInfo.createBuiltin( "Symbol", "sym" , TypeInfoKindPrim );
let typeInfoStat = TypeInfo.createBuiltin( "Stat", "stat" , TypeInfoKindPrim );


pub class Scope {
    pri let parent: Scope { pub };
    pri let symbol2TypeInfoMap: Map<str,TypeInfo> { pub };
    pri let className2ScopeMap: Map<str,Scope> { pub };
    pri let classFlag: bool;
    pri let inheritList: Scope[];
    fn __init( parent: Scope, classFlag: bool, inheritList: Scope[] ) {
	self.parent = parent;
        self.symbol2TypeInfoMap = {};
        self.className2ScopeMap = {};
        self.inheritList = inheritList;
        self.classFlag = classFlag;
    }
    pub fn add( name:str, typeInfo: TypeInfo ) {
	self.symbol2TypeInfoMap[ name ] = typeInfo;
    }
    pub fn addClass( name:str, typeInfo: TypeInfo, scope: Scope ) {
	self.add( name, typeInfo );
        self.className2ScopeMap[ name ] = scope;
    }

    pub fn getClassScope( name: str ) : Scope {
	let scope = self.className2ScopeMap[ name ];
	if not scope and self.parent {
	    scope = self.parent.getClassScope( name );
	}
	return scope;
    }

    pub fn getTypeInfoChild( name: str ) : TypeInfo {
	return self.symbol2TypeInfoMap[ name ];
    }

    pub fn getTypeInfo( name: str ) : TypeInfo {
	let typeInfo = self.symbol2TypeInfoMap[ name ];
	if typeInfo {
	    return typeInfo;
	}
        if self.inheritList {
            foreach scope in self.inheritList {
                typeInfo = scope.getTypeInfo( name );
                if typeInfo {
                    return typeInfo;
                }
            }
        }
	if self.parent {
	    return self.parent.getTypeInfo( name );
	}
	return builtInTypeMap[ name ];
    }

    pub fn getTypeInfoMethod( name: str, includeSelfFlag: bool ) : TypeInfo {
        if self.classFlag {
            let typeInfo: TypeInfo = nil;
            if includeSelfFlag {
	        let typeInfo = self.symbol2TypeInfoMap[ name ];
	        if typeInfo {
	            return typeInfo;
	        }
            }
            if self.inheritList {
                foreach scope in self.inheritList {
                    typeInfo = scope.getTypeInfoMethod( name, true );
                    if typeInfo {
                        return typeInfo;
                    }
                }
            }
        }

        return nil;
    }
}


pub class Filter {
}

pub class NodePos {
    pri let lineNo: int;
    pri let column: int;
}

pub class Node {
    pri let kind: int { pub };
    pri let pos: NodePos;
    pri let expType: TypeInfo { pub };
    pri let expTypeList: TypeInfo[];
    pri let info: stem {pub};
    pub let filter: form;

    pub fn getLiteral(): stem[], TypeInfo[] {
        return nil;
    }
    pub fn processFilter( filter: Filter, ... ) {
    }
}



pub class NamespaceInfo {
    pub let name: str;
    pub let scope: Scope;
    pub let typeInfo: TypeInfo;
}

pub class MacroEval {
    pub fn eval( macroNode: Node ): Map<str,stem>;
}

pub class DeclMacroInfo {
    pri let name: Parser.Token { pub };
    pri let argList: Node[] { pub };
    pri let ast: Node { pub };
    pri let tokenList: Parser.Token[] { pub };
}

class MacroValInfo {
    pub let val: stem;
    pub let typeInfo: TypeInfo;
}

class MacroInfo {
    pub let func: stem;
    pub let declInfo: DeclMacroInfo;
    pub let symbol2MacroValInfoMap: Map<str,MacroValInfo>;
}
pub class TransUnit {

    pri let scope: Scope;
    '' 解析中のクラスを保持する
    pri let namespaceList: NamespaceInfo[];
    pri let classList: NamespaceInfo[];
    pri let typeId2ClassMap: Map<int,NamespaceInfo>;
    
    pri let moduleName2Info: Map<str,stem>;
    pri let parser: Parser.Parser;
    pri let typeId2Scope: Map<int,Scope>;
    pri let typeInfo2ClassNode: Map<TypeInfo,Node>;
    pri let pushbackList: Parser.Token[];
    pri let currentToken: stem;
    pri let currentNamespace: str;
    pri let errMessList: str[] { pub };
    pri let macroEval: MacroEval;
    pri let typeId2MacroInfo: Map<int,MacroInfo>;

    pri let macroMode: str;
    '' macro-expand 内で利用できるシンボルと値の紐付けマップ
    pri let symbol2ValueMapForMacro: Map<str,MacroValInfo>;
    pri let macroScope: Scope;

    fn __init( macroEval: MacroEval ) {
        self.pushbackList = [];
	self.scope = new Scope( nil, false );
        self.namespaceList = [ typeInfoRoot ];
        self.classList = {};
        self.typeId2ClassMap = {};
        self.typeId2Scope = {};
        self.typeInfo2ClassNode = {};
        self.currentToken = nil;
        self.errMessList = {};
        self.macroEval = macroEval;
        self.typeId2MacroInfo = {};
        self.macroMode = "none";
        self.symbol2ValueMapForMacro = {};
    }

    pri fn addErrMess( pos: Parser.Position, mess: str ) {
	table.insert( self.errMessList,
		      "%s:%d:%d: %s" ( self.parser.getStreamName(),
			               pos.lineNo, pos.column, mess ) );
    }


    pri fn pushScope( classFlag: bool, inheritList: Scope ): Scope {
	self.scope = new Scope( self.scope, classFlag, inheritList );
        return self.scope;
    }

    pri fn popScope() {
	self.scope = self.scope.get_parent();
    }

    pri fn pushNamespace( name:str, typeInfo: TypeInfo, scope: Scope ) {
        let namespace = new NamespaceInfo( name, scope, typeInfo );
	table.insert( self.namespaceList, namespace );
    }

    pri fn popNamespace() {
	table.remove( self.namespaceList );
    }

    pri fn getCurrentClass() : TypeInfo {
        if #self.classList == 0 {
            return rootTypeInfo;
        }
        let classInfo = self.classList[ #self.classList ];
        return classInfo.typeInfo;
    }

    pri fn getCurrentNamespaceTypeInfo() : TypeInfo {
        return self.namespaceList[ #self.namespaceList ].typeInfo;
    }

    pri fn pushClass( baseInfo: TypeInfo,
                      externalFlag: bool, name:str, accessMode:str ): TypeInfo
    {
        let typeInfo = self.scope.getTypeInfoChild( name );
	if not typeInfo {
            let parentInfo = self.getCurrentNamespaceTypeInfo();
	    typeInfo = TypeInfo.createClass(
                baseInfo, parentInfo, externalFlag, accessMode, name );
            let inheritList:Scope[] = nil;
            if baseInfo {
                inheritList = [ self.typeId2Scope[ baseInfo.get_typeId() ] ];
            }

	    let scope = self.pushScope( true, inheritList );
	    scope.get_parent().addClass( name, typeInfo, scope );
	}
	else {
	    self.scope = self.scope.getClassScope( name );
	}
        let namespace = new NamespaceInfo( name, self.scope, typeInfo );
	table.insert( self.namespaceList, namespace);
	table.insert( self.classList, namespace );
        self.typeId2ClassMap[ typeInfo.get_typeId() ] = namespace;
	self.typeId2Scope[ typeInfo.get_typeId() ] = self.scope;
	return typeInfo;
    }

    pri fn popClass() {
	self.popScope();
        table.remove( self.namespaceList );
        table.remove( self.classList );
    }
    pri fn addMethod( className: str, methodNode: Node, name: str ) {
        let classTypeInfo = self.scope.getTypeInfo( className );
        let classNodeInfo = self.typeInfo2ClassNode[ classTypeInfo ].info;

        classNodeInfo.outerMethodSet[ name ] = true;
        table.insert( classNodeInfo.fieldList, methodNode );
    }

    pri fn pushbackStr( name: str, statement: str );
    pri fn analyzeDecl( accessMode: str, staticFlag:
	                bool, firstToken: stem, token: stem ): Node;
    pri fn analyzeDeclVar( accessMode: str, staticFlag: bool, firstToken: stem ): Node;
    pri fn analyzeDeclFunc(
        overrideFlag: bool, accessMode: str, staticFlag: bool,
        classNameToken: Parser.Token,
        firstToken: Parser.Token, name: Parser.Token ) : Node;
    pri fn analyzeDeclClass( classAccessMode: str, classToken: stem ): Node;
    pri fn analyzeExp( skipOp2Flag: bool, opLevel: int ): Node;
    pri fn analyzeStatementList( stmtList: stem[], termTxt: str );
    pri fn analyzeStatement( termTxt: str );
    pri fn analyzeExpSymbol( firstToken: stem, token: stem,
	                     mode: str, prefixExp: stem, skipFlag: bool ): Node;
    pri fn analyzeExpList(): Node;


}


let opLevelBase = 0;
let op2levelMap:Map<str,int> = {};
let op1levelMap:Map<str,int> = {};
fn regOpLevel( opnum: int, opList: str[@] ) {
    opLevelBase = opLevelBase + 1;
    if opnum == 1 {
        foreach op in opList {
            op1levelMap[ op ] = opLevelBase;
        }
    }
    else {
        foreach op in opList {
            op2levelMap[ op ] = opLevelBase;
        }
    }
}
regOpLevel( 2, [@ "=" ] );
regOpLevel( 2, [@ "or" ] );
regOpLevel( 2, [@ "and" ] );
regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
regOpLevel( 2, [@ "|" ] );
regOpLevel( 2, [@ "~" ] );
regOpLevel( 2, [@ "&" ] );
regOpLevel( 2, [@ "<<", ">>" ] );
regOpLevel( 2, [@ ".." ] );
regOpLevel( 2, [@ "+", "-" ] );
regOpLevel( 2, [@ "*", "/", "//", "%" ] );
regOpLevel( 1, [@ "`", ",,", ",,,", ",,,," ] );
regOpLevel( 1, [@ "not", "#", "-", "~" ] );
regOpLevel( 1, [@ "^" ] );


let nodeKind2NameMap: Map<int,str> = {};
let nodeKindSeed = 1;
pub let nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
    let kind = nodeKindSeed;
    nodeKindSeed = nodeKindSeed + 1;
    nodeKind2NameMap[ kind ] = name;
    nodeKind[ name ] = kind;
    return kind;
}

pub fn getNodeKindName( kind: int ): str {
    return nodeKind2NameMap[ kind ];
}

pub fn nodeFilter( node: stem, filter: form, ... ) : stem {
    if not filter[ node.kind ] {
	error( string.format( "none filter -- %s %s",
                              node.kind, getNodeKindName( node.kind ) ));
    }
    return filter[ node.kind ]( filter, node, ... );
}

'' let nodeKindNone = regKind( 'None' );
'' let nodeKindImport = regKind( 'Import' );
'' let nodeKindRoot = regKind( 'Root' );
'' let nodeKindRefType = regKind( 'RefType' );
'' let nodeKindIf = regKind( 'If' );
'' let nodeKindSwitch = regKind( 'Switch' );
'' let nodeKindWhile = regKind( 'While' );
'' let nodeKindRepeat = regKind( 'Repeat' );
'' let nodeKindFor = regKind( 'For' );
'' let nodeKindApply = regKind( 'Apply' );
'' let nodeKindForeach = regKind( 'Foreach' );
'' let nodeKindForsort = regKind( 'Forsort' );
'' let nodeKindReturn = regKind( 'Return' );
'' let nodeKindBreak = regKind( 'Break' );
'' let nodeKindExpNew = regKind( 'ExpNew' );
'' let nodeKindExpList = regKind( 'ExpList' );
'' let nodeKindExpRef = regKind( 'ExpRef' );
'' let nodeKindExpOp2 = regKind( 'ExpOp2' );
'' let nodeKindExpCast = regKind( 'ExpCast' );
'' let nodeKindExpOp1 = regKind( 'ExpOp1' );
'' let nodeKindExpRefItem = regKind( 'ExpRefItem' );
'' let nodeKindExpCall = regKind( 'ExpCall' );
'' let nodeKindExpCallSuper = regKind( 'ExpCallSuper' );
'' let nodeKindExpDDD = regKind( 'ExpDDD' );
'' let nodeKindExpParen = regKind( 'ExpParen' );
'' let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); '' macro expand
'' let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); '' `{}
'' let nodeKindBlock = regKind( 'Block' );
'' let nodeKindStmtExp = regKind( 'StmtExp' );
'' let nodeKindRefField = regKind( 'RefField' );
'' let nodeKindDeclVar = regKind( 'DeclVar' );
'' let nodeKindDeclFunc = regKind( 'DeclFunc' );
'' let nodeKindDeclMethod = regKind( 'DeclMethod' );
'' let nodeKindDeclConstr = regKind( 'DeclConstr' );
'' let nodeKindDeclMember = regKind( 'DeclMember' );
'' let nodeKindDeclArg = regKind( 'DeclArg' );
'' let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
'' let nodeKindDeclClass = regKind( 'DeclClass' );
'' let nodeKindDeclMacro = regKind( 'DeclMacro' );
'' let nodeKindLiteralNil = regKind( 'LiteralNil' );
'' let nodeKindLiteralChar = regKind( 'LiteralChar' );
'' let nodeKindLiteralInt = regKind( 'LiteralInt' );
'' let nodeKindLiteralReal = regKind( 'LiteralReal' );
'' let nodeKindLiteralArray = regKind( 'LiteralArray' );
'' let nodeKindLiteralList = regKind( 'LiteralList' );
'' let nodeKindLiteralMap = regKind( 'LiteralMap' );
'' let nodeKindLiteralString = regKind( 'LiteralString' );
'' let nodeKindLiteralBool = regKind( 'LiteralBool' );
'' let nodeKindLiteralSymbol = regKind( 'LiteralSymbol' );

macro _declNodeClass(
    baseName:str, super:sym, fieldInfoList:Map<str,str>[] )
{
    {
        let _className = ,,,"%sNode" (baseName);
        let _nodeKindSym = ,,,"nodeKind%s" (baseName);

        let fieldStatList:stat[] = [];
        let argList:stat[] = [];
        let initStatList:stat[] = [];
        let relateStat:stat[] = [];
        
        if fieldInfoList {
            foreach fieldInfo in fieldInfoList {
                foreach typeName, varName in fieldInfo {
                    table.insert( fieldStatList, `{
                        pri let ,,,varName : ,,,typeName { pub };
                    });
                    table.insert( argList, `{ ,,,varName: ,,,typeName, } );
                    table.insert( initStatList, `{ self.,,,varName = ,,,varName; } );
                }
            }
        }

        table.insert( fieldStatList, `{
            pub override fn processFilter( filter: Filter, ... ) {
                let argList:stem[] = [ ... ];

                filter.,,,"process%s" (baseName) (self, table.unpack( argList ) );
            } } );

        
        let superStat = `{
            super( ,,_nodeKindSym, pos,
                   typeInfoList[1], typeInfoList, self, nodeFilter );
        };

        table.insert( relateStat, `{
            pub fn Filter. ,,,"process%s" (baseName) ( node: ,,_className, ... ) {
            };               
        } );
        
    }

    pub proto class ,,_className extend ,,super;
    ,,relateStat;
    let ,,_nodeKindSym = regKind( ,,baseName );
    pub class ,,_className extend ,,super {
        ,,fieldStatList;
        pub fn __init( pos: Parser.Position, typeInfoList: TypeInfo[], ,,argList ) {
            ,,superStat;
            ,,initStatList;
        }
    }
}

_declNodeClass( "None", Node);
_declNodeClass( "Import", Node,
                [ { "modulePath": "str" } ]
);

_declNodeClass( "Root", Node,
                [ { "children": "Node[]" },
                  { "typeId2ClassMap": "Map<int,NamespaceInfo>" } ]
);

_declNodeClass( "RefType", Node,
                [ { "name": "Parser.Token" },
                  { "refFlag": "bool" },
                  { "mutFlag": "bool" },
                  { "array": "str" } ]
);

_declNodeClass( "Block", Node,
                [ { "blockKind": "str" },
                  { "stmtList": "Node[]" } ]
);

pub class IfStmtInfo {
    pri let kind: str { pub };
    pri let exp: Node { pub };
    pri let block: BlockNode { pub };
}
_declNodeClass( "If", Node,
                [{ "stmtList": "IfStmtInfo[]" } ]
);

_declNodeClass( "ExpList", Node,
                [ { "expList": "Node[]" } ]
);

pub class CaseInfo {
    pri let expList: ExpListNode { pub };
    pri let block: BlockNode { pub };
}
_declNodeClass( "Switch", Node,
                [ { "exp": "Node" },
                  { "caseList": "CaseInfo[]" },
                  { "default": "BlockNode" } ]
);


_declNodeClass( "While", Node,
                [ { "exp": "Node" },
                  { "block": "BlockNode" } ]
);

_declNodeClass( "Repeat", Node,
                [ { "block": "BlockNode" },
                  { "exp": "Node" } ]
);

_declNodeClass( "For", Node,
                [ { "block": "BlockNode" },
                  { "val": "Parser.Token" },
                  { "init": "Node" },
                  { "to": "Node" },
                  { "delta": "Node" }] 
);

_declNodeClass( "Apply", Node,
                [ { "varList": "Parser.Token[]" },
                  { "exp": "Node" },
                  { "block": "BlockNode" } ]
);

_declNodeClass( "Foreach", Node,
                [ { "val": "Parser.Token" },
                  { "key": "Parser.Token" },
                  { "exp": "Node" },
                  { "block": "BlockNode" } ]
);

_declNodeClass( "Forsort", Node,
                [ { "val": "Parser.Token" },
                  { "key": "Parser.Token" },
                  { "exp": "Node" },
                  { "block": "BlockNode" },
                  { "sort": "bool" } ]
);

_declNodeClass( "Return", Node,
                [ { "expList": "ExpListNode" } ]
);

''let nodeKindBreak = regKind( 'Break' );
_declNodeClass( "Break", Node );        

_declNodeClass( "ExpNew", Node,
                [ { "symbol": "Node" },
                  { "argList": "ExpListNode" } ]
);

_declNodeClass( "ExpRef", Node,
                 [ { "token": "Parser.Token" } ]
);

_declNodeClass( "ExpOp2", Node,
                [ { "op": "Parser.Token" },
                  { "exp1": "Node" },
                  { "exp2": "Node" } ]
);

_declNodeClass( "ExpCast", Node,
                [ { "exp": "Node" } ]
);

_declNodeClass( "ExpOp1", Node,
                [ { "op": "Parser.Token" },
                  { "exp": "Node" } ]
);

_declNodeClass( "ExpRefItem", Node,
                [ { "val": "Node" },
                  { "index": "Node" } ]
);

_declNodeClass( "ExpCall", Node,
                [ { "func": "Node" },
                  { "argList": "ExpListNode" } ]
);

_declNodeClass( "ExpDDD", Node,
                [ { "token": "Parser.Token" } ]
);

_declNodeClass( "ExpParen", Node,
                 [ { "exp": "Node" } ]
);

_declNodeClass( "ExpMacroExp", Node,
                [ { "stmtList": "Node[]" } ]
);

_declNodeClass( "ExpMacroStat", Node,
                [ { "expStrList": "Node[]" } ]
);

_declNodeClass( "StmtExp", Node,
                [ { "exp": "Node" } ]
);

_declNodeClass( "RefField", Node,
                [ { "field": "Parser.Token" },
                  { "prefix": "Node" }] 
);

pub class VarInfo {
    pri let name: Parser.Token { pub };
    pri let refType: TypeInfo { pub };
}
_declNodeClass( "DeclVar", Node,
                [ { "accessMode": "str" },
                  { "varList": "VarInfo[]" },
                  { "expList": "ExpListNode" },
                  { "typeInfoList": "TypeInfo[]" },
                  { "unwrap": "BlockNode" } ]
);

pub class DeclFuncInfo {
    pri let className: Parser.Token { pub };
    pri let name: Parser.Token { pub };
    pri let argList: Node[] { pub };
    pri let staticFlag: bool { pub };
    pri let accessMode: str { pub };
    pri let body: Node { pub };
    pri let retTypeList: TypeInfo[] { pub };
    pri let retTypeInfoList: TypeInfo[] { pub };
}
_declNodeClass( "DeclFunc", Node,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclMethod", Node,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclConstr", Node,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "ExpCallSuper", Node,
                [ { "superType": "TypeInfo" },
                  { "expList": "ExpListNode" } ]
);

_declNodeClass( "DeclMember", Node,
                [ { "name": "Parser.Token" },
                  { "refType": "RefTypeNode" },
                  { "staticFlag": "bool" },
                  { "accessMode": "str" },
                  { "getterMode": "str" },
                  { "setterMode": "str" } ]
);

_declNodeClass( "DeclArg", Node,
                [ { "name": "Parser.Token" },
                  { "argType": "RefTypeNode" } ]
);

'' let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
_declNodeClass( "DeclArgDDD", Node );

_declNodeClass( "DeclClass", Node,
                [ { "accessMode": "str" },
                  { "name": "Parser.Token" },
                  { "fieldList": "Node[]" },
                  { "memberList": "DeclMemberNode[]" },
                  { "scope": "Scope" },
                  { "outerMethodSet": "Map<str,bool>" } ]
);

_declNodeClass( "DeclMacro", Node,
                [ { "declInfo": "DeclMacroInfo" } ]
);

'' let nodeKindLiteralNil = regKind( 'LiteralNil' );
_declNodeClass( "LiteralNil", Node );

_declNodeClass( "LiteralChar", Node,
                [ { "token": "Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralInt", Node,
                [ { "token": "Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralReal", Node,
                [ { "token": "Parser.Token" },
                  { "num": "real" } ]
);

_declNodeClass( "LiteralArray", Node,
                [ { "expList": "ExpListNode" } ]
);

_declNodeClass( "LiteralList", Node,
                [ { "expList": "ExpListNode" } ]
);

pub class PairItem {
    pri let key: Node { pub };
    pri let val: Node { pub };
}
_declNodeClass( "LiteralMap", Node,
                [ { "map": "Map<Node,Node>" },
                  { "pairList": "PairItem[]" } ]
);

_declNodeClass( "LiteralString", Node,
                [ { "token": "Parser.Token" },
                  { "argList": "Node[]" } ]
);

_declNodeClass( "LiteralBool", Node,
                [ { "token": "Parser.Token" } ]
);

_declNodeClass( "LiteralSymbol", Node,
                [ { "token": "Parser.Token" } ]
);



pub override fn LiteralNilNode.getLiteral(): stem[], TypeInfo[] {
    return [nil], [typeInfoNil];
}
pub override fn LiteralCharNode.getLiteral(): stem[], TypeInfo[] {
    return [self.num], [typeInfoChar];
}
pub override fn LiteralIntNode.getLiteral(): stem[], TypeInfo[] {
    return [self.num], [typeInfoInt];
}
pub override fn LiteralRealNode.getLiteral(): stem[], TypeInfo[] {
    return [self.num], [typeInfoReal];
}
pub override fn LiteralArrayNode.getLiteral(): stem[], TypeInfo[] {
    let array:stem[] = [];
    foreach val in self.expList.get_expList() {
        let txt = val.getLiteral()[1];
        table.insert( array, txt );
    }
    return [array], [self.get_expType()];
}
pub override fn LiteralListNode.getLiteral(): stem[], TypeInfo[] {
    let list:stem[] = [];
    foreach val in self.expList.get_expList() {
        let item = val.getLiteral()[1];
        table.insert( list, item );
    }
    return [list], [self.get_expType()];
}
pub override fn LiteralMapNode.getLiteral(): stem[], TypeInfo[] {
    let map:Map<str,stem> = {};
    foreach val, key in self.map {
        map[ key.getLiteral()[1] ] = val.getLiteral()[1];
    }
    return [map], [self.get_expType()];
}
pub override fn LiteralStringNode.getLiteral(): stem[], TypeInfo[] {
    let txt = self.token.txt;
    if string.find( txt, '^```' ) {
        txt = txt.sub( 4, -4 );
    }
    else {
        txt = txt.sub( 2, -2 );
    }
    let argList = self.get_argList();
    if argList and #argList > 0 {
        let argTbl = [];
        let argValList = argList.getLiteral()@stem[];
        foreach arg in argValList {
            table.insert( argTbl, arg );
        }
        return string.format( txt, table.unpack( argTbl ) ), typeInfoString;
    }
    return [txt], [typeInfoString];
}
pub override fn LiteralBoolNode.getLiteral(): stem[], TypeInfo[] {
    return [ self.token.txt == "true"], [typeInfoBool];
}
pub override fn LiteralSymbolNode.getLiteral(): stem[], TypeInfo[] {
    return [[ self.token.txt ]], [ typeInfoSymbol ];
}
pub override fn RefFieldNode.getLiteral(): stem[], TypeInfo[] {
    let prefix = self.prefix.getLiteral()[1];
    table.insert( prefix, "." );
    table.insert( prefix, self.field.txt );
    return [ prefix ], [ self.get_expType() ];
}
pub override fn ExpMacroStatNode.getLiteral(): stem[], TypeInfo[] {
    let txt = "";
    foreach token in self.expStrList {
        txt = "%s %s" (txt, token.getLiteral()[1]);
    }
    return [txt ], [ self.get_expType() ];
}


let quotedChar2Code = {};
quotedChar2Code[ 'a' ] = 7;    '' \a
quotedChar2Code[ 'b' ] = 8;    '' \b
quotedChar2Code[ 't' ] = 9;    '' \t
quotedChar2Code[ 'n' ] = 10;   '' \t
quotedChar2Code[ 'v' ] = 11;   '' \v
quotedChar2Code[ 'f' ] = 12;   '' \f
quotedChar2Code[ 'r' ] = 13;   '' \r
quotedChar2Code[ '\\' ] = ?\\; '' \\
quotedChar2Code[ '"' ] = ?\";  '' "
quotedChar2Code[ "'" ] = ?\';  '' '


fn TransUnit.registBuiltInScope() {
    let builtInInfo: Map<str,Map<str,Map<str,str[]>>> = {
	"": {
            "type": { "ret": ["str"] },
            "error": { "ret": [] },
            "print": { "ret": [] },
            "tonumber": { "ret": ["int"] },
            "load": { "ret": ["stem", "str"] },
            "require": { "ret": ["stem"] },
            "_fcall": { "ret": ["stem"] },
        },
	"io": {
            "open": { "ret": ["stem"] },
        },
	"os": {
            "clock": { "ret": ["int"] },
        },
	"string": {
            "find": { "ret": ["int", "int"] },
            "byte": { "ret": ["int"] },
            "format": { "ret": ["str"] },
            "rep": { "ret": ["str"] },
            "gmatch": { "ret": ["stem"] },
            "gsub": { "ret": ["str"] },
            "sub": { "ret": ["str"] },
        },
	"str": {
            "find": { "methodFlag": [], "ret": ["int", "int"] },
            "byte": { "methodFlag": [], "ret": ["int"] },
            "format": { "methodFlag": [], "ret": ["str"] },
            "rep": { "methodFlag": [], "ret": ["str"] },
            "gmatch": { "methodFlag": [], "ret": ["stem"] },
            "gsub": { "methodFlag": [], "ret": ["str"] },
            "sub": { "methodFlag": [], "ret": ["str"] },
        },
	"table": {
            "insert": { "ret": [""] },
            "remove": { "ret": [""] },
            "unpack": { "ret": ["stem"] },
        },
	"debug": {
            "getinfo": { "ret": ["stem"] },
        },
	"_luneScript": {
            "loadModule": { "ret": ["stem"] },
        },
    };


    forsort typeInfo, name in builtInTypeMap {
        if typeInfo.kind == TypeInfoKindClass {
	    let scope = self.pushScope( true );
	    scope.get_parent().addClass( name, typeInfo, scope );
            self.popScope();
        }
        else {
	    self.scope.add( name, typeInfo );
        }
    }

    forsort name2FuncInfo, name in builtInInfo {
        let parentInfo = typeInfoRoot;
	if name ~= "" {
	    let classTypeInfo = self.pushClass( nil, true, name, "pri" );
            parentInfo = classTypeInfo;
            builtInTypeIdSet[ classTypeInfo.get_typeId() ] = true;
	}
        if not parentInfo {
            error( "parentInfo is nil" );
        }
	forsort info, funcName in name2FuncInfo {
            let retTypeList: TypeInfo[] = {};
            foreach retType in info[ "ret" ] {
                table.insert( retTypeList, builtInTypeMap[ retType ] );
            }

            let methodFlag = info[ "methodFlag" ];

            let typeInfo = TypeInfo.createFunc(
                methodFlag and TypeInfoKindMethod or TypeInfoKindFunc, parentInfo,
                false, true, not methodFlag, "pub", funcName, nil, retTypeList );
            builtInTypeIdSet[ typeInfo.get_typeId() ] = true;
	    self.scope.add( funcName, typeInfo );
	}
	if name ~= "" {
	    self.popClass();
	}
    }
}


fn TransUnit.createNode( kind: int, pos: stem, expTypeList: TypeInfo[], info: Map ): Map {
    if not getNodeKindName( kind ) {
	error( string.format( "%d:%d: not found nodeKind", pos.lineNo, pos.column ) );
    }
    return new Node( kind, pos, expTypeList[1], expTypeList, info, nodeFilter );
}

fn TransUnit.error( mess: str ) {
    let pos = { "lineNo": 0, "column": 0 };
    let txt = "";
    if self.currentToken {
	pos = self.currentToken.pos;
        txt = self.currentToken.txt;
    }
    error( string.format( "%s:%d:%d:(%s) %s",
                          self.parser.getStreamName(),
                          pos.lineNo, pos.column, txt, mess ) );
}

fn TransUnit.createNoneNode( pos: Parser.Position ): Node {
    ''return self.createNode( nodeKindNone, pos, [ typeInfoNone ], {} );
    return new NoneNode( pos, [ typeInfoNone ] );
}

fn TransUnit.pushbackToken( token: Parser.Token ) {
    table.insert( self.pushbackList, token );
    self.currentToken = nil;
}

fn expandVal( tokenList:Parser.Token[], val: stem, pos: Parser.Position ): str {
    switch type( val ) {
        case "number" {
            let num = "%g" (val);
            let kind = Parser.kind.Int;
            if string.find( num, ".", 1, true ) {
                kind = Parser.kind.Real;
            }
            table.insert( tokenList, new Parser.Token( kind, num, pos ) );
        }
        case "string" {
            table.insert(
                tokenList,  new Parser.Token( Parser.kind.Str, "[[%s]]" (val), pos ) );
        }
        case "table" {
            table.insert(
                tokenList, new Parser.Token( Parser.kind.Dlmt, "{" (val), pos ) );
            foreach item, key in val@stem[] {
                expandVal( tokenList, item, pos );
                table.insert(
                    tokenList, new Parser.Token( Parser.kind.Dlmt, "," (val), pos ) );
            }
            table.insert(
                tokenList, new Parser.Token( Parser.kind.Dlmt, "}" (val), pos ) );
        }
    }
}

fn TransUnit.newPushback( tokenList: Parser.Token[] ) {
    for index = #tokenList, 1, -1  {
        table.insert( self.pushbackList, tokenList[ index ] );
    }
    self.currentToken = nil;
}

fn TransUnit.getTokenNoErr(): stem {
    if #self.pushbackList > 0 {
	self.currentToken = self.pushbackList[ #self.pushbackList ];
        table.remove( self.pushbackList );
        return self.currentToken;
    }

    let commentList = {};
    let token = nil;
    while true {
	token = self.parser.getToken();
        if not token {
	    break;
        }
        if token.kind ~= Parser.kind.Cmnt {
	    break;
        }
        table.insert( commentList, token );
    }

    if token {
	token.commentList = commentList;
        if self.macroMode == "expand" and token.txt == ',,' {
            token = self.getTokenNoErr();

            let macroVal = self.symbol2ValueMapForMacro[ token.txt ];
            if macroVal {
                ''Util.errorLog( "token: %s" ( token.txt ) );
                if macroVal.typeInfo == typeInfoSymbol {
                    let txtList = macroVal.val;
                    for index = #txtList, 1, -1 {
                        token = new Parser.Token(
                            token.kind, txtList[ index ], token.pos );
                        self.pushbackToken( token );
                    }   
                }   
                elseif macroVal.typeInfo == typeInfoStat {
                    self.pushbackStr( "macroVal %s" (token.txt), macroVal.val );
                }   
                elseif macroVal.typeInfo.get_kind() == TypeInfoKindArray or
                    macroVal.typeInfo.get_kind() == TypeInfoKindList
                {   
                    let strList = macroVal.val@str[];
                    if strList {
                        for index = #strList, 1, -1 {
                            self.pushbackStr(
                                "macroVal %s[%d]" (token.txt, index),
                                strList[ index ] );
                        }   
                    }   
                    else {
                        self.error( "macro val is nil %s" (token.txt) );
                    }   
                }
                else {
                    let tokenList: Parser.Token[] = [];
                    expandVal( tokenList, macroVal.val, token.pos );
                    
                    self.newPushback( tokenList );
                }
                token = self.getTokenNoErr();
            }   
            else {
                self.error( "unknown macro val %s" (token.txt) );
            }   
        }   
    }

    
    self.currentToken = token;

    return token;
}



fn TransUnit.getToken( mess: str ): Parser.Token {
    let token = self.getTokenNoErr();
    if not token {
	return Parser.getEofToken();
    }

    '' if self.macroMode == "expand"  {
    ''     Util.errorLog( "getToken %s" (token.txt) );
    '' }
    

    self.currentToken = token;
    return self.currentToken;
}

fn TransUnit.pushback() {
    table.insert( self.pushbackList, self.currentToken );
    self.currentToken = nil;
}

fn TransUnit.pushbackStr( name: str, statement: str ) {
    let memStream = new Parser.TxtStream( statement );
    let parer = new Parser.StreamParser( memStream, name, false );

    let list:Parser.Token[] = [];
    while true {
        let token = parer.getToken();
        if not token {
            break;
        }
        table.insert( list, token ); 
    }
    for index = #list, 1, -1  {
        self.pushbackToken( list[ index ] );
    }
}

fn TransUnit.checkSymbol( token: stem ): stem {
    if token.kind ~= Parser.kind.Symb and
	token.kind ~= Parser.kind.Kywd and
	token.kind ~= Parser.kind.Type
    {
	self.error( "illegal symbol" );
    }
    return token;
}

fn TransUnit.getSymbolToken(): Parser.Token {
    return self.checkSymbol( self.getToken() );
}


fn TransUnit.checkToken( token: stem, txt: str ): stem {
    if not token or token.txt ~= txt {
	self.error( string.format( "not found -- %s", txt ) );
    }
    return token;
}

fn TransUnit.checkNextToken( txt: str ): stem {
    return self.checkToken( self.getToken(), txt );
}


fn TransUnit.analyzeBlock( blockKind: str, scope: Scope ): stem {
    let token = self.checkNextToken( "{" );

    if not scope {
	self.pushScope( false );
    }

    let stmtList:Node[] = [];
    self.analyzeStatementList( stmtList, "}" );

    self.checkNextToken( "}" );

    if not scope {
	self.popScope();
    }

    '' let node = self.createNode( nodeKindBlock, token.pos, [ typeInfoNone ],
    ''     			{ "kind": blockKind, "stmtList": stmtList } );
    let node = new BlockNode(
        token.pos, [ typeInfoNone ], blockKind, stmtList );

    return node;
}

class _TypeInfo {
    pub let baseId: int;
    pub let itemTypeId: int[];
    pub let retTypeId: int[];
    pub let parentId: int;
    pub let typeId: int;
    pub let txt: str;
    pub let kind: int;
    pub let staticFlag: bool;
    pub let nilable: bool;
    pub let orgTypeId: int;
    pub let children: int[];
}
class _ModuleInfo {
    pub let _className2InfoMap: Map<str,Map<str,stem>>;
    pub let _typeInfoList: _TypeInfo[];
    pub let _varName2InfoMap: Map<str,stem>;
    pub let _funcName2InfoMap: Map<str,stem>;
}

fn TransUnit.analyzeImport( token: stem ): Node {
    let moduleToken = self.getToken();
    let modulePath = moduleToken.txt;
    let nextToken = {};

    let nameList = [ moduleToken.txt ];

    while true {
	nextToken = self.getToken();
        if nextToken.txt == "." {
	    nextToken = self.getToken();
            moduleToken = nextToken;
            modulePath = "%s.%s" ( modulePath, moduleToken.txt );
            table.insert( nameList, moduleToken.txt );
        }
        else {
	    break;
        }
    }


    '' 型情報の登録
    let typeId2TypeInfo: Map<int,TypeInfo> = {};
    typeId2TypeInfo[ rootTypeId ] = typeInfoRoot;

    let typeInfo2Scope: Map<TypeInfo,Scope> = {};

    '' let moduleTypeInfo = self.pushClass( nil, true, moduleToken.txt, "pub" );
    let moduleTypeInfo: TypeInfo = nil;
    foreach moduleName in nameList {
        moduleTypeInfo = self.pushClass( nil, true, moduleName, "pub" );
        typeInfo2Scope[ moduleTypeInfo ] = self.scope;
    }
    foreach moduleName in nameList {
    	self.popClass();
    }


    let moduleInfo: _ModuleInfo = _luneScript.loadModule( modulePath );
    self.moduleName2Info[ modulePath ] = moduleInfo;

    foreach typeInfo in builtInTypeMap@Map<str,TypeInfo> {
        typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
    }

    let typeId2Scope: Map<int,Scope> = {};
    typeId2Scope[ rootTypeId ] = self.scope;

    fn registTypeInfo( atomInfo: _TypeInfo ): TypeInfo {
        let newTypeInfo: TypeInfo = nil;
        if not builtInTypeIdSet[ atomInfo.typeId ] {

	    if atomInfo.nilable {
		let orgTypeInfo = typeId2TypeInfo[ atomInfo.orgTypeId ];
                newTypeInfo = orgTypeInfo.get_nilableTypeInfo();
                typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
	    }
	    else {
		let itemTypeInfo = {};
		foreach typeId in atomInfo.itemTypeId {
	            table.insert( itemTypeInfo, typeId2TypeInfo[ typeId ] );
		}
		let retTypeInfo = {};
		foreach typeId in atomInfo.retTypeId {
	            table.insert( retTypeInfo, typeId2TypeInfo[ typeId ] );
		}
                let parentInfo = moduleTypeInfo;
                if atomInfo.parentId ~= rootTypeId {
                    parentInfo = typeId2TypeInfo[ atomInfo.parentId ];
                    if not parentInfo {
                        error( "not found parentInfo %s %s"
                               ( atomInfo.parentId, atomInfo.txt ) );
                    }
                }
                let baseInfo = typeId2TypeInfo[ atomInfo.baseId ];

                let parentScope = typeId2Scope[ atomInfo.parentId ];
                if not parentScope {
                    error( "not found parentScope %s %s"
                           ( atomInfo.parentId, atomInfo.txt ) );
                }

                if atomInfo.txt ~= "" {
                    newTypeInfo = parentScope.getTypeInfoChild( atomInfo.txt );
                }
                if newTypeInfo and atomInfo.kind == TypeInfoKindClass {
                    typeId2Scope[ atomInfo.typeId ] = typeInfo2Scope[ newTypeInfo ];
                    if not typeInfo2Scope[ newTypeInfo ] {
                        error( "not found scope %s %s %s %s %s"
                               ( parentScope, atomInfo.parentId,
                                 atomInfo.typeId, atomInfo.txt, newTypeInfo.getTxt() ) );
                    }
                    typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
                }
                else {
                    if atomInfo.kind == TypeInfoKindClass {
                        let baseScope = typeId2Scope[ atomInfo.baseId ];

                        scope = new Scope(
                            parentScope, true, baseScope and [ baseScope ] or nil );

                        newTypeInfo = TypeInfo.createClass(
                            baseInfo, parentInfo, true, "pub", atomInfo.txt );
                        typeId2Scope[ atomInfo.typeId ] = scope;


		        typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;

	                parentScope.addClass( atomInfo.txt, newTypeInfo, scope );

                    }
                    else {
                        newTypeInfo = TypeInfo.create(
                            baseInfo, parentInfo, atomInfo.staticFlag, atomInfo.kind,
                            atomInfo.txt, itemTypeInfo, retTypeInfo );

		        typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;

                        if atomInfo.kind == TypeInfoKindFunc or
                            atomInfo.kind == TypeInfoKindMethod
                        {
                            typeId2Scope[ atomInfo.parentId ].add(
                                atomInfo.txt, newTypeInfo );

                            let scope = new Scope( parentScope, false );

                            typeId2Scope[ atomInfo.typeId ] = scope;
                        }
                    }
                }
	    }
        }
        else {
            newTypeInfo = builtInTypeMap[ atomInfo.txt ];
	    typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
        }
        return newTypeInfo;
    }

    '' 初めに child 以外で TypeInfo を登録
    foreach atomInfo in moduleInfo._typeInfoList {
        registTypeInfo( atomInfo );
    }
    '' 次に child を登録
    foreach atomInfo in moduleInfo._typeInfoList {
        if #atomInfo.children > 0 {
            let scope = typeId2Scope[ atomInfo.typeId ];
            foreach childId in atomInfo.children {
                let typeInfo = typeId2TypeInfo[ childId ];
                if typeInfo {
                    scope.add( typeInfo.getTxt(), typeInfo );
                }
            }
        }
    }



    foreach moduleName in nameList {
        self.pushClass( nil, true, moduleName, "pub" );
    }

    '' メンバーの登録
    forsort classInfo, className in moduleInfo._className2InfoMap {
	self.pushClass( nil, true, className, "pub" );
        foreach fieldInfo, fieldName in classInfo {
            let fieldTypeInfo: TypeInfo = nil;
            let typeId = fieldInfo[ "typeId" ];
            fieldTypeInfo = typeId2TypeInfo[ typeId ];
	    self.scope.add( fieldName, fieldTypeInfo );
        }
        self.popClass();
    }

    '' 変数登録
    foreach varInfo, varName in moduleInfo._varName2InfoMap {
	self.scope.add( varName, typeId2TypeInfo[ varInfo[ "typeId" ] ] );
    }

    foreach moduleName in nameList {
    	self.popClass();
    }



    ''self.popClass();


    self.scope.add ( moduleToken.txt, moduleTypeInfo );


    self.checkToken( nextToken, ";" );

    return new ImportNode( token.pos, [ typeInfoNone ], modulePath );
}

fn TransUnit.analyzeIf( token: stem ): stem {
    let list = {};
    table.insert(
	list, { "kind": "if", "exp": self.analyzeExp(),
		"block": self.analyzeBlock( "if" ) } );

    let nextToken = self.getToken();
    if nextToken.txt == "elseif" {
	while nextToken.txt == "elseif" {
	    table.insert(
		list, { "kind": "elseif", "exp": self.analyzeExp(),
			"block": self.analyzeBlock( "elseif" ) } );
	    nextToken = self.getToken();
	}
    }

    if nextToken.txt == "else" {
	table.insert(
	    list, { "kind": "else", "block": self.analyzeBlock( "else" ) } );
    }
    else {
	self.pushback();
    }

    '' return self.createNode(
    ''     nodeKindIf, token.pos, [ typeInfoNone ], list );
    return new IfNode( token.pos, [ typeInfoNone ], list );
}


fn TransUnit.analyzeSwitch( firstToken: stem ): stem {
    let exp = self.analyzeExp();

    self.checkNextToken( "{" );

    let caseList: stem[] = {};

    let nextToken = self.getToken();
    while ( nextToken.txt == "case" ) {
        self.checkToken( nextToken, "case" );
        let condexpList = self.analyzeExpList();
        let condBock = self.analyzeBlock( "switch" );
        table.insert( caseList, { "expList": condexpList, "block": condBock } );
        nextToken = self.getToken();
    }

    let defaultBlock: Node = nil;
    if nextToken.txt == "default" {
        defaultBlock = self.analyzeBlock( "default" );
    }
    else {
	self.pushback();
    }
    self.checkNextToken( "}" );

    '' let info: stem = { "exp": exp, "caseList": caseList, "default": defaultBlock };

    '' return self.createNode(
    ''     nodeKindSwitch, firstToken.pos, [ typeInfoNone ], info );
    return new SwitchNode( firstToken.pos, [ typeInfoNone ],
                           exp, caseList, defaultBlock );
}


fn TransUnit.analyzeWhile( token: stem ): stem {
    '' let info = { "exp": self.analyzeExp(), "block": self.analyzeBlock( "while" ) };
    '' return self.createNode(
    ''     nodeKindWhile, token.pos, [ typeInfoNone ], info );
    return new WhileNode( token.pos, [ typeInfoNone ],
                          self.analyzeExp(), self.analyzeBlock( "while" ) );
}

fn TransUnit.analyzeRepeat( token: stem ): stem {
    let scope = self.pushScope( false );
    '' let info = { "block": self.analyzeBlock( "repeat", scope ),
    ''              "exp": self.analyzeExp() };
    '' let node = self.createNode(
    ''     nodeKindRepeat, token.pos, [ typeInfoNone ], info );
    let node = new RepeatNode( token.pos, [ typeInfoNone ],
                               self.analyzeBlock( "repeat", scope ),
                               self.analyzeExp() );
    self.popScope();
    
    self.checkNextToken( ";" );
    return node;
}

fn TransUnit.analyzeFor( token: stem ): stem {

    let scope = self.pushScope( false );

    let val = self.getToken();
    if val.kind ~= Parser.kind.Symb {
	self.error( "not symbol" );
    }
    self.checkNextToken( "=" );
    let exp1 = self.analyzeExp();
    self.scope.add( val.txt, exp1.expType );
    self.checkNextToken( "," );
    let exp2 = self.analyzeExp();
    let token = self.getToken();
    let exp3 = nil;
    if token.txt == "," {
	exp3 = self.analyzeExp();
    }
    else {
	self.pushback();
    }

    '' let info = { "block": self.analyzeBlock( "for", scope ), "val": val,
    ''              "init": exp1, "to": exp2, "delta": exp3 };
    '' let node = self.createNode( nodeKindFor, token.pos, [ typeInfoNone ], info );
    let node = new ForNode(
        token.pos, [ typeInfoNone ],
        self.analyzeBlock( "for", scope ), val, exp1, exp2, exp3 );
    self.popScope();
                            
    return node;
}

fn TransUnit.analyzeApply( token: stem ): stem {
    let scope = self.pushScope();
    let varList = {};
    let nextToken = nil;
    repeat {
	let var = self.getSymbolToken();
	if var.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	table.insert( varList, var );
	nextToken = self.getToken();
        scope.add( var.txt, typeInfoStem );
    } nextToken.txt ~= ",";
    self.checkToken( nextToken, "of" );

    let exp = self.analyzeExp();
    if exp.kind ~= nodeKindExpCall {
	self.error( "not call" );
    }

    let block = self.analyzeBlock( "apply", scope );
    self.popScope();

    '' let info = { "varList": varList, "exp": exp, "block": block };
    '' return self.createNode( nodeKindApply, token.pos, [ typeInfoNone ], info );
    return new ApplyNode( token.pos, [ typeInfoNone ], varList, exp, block );
}

fn TransUnit.analyzeForeach( token: stem, sortFlag: bool ): stem {
    let scope = self.pushScope();
    let valSymbol = nil;
    let keySymbol = nil;
    let nextToken = nil;
    for index = 1, 2 {
	let sym = self.getToken();
	if sym.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	if index == 1 {
	    valSymbol = sym;
	}
	else {
	    keySymbol = sym;
	}
	nextToken = self.getToken();
	if nextToken.txt ~= "," {
	    break;
	}
    }
    self.checkToken( nextToken, "in" );

    let exp = self.analyzeExp();
    if not exp.expType {
	self.error( "unknown type of exp -- %d:%d" (token.pos.lineNo, token.pos.column) );
    }
    else {
	let itemTypeInfoList = exp.expType.get_itemTypeInfoList();
	if exp.expType.get_kind() == TypeInfoKindMap {
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 2 ] );
	    if keySymbol {
	        self.scope.add( keySymbol.txt, itemTypeInfoList[ 1 ] );
	    }
        }
	elseif exp.expType.get_kind() == TypeInfoKindList or
	    exp.expType.get_kind() == TypeInfoKindArray
	{
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 1 ] );
	    if keySymbol {
	        self.scope.add( keySymbol.txt, typeInfoInt );
	    }
	    else {
	        self.scope.add( "__index", typeInfoInt );
	    }
        }
        else {
            self.error( "unknown kind type of exp for foreach-- %d:%d" (exp.pos.lineNo,
                                                                         exp.pos.column) );
        }
    }


    let block = self.analyzeBlock( "foreach", scope );

    self.popScope();

    '' let info = { "val": valSymbol, "key": keySymbol,
    ''              "exp": exp, "block": block, "sort": sortFlag };
    '' return self.createNode( sortFlag and nodeKindForsort or nodeKindForeach,
    ''                         token.pos, [ typeInfoNone ], info );

    if sortFlag {
        return new ForsortNode( token.pos, [ typeInfoNone ],
                                valSymbol, keySymbol, exp, block, sortFlag );
    }
    else {
        return new ForeachNode( token.pos, [ typeInfoNone ],
                                valSymbol, keySymbol, exp, block, sortFlag );
    }

}

fn TransUnit.analyzeRefType( accessMode: str ): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let refFlag = false;
    if token.txt == "&" {
	refFlag = true;
        token = self.getToken();
    }
    let mutFlag = false;
    if token.txt == "mut" {
	mutFlag = true;
        token = self.getToken();
    }
    let name: Node = nil;
    let typeInfo = typeInfoStem;
    token = self.checkSymbol( token );
    if token {
	name = self.analyzeExpSymbol( firstToken, token, "symbol", token, true );
        typeInfo = name.expType;
    }
    else {
	self.pushback();
    }

    token = self.getToken();
    if token.txt == "!" {
	typeInfo = typeInfo.get_nilableTypeInfo();
        token = self.getToken();
    }
    let arrayMode = "no";
    while true {
        if token.txt == '[' or token.txt == '[@' {
	    if token.txt == '[' {
	        arrayMode = "list";
	        typeInfo = TypeInfo.createList(
                    accessMode, self.getCurrentClass(), [ typeInfo ] );
	    }   
	    else {
	        arrayMode = "array";
	        typeInfo = TypeInfo.createArray(
                    accessMode, self.getCurrentClass(), [ typeInfo ] );
	    }   
	    token = self.getToken();
	    if token.txt ~= ']' {
	        self.pushback();
	        self.checkNextToken( ']' );
	    }   
        }   
        elseif token.txt == "<" {
	    let genericList: Node[] = {};
	    let nextToken: stem = nil;
	    repeat {
	        let typeExp = self.analyzeRefType( accessMode );

	        table.insert( genericList, typeExp.expType );
	        nextToken = self.getToken();
	    } nextToken.txt ~= ",";
	    self.checkToken( nextToken, '>' );
	    if typeInfo.kind == TypeInfoKindMap {
	        typeInfo = TypeInfo.createMap(
                    accessMode, self.getCurrentClass(),
                    genericList[1] or typeInfoStem,
                    genericList[2] or typeInfoStem );
	    }   
	    else {
	        self.error( string.format( "not support generic: %s",
                                           typeInfo.getTxt() ) );
	    }   
        }   
        else {
	    self.pushback();
            break;
        }
        token = self.getToken();
    }


    '' return self.createNode(
    ''     nodeKindRefType, firstToken.pos, [ typeInfo ],
    ''     { "name": name, "refFlag": refFlag,
    ''       "mutFlag": mutFlag, "array": arrayMode } );
    return new RefTypeNode( firstToken.pos, [ typeInfo ],
                            name, refFlag, mutFlag, arrayMode );
}

fn TransUnit.analyzeDeclArgList( accessMode:str, argList: Node[] ) : Parser.Token {
    let token: Parser.Token = Parser.noneToken;
    repeat {
	let argName = self.getToken();
	if argName.txt == ")" {
	    token = argName;
	    break;
	}
	elseif argName.txt == "..." {
	    table.insert(
		argList,
		'' self.createNode(
		''     nodeKindDeclArgDDD, argName.pos, [ typeInfoNone ], argName ) );
                new DeclArgDDDNode( argName.pos, [ typeInfoNone ] ) );
	}
	else {
	    argName = self.checkSymbol( argName );

	    self.checkNextToken( ":" );
	    let refType = self.analyzeRefType( accessMode );
	    '' let arg = self.createNode(
            ''     nodeKindDeclArg, argName.pos, refType.expTypeList ,
	    ''     { "name": argName, "argType": refType } );
            let arg = new DeclArgNode( argName.pos, refType.expTypeList,
	                               argName, refType );    
            
	    self.scope.add( argName.txt, refType.expType );
	    table.insert( argList, arg );
        }
	token = self.getToken();
    } token.txt ~= ",";

    self.checkToken( token, ")" );

    return token;
}

pub class ASTInfo {
    pri let node: Node { pub };
    pri let moduleTypeInfo: TypeInfo { pub };
}

pub fn TransUnit.createAST( parser: str, macroFlag: bool, module: str ): ASTInfo {

    self.pushNamespace( "", typeInfoRoot, self.scope );

    let rootScope = self.scope;

    self.registBuiltInScope();

    let moduleTypeInfo = rootTypeInfo;

    if module {
        apply txt of string.gmatch( module, '[^%.]+' ) {
            moduleTypeInfo = self.pushClass( nil, false, txt, "pub" );
        }
    }
    self.parser = parser;
    self.moduleName2Info = {};

    let ast:Node = nil;

    if macroFlag {
        ast = self.analyzeBlock( "macro" );
    }
    else {
        let rootInfo = {};
        rootInfo.children = {};
        '' ast = self.createNode(
	''     nodeKindRoot, { "lineNo": 0, "column": 0 }, [ typeInfoNone ], rootInfo );
        ast = new RootNode( new Parser.Position( 0, 0 ), [ typeInfoNone ],
                            rootInfo.children, self.typeId2ClassMap );
        self.analyzeStatementList( rootInfo.children );

        let token = self.getTokenNoErr();
        if token {
	    error( "unknown:%d:%d:(%s) %s"
	           ( token.pos.lineNo, token.pos.column,
		     Parser.getKindTxt( token.kind ), token.txt ) );
        }
    }

    if module {
        apply txt of string.gmatch( module, '[^%.]+' ) {
            self.popClass();
        }
    }

    ''    if #self.errMessList > 0 {
    ''      foreach mess in self.errMessList {
    ''          errorLog( "error:" .. mess );
    ''      }
    ''      error( "has error" );
    ''    }


    self.popNamespace();

    return new ASTInfo( ast, moduleTypeInfo );
}


fn TransUnit.analyzeDeclMacro( accessMode: str, firstToken: Parser.Token ) : Node
{
    let nameToken = self.getToken();
    self.checkNextToken( "(" );

    let scope = self.pushScope();

    let argList: Node[] = {};
    let nextToken = self.analyzeDeclArgList( accessMode, argList );

    self.checkToken( nextToken, ")" );

    self.checkNextToken( "{" );

    let nextToken = self.getToken();

    let ast : Node = nil;
    if nextToken.txt == "{" {
        let parser = new Parser.WrapParser( self.parser, "decl macro %s" (nameToken.txt) );

        foreach typeInfo, symbol in scope.get_symbol2TypeInfoMap() {
            scope.add( symbol, typeInfo );
        }   

        self.macroScope = scope;
        
        let bakParser = self.parser;
        self.parser = parser;
        
        let stmtList = {};
        self.analyzeStatementList( stmtList, "}" );
        self.checkNextToken( "}" );


        self.parser = bakParser;


        self.macroScope = nil;
        '' ast = self.createNode( nodeKindBlock, firstToken.pos, [ typeInfoNone ],
	'' 		           { "kind": "macro", "stmtList": stmtList } );
        ast = new BlockNode(
            firstToken.pos, [ typeInfoNone ], "macro", stmtList );
    }
    else {
        self.pushback();
    }

    self.popScope();

    
    let tokenList: Parser.Token[] = [];
    let braceCount = 0;

    while true {
        nextToken = self.getToken();
        if nextToken.txt == "{" {
            braceCount = braceCount + 1;
        }
        elseif nextToken.txt == "}" {
            if braceCount == 0 {
                break;
            }
            braceCount = braceCount - 1;
        }
        table.insert( tokenList, nextToken );
    }

    let typeInfo = TypeInfo.createFunc(
        TypeInfoKindMacro, self.getCurrentNamespaceTypeInfo(),
        false, false, false, accessMode, nameToken.txt, nil, nil );
    self.scope.add( nameToken.txt, typeInfo );


    let declMacroInfo = new DeclMacroInfo( nameToken, argList, ast, tokenList ) ;
    '' let node = self.createNode(
    ''     nodeKindDeclMacro, firstToken.pos, [ typeInfo ], declMacroInfo );
    let node = new DeclMacroNode( firstToken.pos, [ typeInfo ], declMacroInfo );

    let macroObj = self.macroEval.eval( node );

    self.typeId2MacroInfo[ typeInfo.get_typeId() ] =
        new MacroInfo( macroObj, declMacroInfo, self.symbol2ValueMapForMacro );
    self.symbol2ValueMapForMacro = {};

    return node;
}


fn TransUnit.analyzeDeclProto( accessMode: str, firstToken: Parser.Token ) : Node
{
    let nextToken = self.getToken();
    if nextToken.txt == "class" {
        let name = self.getToken();

        nextToken = self.getToken();
        let baseRef:Node = nil;
        if nextToken.txt == "extend" {
            baseRef = self.analyzeRefType( accessMode );
            nextToken = self.getToken();
        }

        self.checkToken( nextToken, ";" );

        self.pushClass(
            baseRef and baseRef.get_expType() or nil, false, name.txt, accessMode );
        self.popClass();
    }
    else {
        self.error( "illegal proto" );
    }
    return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeDecl(
    accessMode: str, staticFlag: bool, firstToken: stem, token: stem ): stem
{
    let staticFlag = false;

    if not staticFlag {
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
    }
    let overrideFlag = false;
    if token.txt == "override" {
	overrideFlag = true;
        token = self.getToken();
    }

    if token.txt == "let" {
	return self.analyzeDeclVar( accessMode, staticFlag, firstToken );
    }
    elseif token.txt == "fn" {
	return self.analyzeDeclFunc(
            overrideFlag, accessMode, staticFlag, nil, firstToken, nil );
    }
    elseif token.txt == "class" {
	return self.analyzeDeclClass( accessMode, firstToken );
    }
    elseif token.txt == "proto" {
        return self.analyzeDeclProto( accessMode, firstToken );
    }
    elseif token.txt == "macro" {
        return self.analyzeDeclMacro( accessMode, firstToken );
    }

    return nil;
}

fn TransUnit.analyzeDeclMember(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem {
        let varName = self.getSymbolToken();
        let token = self.getToken();
        let refType = self.analyzeRefType( accessMode );
        token = self.getToken();

        let getterMode = "none";
        let setterMode = "none";
        if token.txt == "{" {
            let nextToken = self.getToken();
            if nextToken.txt == "pub" or nextToken.txt == "pri" {
                getterMode = nextToken.txt;
                nextToken = self.getToken();
                if nextToken.txt == "," {
                    nextToken = self.getToken();
                    if nextToken.txt == "pub" or nextToken.txt == "pri" {
                        setterMode = nextToken.txt;
                        nextToken = self.getToken();
                    }
                }
            }
            self.checkToken( nextToken, "}" );
            token = self.getToken();
        }

        '' accessor
        self.checkToken( token, ";" );

        self.scope.add( varName.txt, refType.expType );

        let info = {
            "name": varName, "refType": refType,
	    "staticFlag": staticFlag, "accessMode": accessMode,
            "getterMode": getterMode, "setterMode": setterMode
        };

        '' return self.createNode(
	''     nodeKindDeclMember, firstToken.pos, refType.expTypeList, info );
        return new DeclMemberNode(
            firstToken.pos, refType.expTypeList,
            varName, refType, staticFlag, accessMode, getterMode, setterMode );
    }

fn TransUnit.analyzeDeclMethod(
    overrideFlag: bool, accessMode: str, staticFlag: bool,
    className: Parser.Token, firstToken: Parser.Token, name: Parser.Token ): stem
{
    let node = self.analyzeDeclFunc(
        overrideFlag, accessMode, staticFlag, className, name, name );
    return node;
}

fn TransUnit.analyzeDeclClass( classAccessMode: str, firstToken: stem ): stem {
    let name = self.getSymbolToken();

    let nextToken = self.getToken();

    let baseRef:Node = nil;
    if nextToken.txt == "extend" {
        baseRef = self.analyzeRefType( classAccessMode );
        nextToken = self.getToken();
    }
    self.checkToken( nextToken, "{" );


    let classTypeInfo = self.pushClass(
        baseRef and baseRef.get_expType() or nil, false, name.txt, classAccessMode );

    let fieldList:Node[] = {};
    let memberList:Node[] = [];
    let methodName2Node: Map<str,Node> = {};
    '' let node = self.createNode(
    ''     nodeKindDeclClass, firstToken.pos, [ classTypeInfo ],
    ''     { "accessMode": classAccessMode, "name": name, "fieldList": fieldList,
    ''       "memberList": memberList, "scope": self.scope,
    ''       "outerMethodSet": {}
    ''     } );
    let node = new DeclClassNode(
        firstToken.pos, [ classTypeInfo ],
        classAccessMode, name, fieldList, memberList, self.scope, {} );
    self.typeInfo2ClassNode[ classTypeInfo ] = node;


    while true {
	let token = self.getToken();
	if token.txt == "}" {
	    break;
	}
	let accessMode = "pri";
	if token.txt == "pub" or token.txt == "pro" or
	    token.txt == "pri" or token.txt == "global"
	{
	    accessMode = token.txt;
	    token = self.getToken();
	}
	let staticFlag = false;
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
        let overrideFlag = false;
	if token.txt == "override" {
	    overrideFlag = true;
	    token = self.getToken();
	}

	if token.txt == "let" {
            let memberNode = self.analyzeDeclMember( accessMode, staticFlag, token );
	    table.insert( fieldList, memberNode );
            table.insert( memberList, memberNode );
	}
	elseif token.txt == "fn" {
            let nameToken = self.getToken();
            let methodNode = self.analyzeDeclMethod(
                overrideFlag, accessMode, staticFlag, name, token, nameToken );
	    table.insert( fieldList, methodNode );
	}
	elseif token.txt == ";" {
        }
	else {
            self.error( "illegal field" );
        }
    }

    let parentInfo = classTypeInfo;

    '' accessor の生成
    foreach memberNode in memberList {
        let memberType = memberNode.expType;
        if memberNode.expType.accessMode ~= "pub" {
            memberType = TypeInfo.cloneToPublic( memberType );
        }
        let memberName = memberNode.info.name;
        let getterName = "get_" .. memberName.txt;
        let accessMode = memberNode.info.getterMode;
        if accessMode ~= "none" and not self.scope.getTypeInfo( getterName )
        {
            let retTypeInfo = TypeInfo.createFunc(
                TypeInfoKindMethod, parentInfo, true, false, false, "pub",
                getterName, nil, [ memberType ] );
            self.scope.add( getterName, retTypeInfo );
        }
        let setterName = "set_" .. memberName.txt;
        let accessMode = memberNode.info.setterMode;
        if memberNode.info.setterMode ~= "none" and
            not self.scope.getTypeInfo( setterName )
        {
            self.scope.add(
                setterName,
                TypeInfo.createFunc(
                    TypeInfoKindMethod, parentInfo, true, false, false, "pub",
                    setterName, nil, [ memberType ]
                ));
        }
    }

    self.popClass();

    return node;
}


fn TransUnit.analyzeDeclFunc(
    overrideFlag: bool, accessMode: str, staticFlag: bool, classNameToken: stem,
    firstToken: Parser.Token, name: Parser.Token ) : stem
{
    let argList = {};
    let token = self.getToken();
    if not name {
	if token.txt ~= "(" {
	    name = self.checkSymbol( token );
	    token = self.getToken();
	}
    }
    else {
	name = self.checkSymbol( name );
    }
    let needPopFlag = false;
    if token.txt == "." {
        needPopFlag = true;
        classNameToken = name;

        self.pushClass( nil, false, name.txt, "pub" );

        name = self.getSymbolToken();
        token = self.getToken();
    }

    let kind = nodeKindDeclConstr;
    let typeKind = TypeInfoKindFunc;
    if classNameToken {
        if not staticFlag {
            typeKind = TypeInfoKindMethod;
        }
	if name.txt == "__init" {
	    kind = nodeKindDeclConstr;
	}
	else {
	    kind = nodeKindDeclMethod;
	}
    }
    else {
	kind = nodeKindDeclFunc;
        if not staticFlag {
            staticFlag = true;
        }
    }

    if overrideFlag {
        '' オーバーライドの型チェック
        let overrideType = self.scope.getTypeInfoMethod( name.txt );
        if not overrideType {
            self.error( "not found override -- " .. name.txt );
        }
        if overrideType.get_accessMode() ~= accessMode {
            self.error( "missmatch override accessMode -- %s,%s,%s"
                        ( name.txt, overrideType.get_accessMode(), accessMode ) );
        }
        if overrideType.get_staticFlag() ~= staticFlag {
            self.error( "missmatch override staticFlag -- " .. name.txt );
        }
        if overrideType.get_kind() ~= TypeInfoKindMethod {
            self.error( "missmatch override kind -- %s, %d"
                        ( name.txt, overrideType.get_kind() ) );
        }
    }
    elseif name and self.scope.getTypeInfoMethod( name.txt ) {
        '' override 宣言していないのに、オーバーライドしている場合エラー
        self.error( "missmatch override --" .. name.txt );
    }


    self.checkToken( "(" );

    let scope = self.pushScope();

    token = self.analyzeDeclArgList( accessMode, argList );

    self.checkToken( token, ")" );

    token = self.getToken();
    let retTypeList = {};
    let retTypeInfoList = {};
    if token.txt == ":" {
	repeat {
	    let refType = self.analyzeRefType( accessMode );
	    table.insert( retTypeList, refType );
	    table.insert( retTypeInfoList, refType.expType );
	    token = self.getToken();
	} token.txt ~= ",";
    }


    let typeInfo = TypeInfo.createFunc(
        typeKind, self.getCurrentNamespaceTypeInfo(),
        false, false, staticFlag, accessMode,
	name and name.txt or "", nil, retTypeInfoList );
    if name {
	scope.get_parent().add( name.txt, typeInfo );
    }

    if not needPopFlag {
        self.pushNamespace( name and name.txt or "", typeInfo, scope );
    }

    let node:Node = nil;
    let info:DeclFuncInfo = nil;
    if token.txt == ";" {
	node = self.createNoneNode( firstToken.pos );
    }
    else {
        self.pushback();
        let body = self.analyzeBlock( "func", scope );
        info = new DeclFuncInfo(
            classNameToken, name, argList, staticFlag, accessMode,
            body, retTypeList, retTypeInfoList );
        '' node = self.createNode( kind, firstToken.pos, [ typeInfo ], info );

        switch ( kind ) {
            case nodeKindDeclConstr {
                node = new DeclConstrNode( firstToken.pos, [ typeInfo ], info );
            }
	    case nodeKindDeclMethod {
                node = new DeclMethodNode( firstToken.pos, [ typeInfo ], info );
            }
            case nodeKindDeclFunc {
                node = new DeclFuncNode( firstToken.pos, [ typeInfo ], info );
            }
            default {
                self.error( "illegal kind -- %d" (kind) );
            }
        }
    }

    if not needPopFlag {
        self.popNamespace();
    }

    self.popScope();

    if needPopFlag {
        self.addMethod( classNameToken.txt, node, name.txt );
        self.popClass();
    }

    return node;
}

fn TransUnit.analyzeDeclVar(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem
{
    let unwrapFlag = false;
    let token = self.getToken();
    if token.txt == "!" {
	unwrapFlag = true;
    }
    else {
	self.pushback();
    }

    let typeInfoList : TypeInfo[] = {};

    let varList = {};
    repeat {
	let varName = self.getSymbolToken();
	token = self.getToken();
	let typeInfo = typeInfoNone;
	let refType = nil;
	if token.txt == ":" {
	    refType = self.analyzeRefType( accessMode );
	    typeInfo = refType.expType;
	    token = self.getToken();
	}
	table.insert( varList, new VarInfo( varName, refType ) );
	table.insert( typeInfoList, typeInfo );
    } token.txt ~= ",";

    let expList = nil;
    if token.txt == "=" {
	expList = self.analyzeExpList();
        if not expList {
	    self.error( "expList is nil" );
        }
    }
    if expList {
        let nodeList: Node[] = expList.expList;
        foreach exp, index in nodeList {
            if not typeInfoList[ index ] or typeInfoList[ index ] == typeInfoNone {
		typeInfoList[ index ] = exp[ "expType" ];
	    }
	}
    }

    let unwrapBlock: Node = nil;
    if unwrapFlag {
	unwrapBlock = self.analyzeBlock( "let!" );

        foreach typeInfo, index in typeInfoList {
	    if typeInfo.get_nilable() {
	        typeInfoList[ index ] = typeInfo.get_orgTypeInfo();
	    }
        }
    }

    if self.macroScope == self.scope {
        foreach typeInfo, index in typeInfoList {
            let varInfo = varList[ index ];
            
            self.symbol2ValueMapForMacro[ varInfo.name.txt ] =
                new MacroValInfo( nil, typeInfo);
        }
    }

    self.checkNextToken( ";" );

    '' let declVarInfo = { "accessMode": accessMode,
    ''                     "varList": varList, "expList": expList,
    ''                     "typeInfoList": typeInfoList, "unwrap": unwrapBlock };



    '' let node = self.createNode(
    ''     nodeKindDeclVar, firstToken.pos, [ typeInfoNone ], declVarInfo );
    let node = new DeclVarNode(
        firstToken.pos, [ typeInfoNone ],
        accessMode, varList, expList, typeInfoList, unwrapBlock );

    foreach typeInfo, index in typeInfoList {
	self.scope.add( varList[ index ].name.txt, typeInfo );
    }
    return node;
}

fn TransUnit.analyzeExpList(): Node {
    let expList = {};
    let firstExp = nil;
    repeat {
	let exp = self.analyzeExp();
	if not firstExp {
	    firstExp = exp;
	}
	table.insert( expList, exp );
	let token = self.getToken();
    } token.txt ~= ",";

    self.pushback();

    '' return self.createNode(
    ''     nodeKindExpList, firstExp.pos, [ typeInfoNone ], expList );
    return new ExpListNode( firstExp.pos, [ typeInfoNone ], expList );
}

fn TransUnit.analyzeListConst( token: stem ): stem {
    let nextToken = self.getToken();
    let expList:ExpListNode = nil;
    let itemTypeInfo = typeInfoNone;
    if nextToken.txt ~= "]" {
	self.pushback();
        expList = self.analyzeExpList();
        self.checkNextToken( "]" );
        let nodeList: Node[] = expList.expList;
        foreach exp in nodeList {
	    if itemTypeInfo == typeInfoNone {
	        itemTypeInfo = exp[ "expType" ];
	    }
	    elseif itemTypeInfo ~= exp[ "expType" ] {
	        itemTypeInfo = typeInfoStem;
	    }
        }
    }
    let kind = nodeKindLiteralArray;
    let typeInfo = typeInfoNone;
    if token.txt == '[' {
	kind = nodeKindLiteralList;
        typeInfo = [ TypeInfo.createList(
            "pri", self.getCurrentClass(), [ itemTypeInfo ] ) ];
        return new LiteralListNode( token.pos, typeInfo, expList );
    }
    else {
	typeInfo = [ TypeInfo.createArray(
            "pri", self.getCurrentClass(), [ itemTypeInfo ] ) ];
        return new LiteralArrayNode( token.pos, typeInfo, expList );
    }
    ''return self.createNode( kind, token.pos, typeInfo, expList );
}

fn TransUnit.analyzeMapConst( token: stem ): stem {
    let nextToken = nil;
    let map = {};
    let pairList = {};
    let keyTypeInfo = typeInfoNone;
    let valTypeInfo = typeInfoNone;
    repeat {
	nextToken = self.getToken();
        if nextToken.txt == "}" {
	    break;
        }
        self.pushback();

        let key = self.analyzeExp();
        if key.expType ~= keyTypeInfo {
	    if keyTypeInfo ~= typeInfoNone {
	        keyTypeInfo = typeInfoStem;
	    }
	    else {
	        keyTypeInfo = key.expType;
	    }
        }
        self.checkNextToken( ":" );
        let val = self.analyzeExp();
        if val.expType ~= valTypeInfo {
	    if valTypeInfo ~= typeInfoNone {
	        valTypeInfo = typeInfoStem;
	    }
	    else {
	        valTypeInfo = val.expType;
	    }
        }

        ''table.insert( pairList, { "key": key, "val": val } );
        table.insert( pairList, new PairItem( key, val ) );
        map[ key ] = val;
        nextToken = self.getToken();
    } nextToken.txt ~= ",";

    let typeInfo = TypeInfo.createMap(
        "pri", self.getCurrentClass(), keyTypeInfo, valTypeInfo );

    self.checkToken( nextToken, "}" );
    '' return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ],
    ''     		    { "map": map, "pairList": pairList } );
    return new LiteralMapNode( token.pos,[ typeInfo ], map, pairList );
}

fn TransUnit.analyzeExpRefItem( token: Parser.Token, exp: Node ): stem {
    let indexExp = self.analyzeExp();
    self.checkNextToken( "]" );

    let info = { "val": exp, "index": indexExp };
    let typeInfo = typeInfoStem;
    if exp.expType {
	if exp.expType.kind == TypeInfoKindMap {
	    typeInfo = exp.expType.get_itemTypeInfoList()[2];
	}
	elseif exp.expType.kind == TypeInfoKindArray or
	    exp.expType.kind == TypeInfoKindArray
	{
	    typeInfo = exp.expType.get_itemTypeInfoList()[1];
	}
    }

    ''return self.createNode( nodeKindExpRefItem, token.pos, [ typeInfo ], info );
    return new ExpRefItemNode( token.pos, [ typeInfo ], exp, indexExp );
}


class MacroPaser extend Parser.Parser {
    let tokenList: Parser.Token[];
    let pos: int;
    let name: str;
    let parser: Parser.StreamParser;

    pub fn __init( tokenList: Parser.Token[], name: str ) {
        self.pos = 1;
        self.tokenList = tokenList;
        self.name = name;
        self.parser = nil;
    }

    pub override fn getToken() : Token {
        if #self.tokenList < self.pos {
            return nil;
        }
        let token = self.tokenList[ self.pos ];
        self.pos = self.pos + 1;

        '' Util.errorLog( "getToken: %s" (token.txt) );
        
        return token;
    }
    pub override fn getStreamName(): str {
        return self.name;
    }
}


fn TransUnit.evalMacro( firstToken: Parser.Token,
                        macroTypeInfo: TypeInfo, expList: ExpListNode )
{

    if expList and expList.get_expList() {
        foreach exp in expList.get_expList() {
            let kind = exp.kind;    
            if kind ~= nodeKindLiteralNil and
                kind ~= nodeKindLiteralChar and
                kind ~= nodeKindLiteralInt and
                kind ~= nodeKindLiteralReal and
                kind ~= nodeKindLiteralArray and
                kind ~= nodeKindLiteralList and
                kind ~= nodeKindLiteralMap and
                kind ~= nodeKindLiteralString and
                kind ~= nodeKindLiteralBool and
                kind ~= nodeKindLiteralSymbol and
                kind ~= nodeKindRefField and
                kind ~= nodeKindExpMacroStat 
            {                       
                self.error( "Macro arguments must be literal value." );
            }                       
        }                       
    }                       

    let macroInfo = self.typeId2MacroInfo[ macroTypeInfo.get_typeId() ];

    let argVal:stem[] = []; 
    let argType:stem[] = []; 
    if expList {            
        foreach argNode in expList.get_expList() {
            ''let val, typeInfo = getLiteralValue( argNode );
            let valList, typeInfoList = argNode.getLiteral();
            let val = valList[1];
            let typeInfo = typeInfoList[1];
            '' if type( val ) == "table" {
            ''     foreach txt in val@str[] {
            ''         if type( txt ) == "table" {
            ''             foreach txt2 in txt@str[] {
            ''                 Util.errorLog( "hoge: %s" ( txt2 ) );
            ''             }
            ''         }
            ''         else {
            ''             Util.errorLog( "hoge: %s" ( txt ) );
            ''         }
            ''     }
            '' }
            '' else {
            ''         Util.errorLog( "hoge: %s" ( val ) );
            '' }
            table.insert( argVal, val );
            table.insert( argType, typeInfo );
        }                       
    }                       

    let func = macroInfo.func;
    let macroVars:Map<str,stem> = func( table.unpack( argVal ) );

    foreach name in macroVars._names@str[] {
        let valInfo = macroInfo.symbol2MacroValInfoMap[ name ];
        let typeInfo = valInfo and valInfo.typeInfo or typeInfoStem;
        let val = macroVars[ name ];
        if typeInfo == typeInfoSymbol {
            val = [ val ];
        }
        self.symbol2ValueMapForMacro[ name ] = new MacroValInfo( val, typeInfo );
    }
    
    ''let scope = self.pushScope();


    let argList:Node[] = macroInfo.declInfo.get_argList();
    if argList {            
        foreach arg, index in argList {
            let argInfo:stem = arg; 
            let argType = argInfo.info.argType;
            let argName = argInfo.info.name.txt;
            ''scope.add( argName, argType.expType );
            self.symbol2ValueMapForMacro[ argName ] =
                new MacroValInfo( argVal[ index ], argType.expType );
        }                       
    }

    '' foreach macroValInfo, symbol in self.symbol2ValueMapForMacro {
    ''     Util.errorLog( "HOGE: %s %s" (symbol, macroValInfo) );
    '' }
    

    let parser = new MacroPaser( macroInfo.declInfo.tokenList, "macro" );
    let bakParser = self.parser;
    self.parser = parser;   
    

    self.macroMode = "expand";

    
    let stmtList = {};      
    self.analyzeStatementList( stmtList, "}" );


    ''    self.popScope();        

    self.macroMode = "none";
    self.parser = bakParser;

    
    '' return self.createNode( 
    ''     nodeKindExpMacroExp, firstToken.pos, typeInfoNone, stmtList );
    return new ExpMacroExpNode( firstToken.pos, typeInfoNone, stmtList );
    
}                       

fn TransUnit.analyzeExpCont( firstToken: Parser.Token, exp: Node, skipFlag: bool ): stem {
    let nextToken = self.getToken();

    if not skipFlag {
	repeat {
	    let matchFlag = false;
	    if nextToken.txt == "[" {
		matchFlag = true;
	        exp = self.analyzeExpRefItem( nextToken, exp );
	        nextToken = self.getToken();
	    }
	    if nextToken.txt == "(" {
                let macroFlag = false;
                if exp.expType.get_kind() == TypeInfoKindMacro {
                    macroFlag = true;
                    self.symbol2ValueMapForMacro = {};
                    self.macroMode = "analyze";
                }
                
		matchFlag = true;
	        let work = self.getToken();
	        let expList: ExpListNode = nil;
	        if work.txt ~= ")" {
		    self.pushback();
	            expList = self.analyzeExpList();
	            self.checkNextToken( ")" );
	        }
	        let info = { "func": exp, "argList": expList };

                if macroFlag {
                    self.macroMode = "none";
                    exp = self.evalMacro( firstToken, exp.expType, expList );
                }
                else {
	            '' exp = self.createNode(
		    ''     nodeKindExpCall, firstToken.pos,
                    ''     exp.expType.get_retTypeInfoList(), info );
	            exp = new ExpCallNode(
		        firstToken.pos,
                        exp.expType.get_retTypeInfoList(), exp, expList );
                }

	        nextToken = self.getToken();
	    }
	} not matchFlag;
    }

    if nextToken.txt == "." {
	return self.analyzeExpSymbol(
	    firstToken, self.getToken(), "field", exp, skipFlag );
    }

    self.pushback();
    return exp;

}


fn TransUnit.analyzeExpSymbol(
    firstToken: stem, token: stem, mode: str, prefixExp: Node, skipFlag: bool ): stem {
        let exp = nil;

        if mode == "field" {
	    let info = { "field": token, "prefix": prefixExp };
	    let typeInfo = typeInfoNone;
	    if not prefixExp.expType {
	        self.error( "unknown prefix type: " .. getNodeKindName( prefixExp.kind ) );
	    }
	    if prefixExp.expType.get_kind() == TypeInfoKindClass {
	        let classScope = self.typeId2Scope[ prefixExp.expType.get_typeId() ];
	        let className = prefixExp.expType.getTxt();
	        if not classScope {
		    self.error( "not found field: %s, %s" ( className,
                                                            prefixExp.expType ) );
	        }
	        typeInfo = classScope.getTypeInfo( token.txt );
	        if not typeInfo {
                    print( "hoge", classScope.symbol2TypeInfoMap );
                    foreach val, name in classScope.symbol2TypeInfoMap {
                        print( "hoge", name, val );
                    }
	            self.error( string.format(
		        "not found field typeInfo: %s.%s %s",
		        className, token.txt, classScope) );
	        }
	    }
	    '' exp = self.createNode(
            ''     nodeKindRefField, firstToken.pos, [ typeInfo ], info );
	    exp = new RefFieldNode(
                firstToken.pos, [ typeInfo ], token, prefixExp );
        }
        elseif mode == "symbol" {
            if self.macroMode == "analyze" {
	        '' exp = self.createNode(
                ''     nodeKindLiteralSymbol, firstToken.pos,
                ''     [ typeInfoSymbol ], token );
	        exp = new LiteralSymbolNode(
                    firstToken.pos, [ typeInfoSymbol ], token );
            }
            else {
                let typeInfo = self.scope.getTypeInfo( token.txt );
	        if not typeInfo and token.txt == "self" {
	            let namespaceInfo = self.classList[#self.classList];
	            typeInfo = namespaceInfo.typeInfo;
	        }   
	        if not typeInfo {
	            self.error( "not found type -- " .. token.txt );
	        }

                if typeInfo == typeInfoSymbol {
                    skipFlag = true;
                }
	        '' exp = self.createNode( nodeKindExpRef, firstToken.pos,
                ''                        [ typeInfo ], token );
	        exp = new ExpRefNode( firstToken.pos, [ typeInfo ], token );
            }
        }
        elseif mode == "fn" {
	    exp = self.analyzeDeclFunc( false, "pri", false, nil, token, nil );
        }
        else {
	    self.error( "illegal mode", mode );
        }

        return self.analyzeExpCont( firstToken, exp, skipFlag );
    }

fn TransUnit.analyzeExpOp2( firstToken: stem, exp: stem, prevOpLevel: int ): stem, int
{
    while true {
        let nextToken = self.getToken();
        let opLevel = prevOpLevel;
        let opTxt = nextToken.txt;

        if opTxt == "@" {
	    let castType = self.analyzeRefType( "pri" );
	    '' exp = self.createNode(
            ''     nodeKindExpCast, firstToken.pos, castType.expTypeList, exp );
	    exp = new ExpCastNode( firstToken.pos, castType.expTypeList, exp );
        }
        elseif nextToken.kind == Parser.kind.Ope {
	    if Parser.isOp2( opTxt ) {
                opLevel = op2levelMap[ opTxt ];
                if not opLevel {
                    error( string.format( "unknown op -- %s %s",
                                          opTxt, prevOpLevel ) );
                }
                if prevOpLevel and opLevel <= prevOpLevel {
                    self.pushback();
                    return exp;
                }

	        let exp2 = self.analyzeExp( false, opLevel );
	        let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };
	        let opTxt = nextToken.txt;

	        '' if not exp.expType or not exp2.expType {
	        ''     self.error( "illegal exp or exp2 %s, %s, %s , %s,%d:%d"
	        '' 		( exp.expType, exp2.expType,
                ''                   nextToken.txt, self.parser.getStreamName(),
	        '' 		  nextToken.pos.lineNo,	nextToken.pos.column) );
	        '' }

	        let expType = typeInfoNone;
                if not exp.expType {
                    self.error( "expType is nil %s:%d:%d"
                                ( self.parser.getStreamName(),
                                  firstToken.pos.lineNo, firstToken.pos.column ) );
                }

	        switch opTxt {
		    case "or", "and" {
		        if exp.expType.equals( exp2.expType ) {
			    expType = exp.expType;
		        }
		        else {
			    expType = typeInfoStem;
		        }
		    }
		    case "<", ">", "<=", ">=", "~=", "==", "not" {
			expType = typeInfoBool;
		    }
		    case "^", "|", "~", "&", "<<", ">>", "#" {
			expType = typeInfoInt;
		    }
		    case ".." {
			expType = typeInfoString;
		    }
		    case "+", "-", "*", "/", "//", "%" {
			if exp.expType == typeInfoReal or exp2.expType == typeInfoReal
			{
			    expType = typeInfoReal;
			}
			else {
			    expType = typeInfoInt;
			}
		    }
		    case "=" {
			'' if not exp.expType.equals( exp2.expType ) {
			''     self.addErrMess(
			'' 	nextToken.pos,
			'' 	"unmatch type %s %s" ( exp.expType.getTxt(),
			'' 	                       exp2.expType.getTxt() ) );
			'' }
		    }
		    default {
			self.error( "unknown op " .. opTxt );
		    }
		}

	        '' exp = self.createNode(
                ''     nodeKindExpOp2, firstToken.pos, [ expType ], info );
	        exp = new ExpOp2Node(
                    firstToken.pos, [ expType ], nextToken, exp, exp2 );
	    }
	    else {
	        self.error( "illegal op" );
	    }
        }
        else {
	    self.pushback();
	    return exp;
        }
    }
    return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}

fn TransUnit.analyzeExpMacroStat( firstToken: Parser.Token ) {
    let expStrList: Node = [];

    self.checkNextToken( "{" );

    let braceCount = 0;
    while true {
        let token = self.getToken();

        if token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
            let exp = self.analyzeExp( true, op1levelMap[ token.txt ] );
            let format = token.txt == ",,," and "'%s '" or '"\'%s\'"';

            if token.txt == ",," and exp.kind == nodeKindExpRef {
                let refToken = (exp@ExpRefNode).get_token();
                let macroInfo = self.symbol2ValueMapForMacro[ refToken.txt ];
                if macroInfo and macroInfo.typeInfo == typeInfoSymbol {
                    format = "'%s '";
                }
            }
            let newToken = new Parser.Token( Parser.kind.Str, format, token.pos );
            '' let literalStr = self.createNode(
            ''     nodeKindLiteralString, token.pos, [ typeInfoString ],
            ''     new LiteralStringInfo( newToken, [ exp ] ) );
            let literalStr = new LiteralStringNode(
                token.pos, [ typeInfoString ], newToken, [ exp ] );
            table.insert( expStrList,  literalStr );
        }
        else {
            if token.txt == "{" {
                braceCount = braceCount + 1;
            }   
            elseif token.txt == "}" {
                if braceCount == 0 {
                    break;
                }   
                braceCount = braceCount - 1;
            }

            let newToken = new Parser.Token(
                token.kind, string.format( "'%s '", token.txt ), token.pos );
            '' let literalStr = self.createNode(
            ''     nodeKindLiteralString, token.pos, [ typeInfoString ],
            ''     new LiteralStringInfo( newToken, nil ) );
            let literalStr = new LiteralStringNode(
                token.pos, [ typeInfoString ], newToken, nil );
            table.insert( expStrList, literalStr );
        }
    }

    '' return self.createNode(
    ''     nodeKindExpMacroStat, firstToken.pos, [ typeInfoStat ], expStrList );
    return new ExpMacroStatNode( firstToken.pos, [ typeInfoStat ], expStrList );
}

fn TransUnit.analyzeSuper( firstToken:Parser.Token ) : Node {

    self.checkNextToken( "(" );

    let expList = self.analyzeExpList();
    
    self.checkNextToken( ")" );
    self.checkNextToken( ";" );

    let classType = self.getCurrentClass();
    let superType = classType.get_baseTypeInfo();
    
    '' return self.createNode(
    ''     nodeKindExpCallSuper, firstToken.pos, [ typeInfoNone ],
    ''     { "superType": superType, "expList": expList } ); 
    return new ExpCallSuperNode(
        firstToken.pos, [ typeInfoNone ], superType, expList ); 
}


fn TransUnit.analyzeExp( skipOp2Flag: bool, prevOpLevel: int ): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let exp = nil;

    if token.kind == Parser.kind.Dlmt {
	if token.txt == "..." {
	    '' return self.createNode(
            ''     nodeKindExpDDD, firstToken.pos, [ typeInfoNone ], token );
	    return new ExpDDDNode( firstToken.pos, [ typeInfoNone ], token );
	}

	if token.txt == '[' or token.txt == '[@' {
	    return self.analyzeListConst( token );
	}
	if token.txt == '{' {
	    return self.analyzeMapConst( token );
	}
	if token.txt == "(" {
	    exp = self.analyzeExp();
	    self.checkNextToken( ")" );
	    '' exp = self.createNode(
            ''     nodeKindExpParen, firstToken.pos, exp.expTypeList, exp );
	    exp = new ExpParenNode( firstToken.pos, exp.expTypeList, exp );
	    exp = self.analyzeExpCont( firstToken, exp, false );
	}
    }

    if token.txt == "new" {
	''let nextToken = self.getToken();
        ''exp = self.analyzeExpSymbol(
        ''  firstToken, nextToken, "symbol", nextToken, true );
        exp = self.analyzeRefType( "pri" );

        self.checkNextToken( "(" );
        let nextToken = self.getToken();
        let argList: stem = nil;
        if nextToken.txt ~= ")" {
	    self.pushback();
            argList = self.analyzeExpList();
            self.checkNextToken( ")" );
        }
        '' exp = self.createNode( nodeKindExpNew, firstToken.pos, exp.expTypeList,
	'' 		       { "symbol": exp, "argList": argList } );
        exp = new ExpNewNode( firstToken.pos, exp.expTypeList, exp, argList );
        exp = self.analyzeExpCont( firstToken, exp, false );
    }

    if token.kind == Parser.kind.Ope and Parser.isOp1( token.txt ) {
	'' 単項演算
        if token.txt == "`" {
            exp = self.analyzeExpMacroStat( token );
        }
        else {
	    exp = self.analyzeExp( true, op1levelMap[ token.txt] );
            let typeInfo = typeInfoNone;

            switch ( token.txt ) {
	        case "-" {
	            if exp.expType ~= typeInfoInt and exp.expType ~= typeInfoReal {
		        self.addErrMess(
		            token.pos,
                            'unmatch type for "-" -- %s' ( exp.expType.getTxt() ) );
	            }
	            typeInfo = exp.expType;
	        }
                case "#" {
	            typeInfo = typeInfoInt;
	        }
                case "not" {
	            typeInfo = typeInfoBool;
	        }
                case ",," {
	        }
                case ",,," {
                    if exp.expType ~= typeInfoString {
                        self.error( "unmatch ,,, type, need string type" );
                    }   
	            typeInfo = typeInfoSymbol;
                }
                case ",,,," {
                    if exp.expType ~= typeInfoSymbol {
                        self.error( "unmatch ,,, type, need symbol type" );
                    }   
	            typeInfo = typeInfoString;
                }
                case "`" {
                    typeInfo = typeInfoNone;
                }
                case "not" {
	            typeInfo = typeInfoBool;
	        }
                default {
	            self.error( "unknown op1" );
                }
	    }

            '' exp = self.createNode( nodeKindExpOp1, firstToken.pos, [ typeInfo ],
	    ''     	           { "op": token, "exp": exp } );
            exp = new ExpOp1Node( firstToken.pos, [ typeInfo ], token, exp );
            return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
        }
    }


    if token.kind == Parser.kind.Int {
	'' exp = self.createNode( nodeKindLiteralInt, firstToken.pos, [ typeInfoInt ],
	'' 		       { "token": token, "num": tonumber( token.txt ) } );
	exp = new LiteralIntNode( firstToken.pos, [ typeInfoInt ],
	                          token, tonumber( token.txt ) );
    }
    elseif token.kind == Parser.kind.Real {
	'' exp = self.createNode( nodeKindLiteralReal, firstToken.pos, [ typeInfoReal ],
	'' 		       { "token": token, "num": tonumber( token.txt ) } );
	exp = new LiteralRealNode( firstToken.pos, [ typeInfoReal ],
			           token, tonumber( token.txt ) );
    }
    elseif token.kind == Parser.kind.Char {
	let num = 0;
	if #(token.txt) == 1 {
	    num = token.txt.byte( 1 );
	}
	else {
	    num = quotedChar2Code[ token.txt.sub( 2, 2 ) ];
	}
	'' exp = self.createNode( nodeKindLiteralChar, firstToken.pos, [ typeInfoChar ],
	'' 		       { "token": token, "num": num } );
	exp = new LiteralCharNode( firstToken.pos, [ typeInfoChar ], token, num );
    }
    elseif token.kind == Parser.kind.Str {
	let nextToken = self.getToken();
	let formatArgList:Node = [];
	if nextToken.txt == "(" {
	    repeat {
		let arg = self.analyzeExp();
		table.insert( formatArgList, arg );
		nextToken = self.getToken();
	    } nextToken.txt ~= ",";
	    self.checkToken( nextToken, ")" );
	    nextToken = self.getToken();
	}
	'' exp = self.createNode(
        ''     nodeKindLiteralString, firstToken.pos, [ typeInfoString ],
        ''     new LiteralStringInfo( token, formatArgList ) );
	exp = new LiteralStringNode(
            firstToken.pos, [ typeInfoString ], token, formatArgList );
	token = nextToken;
	if token.txt == "[" {
	    exp = self.analyzeExpRefItem( token, exp );
	}
	else {
	    self.pushback();
	}
    }
    elseif token.txt == "fn" {
	exp = self.analyzeExpSymbol( firstToken, token, "fn", token, false );
    }
    elseif token.kind == Parser.kind.Symb {
	exp = self.analyzeExpSymbol(
            firstToken, token, "symbol", token, false );
    }
    elseif token.kind == Parser.kind.Type {
	''exp = self.createNode( nodeKindExpRef, firstToken.pos, [ typeInfoNone ], token );
	exp = new ExpRefNode( firstToken.pos, [ typeInfoNone ], token );
    }
    elseif token.txt == "true" or token.txt == "false" {
	'' exp = self.createNode(
        ''     nodeKindLiteralBool, firstToken.pos, [ typeInfoBool ], token );
	exp = new LiteralBoolNode( firstToken.pos, [ typeInfoBool ], token );
    }
    elseif token.txt == "nil" {
	'' exp = self.createNode(
        ''     nodeKindLiteralNil, firstToken.pos, [ typeInfoNil ] , token );
	exp = new LiteralNilNode( firstToken.pos, [ typeInfoNil ] );
    }

    if not exp {
	self.error( "illegal exp" );
    }

    if skipOp2Flag {
	return exp;
    }

    return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}


fn TransUnit.analyzeStatement( termTxt: str ): Node {
    let token = self.getTokenNoErr();
    if not token {
	return nil;
    }

    let statement = self.analyzeDecl( "pri", false, token, token );

    if not statement {
	if token.txt == termTxt {
	    self.pushback();
	    return nil;
	}
	elseif token.txt == "pub" or token.txt == "pro" or
	    token.txt == "pri" or token.txt == "global" or token.txt == "static"
	{
	    let accessMode = (token.txt ~= "static") and token.txt or "pri";
	    let staticFlag = (token.txt == "static");

	    let nextToken = nil;
	    if token.txt ~= "static" {
		nextToken = self.getToken();
	    }
	    else {
		nextToken = token;
	    }
	    statement = self.analyzeDecl( accessMode, staticFlag, token, nextToken );
	}
	elseif token.txt == "{" {
	    self.pushback();
	    statement = self.analyzeBlock( "{" );
	}
        elseif token.txt == "super" {
            statement = self.analyzeSuper( token );
        }
	elseif token.txt == "if" {
	    statement = self.analyzeIf( token );
	}
        elseif token.txt == "switch" {
            statement = self.analyzeSwitch( token );
        }
	elseif token.txt == "while" {
	    statement = self.analyzeWhile( token );
	}
	elseif token.txt == "repeat" {
	    statement = self.analyzeRepeat( token );
	}
	elseif token.txt == "for" {
	    statement = self.analyzeFor( token );
	}
	elseif token.txt == "apply" {
	    statement = self.analyzeApply( token );
	}
	elseif token.txt == "foreach" {
	    statement = self.analyzeForeach( token, false );
	}
	elseif token.txt == "forsort" {
	    statement = self.analyzeForeach( token, true );
	}
	elseif token.txt == "return" {
            let nextToken = self.getToken();

            let expList: Node = nil;
            if nextToken.txt ~= ";" {
                self.pushback();
	        expList = self.analyzeExpList();
	        self.checkNextToken( ";" );
            }
	    '' statement = self.createNode(
	    ''     nodeKindReturn, token.pos, [ typeInfoNone ], expList );
	    statement = new ReturnNode( token.pos, [ typeInfoNone ], expList );
	}
	elseif token.txt == "break" {
	    self.checkNextToken( ";" );
	    '' statement = self.createNode(
            ''     nodeKindBreak, token.pos, [ typeInfoNone ], nil );}
	    statement = new BreakNode( token.pos, [ typeInfoNone ] );
        }
	elseif token.txt == "import" {
	    statement = self.analyzeImport( token );
	}
        elseif token.txt == ";" {
            '' statement = self.createNode(
            ''     nodeKindNone, token.pos, [ typeInfoNone ], nil );
            statement = self.createNoneNode( token.pos );
        }
        elseif token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
            self.error( "illegal macro op -- %s" (token.txt) );
        }
	else {
	    self.pushback();
	    let exp = self.analyzeExp();
	    self.checkNextToken( ";" );
	    '' statement = self.createNode(
	    ''     nodeKindStmtExp, self.currentToken.pos, [ typeInfoNone ], exp );
	    statement = new StmtExpNode(
                self.currentToken.pos, [ typeInfoNone ], exp );
        }
    }

    return statement;
}


fn TransUnit.analyzeStatementList( stmtList: stem[], termTxt: str ) {
    while true {
	let statement = self.analyzeStatement( termTxt );
	if not statement {
	    break;
	}
	table.insert( stmtList, statement );
    }
}
