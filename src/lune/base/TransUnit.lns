import lune.base.Parser;

fn debugLog() {
    let debugInfo1 = debug.getinfo( 2 );
    let debugInfo2 = debug.getinfo( 3 );
    let debugInfo3 = debug.getinfo( 4 );
    print( debugInfo1[ "short_src" ], debugInfo1[ 'currentline' ] );
    print( debugInfo2[ "short_src" ], debugInfo2[ 'currentline' ] );
    print( debugInfo3[ "short_src" ], debugInfo3[ 'currentline' ] );
}

let typeIdSeed = 1;

pub let typeInfo = {};
let builtInTypeMap = {};

let TypeInfoKindPrim = 1;
let TypeInfoKindList = 2;
let TypeInfoKindArray = 3;
let TypeInfoKindMap = 4;
let TypeInfoKindClass = 5;
let TypeInfoKindFunc = 6;

class TypeInfo {
    pri let itemTypeInfo: TypeInfo[@];
    pri let retTypeInfo: TypeInfo[@];
    pri let typeId: int;
    pri let txt: str;
    pri let kind: int;
    __init( txt: str, typeId: int, kind: int,
	    itemTypeInfo: TypeInfo[@], retTypeInfo: TypeInfo[@] ) {
	self.txt = txt;
	self.typeId = typeId;
	self.kind = kind;
	self.itemTypeInfo = itemTypeInfo or [@];
	self.retTypeInfo = retTypeInfo or [@];
	return self;
    }

    pub serialize() {
	let txt = '{ itemTypeId = { ';

	foreach typeInfo, index in self.itemTypeInfo {
	    if index ~= 1 {
		txt = txt .. ", ";
	    }
	    txt = "%s%d" (txt, typeInfo.typeId );
	}
	txt = txt .. '}, typeId = %d, txt = "%s", kind = %d }' (self.typeId,
							       self.txt, self.kind );
	
	return txt;
    }

    pub getItemTypeInfoList() : TypeInfo[@] {
	return self.itemTypeInfo;
    }

    pub getRetTypeInfoList() : TypeInfo[@] {
	return self.retTypeInfo;
    }
    
    pub getKind() : int {
	return self.kind;
    }

    pub getTypeId() : int {
	return self.typeId;
    }
    
    pub getTxt() : str {
	if self.kind == TypeInfoKindArray {
	    return self.itemTypeInfo[1].getTxt() .. "[@]";
	}
	if self.kind == TypeInfoKindList {
	    return self.itemTypeInfo[1].getTxt() .. "[]";
	}
	if self.itemTypeInfo and #self.itemTypeInfo > 0 {
	    let txt = self.txt .. "<";
	    foreach typeInfo, index in self.itemTypeInfo {
		if index ~= 1 {
		    txt = txt .. ",";
		}
		txt = txt .. typeInfo.getTxt();
	    }
	    
	    return txt .. ">";
	}
	if self.txt {
	    return self.txt;
	}
	return "";
    }

    pub static create( kind: int, txt: str,
		       itemTypeInfo: TypeInfo[@], retTypeInfo: TypeInfo[@] ) {
	if kind == TypeInfoKindPrim {
	    return builtInTypeMap[ txt ];
	}
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( txt, typeIdSeed, kind, itemTypeInfo, retTypeInfo );
	return info;
    }
	

    
    pub static createBuiltin( idName: str, typeTxt: str, kind: int ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( typeTxt, typeIdSeed, kind );
	typeInfo[ idName ] = info;
	builtInTypeMap[ typeTxt ] = info;
	return info;
    }

    pub static createList( itemTypeInfo: TypeInfo ): TypeInfo {
	if not itemTypeInfo or #itemTypeInfo == 0 {
	    error( "illegal list type: %s" (itemTypeInfo) );
	}	
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( nil, typeIdSeed, TypeInfoKindList, itemTypeInfo );
    }

    pub static createArray( itemTypeInfo: TypeInfo ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( nil, typeIdSeed, TypeInfoKindArray, itemTypeInfo );
    }

    pub static createMap( keyTypeInfo: TypeInfo, valTypeInfo: TypeInfo ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	return new TypeInfo( "Map", typeIdSeed, TypeInfoKindMap,
			     [@ keyTypeInfo, valTypeInfo ] );
    }
    
    pub static createClass( className: str ): TypeInfo {
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( className, typeIdSeed, TypeInfoKindClass );
	return info;
    }

    pub static createFunc(
	funcName: str, argTypeList: TypeInfo[@], retTypeInfo: TypeInfo[@] ): TypeInfo
    {   
	typeIdSeed = typeIdSeed + 1;
	let info = new TypeInfo( funcName, typeIdSeed, TypeInfoKindFunc,
				 argTypeList, retTypeInfo );	    
	return info;
    }
}

let typeInfoNone = TypeInfo.createBuiltin( "None", "", TypeInfoKindPrim );
let typeInfoStem = TypeInfo.createBuiltin( "Stem", "stem" , TypeInfoKindPrim );
let typeInfoNil = TypeInfo.createBuiltin( "Nil", "nil" , TypeInfoKindPrim );
let typeInfoBool = TypeInfo.createBuiltin( "Bool", "bool" , TypeInfoKindPrim );
let typeInfoInt = TypeInfo.createBuiltin( "Int", "int" , TypeInfoKindPrim );
let typeInfoReal = TypeInfo.createBuiltin( "Real", "real" , TypeInfoKindPrim );
let typeInfoChar = TypeInfo.createBuiltin( "char", "char" , TypeInfoKindPrim );
let typeInfoString = TypeInfo.createBuiltin( "String", "str" , TypeInfoKindPrim );
let typeInfoMap = TypeInfo.createBuiltin( "Map", "Map" , TypeInfoKindMap );
let typeInfoList = TypeInfo.createBuiltin( "List", "List" , TypeInfoKindList );
let typeInfoArray = TypeInfo.createBuiltin( "Array", "Array" , TypeInfoKindArray );
let typeInfoForm = TypeInfo.createBuiltin( "Form", "form" , TypeInfoKindFunc );


class Scope {
    pri let parent: Scope;
    pri let symbol2TypeInfoMap: Map<str,TypeInfo>;
    pri let className2ScopeMap: Map<str,Scope>;
    __init( parent: Scope ) {
	self.parent = parent;
	self.symbol2TypeInfoMap = {};
	self.className2ScopeMap = {};
	return self;
    }
    pub add( name:str, typeInfo: TypeInfo ) {
	self.symbol2TypeInfoMap[ name ] = typeInfo;
    }
    pub addClass( name:str, typeInfo: TypeInfo, scope: Scope ) {
	self.add( name, typeInfo );
	self.className2ScopeMap[ name ] = scope;
    }

    pub getClassScope( name: str ) : Scope {
	let scope = self.className2ScopeMap[ name ];
	if not scope and self.parent {
	    scope = self.parent.getClassScope( name );
	}
	return scope;
    }
    
    pub getTypeInfoChild( name: str ) : TypeInfo {
	return self.symbol2TypeInfoMap[ name ];
    }


    pub getTypeInfo( name: str ) : TypeInfo {
	let node = self.symbol2TypeInfoMap[ name ];
	if node {
	    return node;
	}
	if self.parent {
	    return self.parent.getTypeInfo( name );
	}
	return builtInTypeMap[ name ];
    }
    pub getParent(): Scope {
	return self.parent;
    }
}

pub class NodePos {
    pri let lineNo: int;
    pri let column: int;
}

pub class Node {
    pri let kind: int;
    pri let pos: NodePos;
    pri let expType: TypeInfo;
    pri let info: stem;
    pub let filter: form;
}

pub class TransUnit {
    pri let scope: Scope;
    '' 解析中のクラスを保持する
    pri let classList: Map[];
    pri let moduleName2Info: Map;
    pri let parser: Parser.Parser;
    pri let typeInfo2Scope: Map<TypeInfo,Scope>;
    pri let pushbackToken: stem;
    pri let currentToken: stem;
    __init() {
	self.scope = new Scope( nil );
	self.classList = {};
	self.typeInfo2Scope = {};
	return self;
    }

    pri pushScope(): Scope {
	self.scope = new Scope( self.scope );
	return self.scope;
    }

    pri popScope() {
	self.scope = self.scope.getParent();
    }

    pri pushClass( name:str ): Scope {
	let typeInfo = self.scope.getTypeInfoChild( name );
	if not typeInfo {
	    typeInfo = TypeInfo.createClass( name );
	    let scope = self.pushScope();
	    scope.getParent().addClass( name, typeInfo, scope );
	}
	else {
	    self.scope = self.scope.getClassScope( name );
	}
	table.insert( self.classList,
		      { "name": name, "scope": self.scope, "typeInfo": typeInfo } );
	self.typeInfo2Scope[ typeInfo ] = self.scope;
	return self.scope;
    }

    pri popClass() {
	self.popScope();
	table.remove( self.classList );
    }

    pri analyzeDecl( accessMode: str, staticFlag:
		     bool, firstToken: stem, token: stem ): Node;
    pri analyzeDeclVar( accessMode: str, staticFlag: bool, firstToken: stem ): Node;
    pri analyzeDeclFunc( accessMode: str, staticFlag: bool,
			 methodFlag: bool, firstToken: stem, name: stem ) : Node;
    pri analyzeDeclClass( classAccessMode: str, classToken: stem ): Node;
    pri analyzeExp( skipOp2Flag: bool ): Node;
    pri analyzeStatement( stmtList: stem[], termTxt: str );
    pri analyzeExpSymbol( firstToken: stem, token: stem,
			  mode: str, prefixExp: stem, skipFlag: bool ): Node;
    pri analyzeExpList(): Node;
}


let nodeKind2NameMap: Map<int,str> = {};
let nodeKindSeed = 1;
pub let nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
    let kind = nodeKindSeed;
    nodeKindSeed = nodeKindSeed + 1;
    nodeKind2NameMap[ kind ] = name;
    nodeKind[ name ] = kind;
    return kind;
}

let nodeKindNone = regKind( 'None' );
let nodeKindImport = regKind( 'Import' );
let nodeKindRoot = regKind( 'Root' );
let nodeKindRefType = regKind( 'RefType' );
let nodeKindIf = regKind( 'If' );
let nodeKindWhile = regKind( 'While' );
let nodeKindRepeat = regKind( 'Repeat' );
let nodeKindFor = regKind( 'For' );
let nodeKindApply = regKind( 'Apply' );
let nodeKindForeach = regKind( 'Foreach' );
let nodeKindForsort = regKind( 'Forsort' );
let nodeKindReturn = regKind( 'Return' );
let nodeKindBreak = regKind( 'Break' );
let nodeKindExpNew = regKind( 'ExpNew' );
let nodeKindExpList = regKind( 'ExpList' );
let nodeKindExpRef = regKind( 'ExpRef' );
let nodeKindExpOp2 = regKind( 'ExpOp2' );
let nodeKindExpCast = regKind( 'ExpCast' );
let nodeKindExpOp1 = regKind( 'ExpOp1' );
let nodeKindExpRefItem = regKind( 'ExpRefItem' );
let nodeKindExpCall = regKind( 'ExpCall' );
let nodeKindExpDDD = regKind( 'ExpDDD' );
let nodeKindExpParen = regKind( 'ExpParen' );
let nodeKindBlock = regKind( 'Block' );
let nodeKindStmtExp = regKind( 'StmtExp' );
let nodeKindRefField = regKind( 'RefField' );
let nodeKindDeclVar = regKind( 'DeclVar' );
let nodeKindDeclFunc = regKind( 'DeclFunc' );
let nodeKindDeclMethod = regKind( 'DeclMethod' );
let nodeKindDeclConstr = regKind( 'DeclConstr' );
let nodeKindDeclMember = regKind( 'DeclMember' );
let nodeKindDeclArg = regKind( 'DeclArg' );
let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
let nodeKindDeclClass = regKind( 'DeclClass' );
let nodeKindLiteralNil = regKind( 'LiteralNil' );
let nodeKindLiteralChar = regKind( 'LiteralChar' );
let nodeKindLiteralInt = regKind( 'LiteralInt' );
let nodeKindLiteralReal = regKind( 'LiteralReal' );
let nodeKindLiteralArray = regKind( 'LiteralArray' );
let nodeKindLiteralList = regKind( 'LiteralList' );
let nodeKindLiteralMap = regKind( 'LiteralMap' );
let nodeKindLiteralString = regKind( 'LiteralString' );
let nodeKindLiteralBool = regKind( 'LiteralBool' );


let quotedChar2Code = {};
quotedChar2Code[ 'a' ] = 7;    '' \a
quotedChar2Code[ 'b' ] = 8;    '' \b
quotedChar2Code[ 't' ] = 9;    '' \t
quotedChar2Code[ 'n' ] = 10;   '' \t
quotedChar2Code[ 'v' ] = 11;   '' \v
quotedChar2Code[ 'f' ] = 12;   '' \f 
quotedChar2Code[ 'r' ] = 13;   '' \r
quotedChar2Code[ '\\' ] = ?\\; '' \\
quotedChar2Code[ '"' ] = ?\";  '' "
quotedChar2Code[ "'" ] = ?\';  '' '

pub fn getNodeKindName( kind: int ): str {
    return nodeKind2NameMap[ kind ];
}

pub fn nodeFilter( node: stem, filter: form, ... ) : stem {
    if not filter[ node.kind ] {
	error( string.format( "none filter -- %s",
			      getNodeKindName( node.kind ) ));
    }
    return filter[ node.kind ]( filter, node, ... );
}

fn TransUnit.registBuiltInScope() {
    let builtInInfo: Map<str,str[]> = {
	"": [ "error", "print", "tonumber" ],
	"io": [ "open" ],
	"string": [ "find", "byte", "format", "rep", "gmatch", "gsub" ],
	"table": [ "insert", "remove" ],
	"debug": [ "getinfo" ],
	"_luneScript": [ "loadModule" ],
    };
    
    foreach infoList, name in builtInInfo {
	if name ~= "" {
	    self.pushClass( name );
	}
	foreach info in infoList {
	    self.scope.add( info, TypeInfo.createFunc( info ) );
	}
	if name ~= "" {
	    self.popClass();
	}
    }
}


fn TransUnit.createNode( kind: int, pos: stem, expType: TypeInfo, info: Map ): Map {
    if not getNodeKindName( kind ) {
	error( string.format( "%d:%d: not found nodeKind", pos.lineNo, pos.column ) );
    }
    return { "kind": kind, "pos": pos, "expType": expType,
	     "info": info, "filter": nodeFilter };
}

fn TransUnit.error( mess: str ) {
    let pos = { "lineNo": 0, "column": 0 };
    let txt = "";
    if self.currentToken {
	pos = self.currentToken.pos;
	txt = self.currentToken.txt;
    }
    error( string.format( "%d:%d:(%s) %s", pos.lineNo, pos.column, txt, mess ) );
}

fn TransUnit.createNoneNode(): stem {
    return self.createNode( nodeKindNone, { "lineNo": 0, "column": 0 },
			    typeInfoNone, {} );			    
}

fn TransUnit.getTokenNoErr(): stem {
    if self.pushbackToken {
	self.currentToken = self.pushbackToken;
	self.pushbackToken = nil;
	return self.currentToken;
    }

    let commentList = {};
    let token = nil;
    while true {
	token = self.parser.getToken();
	if not token {
	    break;
	}
	if token.kind ~= Parser.kind.Cmnt {
	    break;
	}
	table.insert( commentList, token );
    }

    if token {
	token.commentList = commentList;
    }
    self.currentToken = token;
    return token;
}


fn TransUnit.getToken( mess: str ): stem {
    let token = self.getTokenNoErr();
    if not token {
	return Parser.getEofToken();
    }
    self.currentToken = token;
    return self.currentToken;
}

fn TransUnit.pushback() {
    if self.pushbackToken {
	error( string.format( "multiple pushback:%d:%d: %s, %s",
			      self.currentToken.pos.lineNo,
			      self.currentToken.pos.column,
			      self.pushbackToken.txt, self.currentToken.txt ) );
    }
    self.pushbackToken = self.currentToken;
    self.currentToken = nil;
}

fn TransUnit.checkSymbol( token: stem ): stem {
    if token.kind ~= Parser.kind.Symb and
	token.kind ~= Parser.kind.Kywd and
	token.kind ~= Parser.kind.Type
    {
	self.error( "illegal symbol" );
    }
    return token;
}

fn TransUnit.getSymbolToken(): Parser.Token {
    return self.checkSymbol( self.getToken() );
}


fn TransUnit.checkToken( token: stem, txt: str ): stem {
    if not token or token.txt ~= txt {
	self.error( string.format( "not found -- %s", txt ) );
    }
    return token;
}

fn TransUnit.checkNextToken( txt: str ): stem {
    return self.checkToken( self.getToken(), txt );
}


fn TransUnit.analyzeBlock( blockKind: str, scope: Scope ): stem {
    let token = self.checkNextToken( "{" );

    if not scope {
	self.pushScope();
    }

    let stmtList = {};
    self.analyzeStatement( stmtList, "}" );

    self.checkNextToken( "}" );

    if not scope {
	self.popScope();
    }

    let node = self.createNode( nodeKindBlock, token.pos, typeInfoNone, 
				{ "kind": blockKind, "stmtList": stmtList } );
    
    return node;
}


fn TransUnit.analyzeDecl(
    accessMode: str, staticFlag: bool, firstToken: stem, token: stem ): stem
{
    let staticFlag = false;

    if not staticFlag {
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
    }

    if token.txt == "let" {
	return self.analyzeDeclVar( accessMode, staticFlag, firstToken );
    }
    elseif token.txt == "fn" {
	return self.analyzeDeclFunc( accessMode, staticFlag, false, token, nil );
    }
    elseif token.txt == "class" {
	return self.analyzeDeclClass( accessMode, token );
    }

    return nil;
}

class _TypeInfo {
    pri let itemTypeId: int[];
    pri let typeId: int;
    pri let txt: str;
    pri let kind: int;
}
class _ModuleInfo {
    pri let _className2InfoMap: Map<str,Map<str,stem>>;
    pri let _typeInfoList: _TypeInfo[];
    pri let _varName2InfoMap: Map<str,stem>;
    pri let _funcName2InfoMap: Map<str,stem>;
}

fn TransUnit.analyzeImport( token: stem ) {
    let moduleToken = self.getToken();
    let modulePath = moduleToken.txt;
    let nextToken = {};

    let nameList = [ moduleToken.txt ];
    
    while true {
	nextToken = self.getToken();
	if nextToken.txt == "." {
	    nextToken = self.getToken();
	    moduleToken = nextToken;
	    modulePath = "%s.%s" ( modulePath, moduleToken.txt );
	    table.insert( nameList, moduleToken.txt );
	}
	else {
	    break;
	}
    }

    '' foreach moduleName in nameList {
    '' 	self.pushClass( moduleName );
    '' }
    self.pushClass( moduleToken.txt );

    let moduleInfo: _ModuleInfo = _luneScript.loadModule( modulePath );
    self.moduleName2Info[ modulePath ] = moduleInfo;
    
    foreach classInfo, className in moduleInfo._className2InfoMap {
	self.pushClass( className );
	foreach fieldInfo, fieldName in classInfo {
	    self.scope.add( fieldName, TypeInfo.createFunc( fieldName ) );
	}
	self.popClass();
    }

    let typeId2TypeInfo: Map<int,TypeInfo> = {};
    foreach typeInfo in moduleInfo._typeInfoList {
	let itemTypeInfo = {};
	foreach typeId in typeInfo.itemTypeId {
	    table.insert( itemTypeInfo, typeId2TypeInfo[ typeId ] );
	}
	typeId2TypeInfo[ typeInfo.typeId ] = TypeInfo.create(
	    typeInfo.typeId, typeInfo.txt, itemTypeInfo );
    }

    foreach varInfo, varName in moduleInfo._varName2InfoMap {
	self.scope.add( varName, typeId2TypeInfo[ varInfo[ "typeId" ] ] );
    }

    foreach funcInfo, funcName in moduleInfo._funcName2InfoMap {
	self.scope.add( funcName, typeId2TypeInfo[ funcInfo[ "typeId" ] ] );
    }
    
    self.popClass();

    '' foreach moduleName in nameList {
    '' 	self.popClass();
    '' }
    
    self.checkToken( nextToken, ";" );
    
    return self.createNode( nodeKindImport, token.pos, typeInfoNone, modulePath );
}

fn TransUnit.analyzeIf( token: stem ): stem {
    let list = {};
    table.insert(
	list, { "kind": "if", "exp": self.analyzeExp(),
		"block": self.analyzeBlock( "if" ) } );

    let nextToken = self.getToken();
    if nextToken.txt == "elseif" {
	while nextToken.txt == "elseif" {
	    table.insert(
		list, { "kind": "elseif", "exp": self.analyzeExp(),
			"block": self.analyzeBlock( "elseif" ) } );
	    nextToken = self.getToken();
	}
    }

    if nextToken.txt == "else" {
	table.insert(
	    list, { "kind": "else", "block": self.analyzeBlock( "else" ) } );
    }
    else {
	self.pushback();
    }

    return self.createNode(
	nodeKindIf, token.pos, typeInfoNone, list );
}

fn TransUnit.analyzeWhile( token: stem ): stem {
    let info = { "exp": self.analyzeExp(), "block": self.analyzeBlock( "while" ) };
    return self.createNode(
	nodeKindWhile, token.pos, typeInfoNone, info );
}

fn TransUnit.analyzeRepeat( token: stem ): stem {
    let scope = self.pushScope();
    let info = { "block": self.analyzeBlock( "repeat", scope ),
		 "exp": self.analyzeExp() };
    self.popScope();
    let node = self.createNode( nodeKindRepeat, token.pos, typeInfoNone, info );
    self.checkNextToken( ";" );
    return node;
}

fn TransUnit.analyzeFor( token: stem ): stem {

    let scope = self.pushScope();

    let val = self.getToken();
    if val.kind ~= Parser.kind.Symb {
	self.error( "not symbol" );
    }
    self.checkNextToken( "=" );
    let exp1 = self.analyzeExp();
    self.scope.add( val.txt, exp1.expType );
    self.checkNextToken( "," );
    let exp2 = self.analyzeExp();
    let token = self.getToken();
    let exp3 = nil;
    if token.txt == "," {
	exp3 = self.analyzeExp();
    }
    else {
	self.pushback();
    }

    let info = { "block": self.analyzeBlock( "for", scope ), "val": val,
		 "init": exp1, "to": exp2, "delta": exp3 };
    self.popScope();
    let node = self.createNode( nodeKindFor, token.pos, typeInfoNone, info );
    return node;
}

fn TransUnit.analyzeApply( token: stem ): stem {
    let scope = self.pushScope();
    let varList = {};
    let nextToken = nil;
    repeat {
	let var = self.getToken();
	if var.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	table.insert( varList, var );
	nextToken = self.getToken();
    } nextToken.txt ~= ",";
    self.checkToken( nextToken, "of" );

    let exp = self.analyzeExp();
    if exp.kind ~= nodeKindExpCall {
	self.error( "not call" );
    }

    let block = self.analyzeBlock( "apply", scope );
    self.popScope();

    let info = { "varList": varList, "exp": exp, "block": block };
    return self.createNode( nodeKindApply, token.pos, typeInfoNone, info );
}

fn TransUnit.analyzeForeach( token: stem, sortFlag: bool ): stem {
    let scope = self.pushScope();
    let valSymbol = nil;
    let keySymbol = nil;
    let nextToken = nil;
    for index = 1, 2 {
	let sym = self.getToken();
	if sym.kind ~= Parser.kind.Symb {
	    self.error( "illegal symbol" );
	}
	if index == 1 {
	    valSymbol = sym;
	}
	else {
	    keySymbol = sym;
	}
	nextToken = self.getToken();
	if nextToken.txt ~= "," {
	    break;
	}
    }
    self.checkToken( nextToken, "in" );

    let exp = self.analyzeExp();
    if not exp.expType {
	self.error( "unknown type of exp" );
    }
    else {
	let itemTypeInfoList = exp.expType.getItemTypeInfoList();
	if exp.expType.getKind() == TypeInfoKindMap {
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 2 ] );
	    if keySymbol {
		self.scope.add( keySymbol.txt, itemTypeInfoList[ 1 ] );
	    }   
	}	
	elseif exp.expType.getKind() == TypeInfoKindList or
	    exp.expType.getKind() == TypeInfoKindArray
	{	
	    self.scope.add( valSymbol.txt, itemTypeInfoList[ 1 ] );
	    if keySymbol {
		self.scope.add( keySymbol.txt, typeInfoInt );
	    }
	    else {
		self.scope.add( "__index", typeInfoInt );
	    }   
	}
        else {
            self.error( "unknown kind type of exp for foreach-- %d:%d" (exp.pos.lineNo,
                                                                         exp.pos.column) );
        }
    }
	

    let block = self.analyzeBlock( "foreach", scope );

    self.popScope();

    let info = { "val": valSymbol, "key": keySymbol,
		 "exp": exp, "block": block, "sort": sortFlag };
    return self.createNode( sortFlag and nodeKindForsort or nodeKindForeach,
			    token.pos, typeInfoNone, info );	    
}

fn TransUnit.analyzeRefType(): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let refFlag = false;
    if token.txt == "&" {
	refFlag = true;
	token = self.getToken();
    }
    let mutFlag = false;
    if token.txt == "mut" {
	mutFlag = true;
	token = self.getToken();
    }
    ''let name = self.checkSymbol( token );
    let name: Node = nil;
    let typeInfo = typeInfoStem;
    if self.checkSymbol( token ) {
	name = self.analyzeExpSymbol( firstToken, token, "symbol", token, true );
	typeInfo = name.expType;
    }
    else {
	self.pushback();
    }
    let arrayMode = "no";
    token = self.getToken();
    if token.txt == '[' or token.txt == '[@' {
	if token.txt == '[' {
	    arrayMode = "list";
	    typeInfo = TypeInfo.createList( [ typeInfo ] );
	}
	else {
	    arrayMode = "array";
	    typeInfo = TypeInfo.createArray( [ typeInfo ] );
	}
	token = self.getToken();
	if token.txt ~= ']' {
	    self.pushback();
	    self.checkNextToken( ']' );
	}
    }
    elseif token.txt == "<" {
	let genericList: Node[] = {};
	let nextToken: stem = nil;
	repeat {
	    let typeExp = self.analyzeRefType();
		
	    table.insert( genericList, typeExp.expType );
	    nextToken = self.getToken();
	} nextToken.txt ~= ",";
	self.checkToken( nextToken, '>' );
	if typeInfo.kind == TypeInfoKindMap {
	    typeInfo = TypeInfo.createMap( genericList[1],genericList[2] );
	}
	else {
	    self.error( string.format( "not support generic: %s", typeInfo.getTxt() ) );
	}
    }
    else {
	self.pushback();
    }


    return self.createNode(
	nodeKindRefType, firstToken.pos, typeInfo, 
	{ "name": name, "refFlag": refFlag, "mutFlag": mutFlag, "array": arrayMode } );
}


fn TransUnit.analyzeDeclMember(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem {
    let varName = self.getSymbolToken();
    token = self.getToken();
    let refType = self.analyzeRefType();
    token = self.getToken();
    '' accessor
    self.checkToken( token, ";" );

    self.scope.add( varName.txt, refType.expType );
	
    return self.createNode(
	nodeKindDeclMember, firstToken.pos, refType.expType, 
	{ "name": varName, "refType": refType,
	  "staticFlag": staticFlag, "accessMode": accessMode } );
}

fn TransUnit.analyzeDeclMethod(
    accessMode: str, staticFlag: bool,
    className: str, firstToken: stem, name: str ): stem
{
    let node = self.analyzeDeclFunc( accessMode, staticFlag, true, name, name );
    node.info.className = className;
    return node;
}

fn TransUnit.analyzeDeclClass( classAccessMode: str, classToken: stem ): stem {
    let name = self.getToken();
    self.checkNextToken( "{" );

    let fieldList = {};
    let typeInfo = TypeInfo.createClass( name );
    let node = self.createNode(
	nodeKindDeclClass, classToken.pos, typeInfo, 
	{ "accessMode": classAccessMode, "name": name, "fieldList": fieldList } );

    
    self.pushClass( name.txt );

    while true {
	let token = self.getToken();
	if token.txt == "}" {
	    break;
	}
	let accessMode = "pri";
	if token.txt == "pub" or token.txt == "pro" or
	    token.txt == "pri" or token.txt == "global"
	{
	    accessMode = token.txt;
	    token = self.getToken();
	}
	let staticFlag = false;
	if token.txt == "static" {
	    staticFlag = true;
	    token = self.getToken();
	}
	if token.txt == "let" {
	    table.insert( fieldList,
			  self.analyzeDeclMember( accessMode, staticFlag, token ) );
	}
	else {
	    table.insert(
		fieldList,
		self.analyzeDeclMethod(
		    accessMode, staticFlag, name, token, token ) );
	}
    }
    self.popClass();

    return node;
}

fn TransUnit.analyzeDeclFunc(
    accessMode: str, staticFlag: bool,
    methodFlag: bool, firstToken: stem, name: stem ) : stem
{
    let argList = {};
    let token = self.getToken();
    if not name {
	if token.txt ~= "(" {
	    name = self.checkSymbol( token );
	    token = self.getToken();
	}
    }
    else {
	self.checkSymbol( name );
    }
    let className:stem = nil;
    if token.txt == "." {
	methodFlag = true;
	className = name;

	self.pushClass( name.txt );
	
	name = self.getSymbolToken();
	token = self.getToken();
    }

    self.checkToken( "(" );

    let kind = nodeKindDeclConstr;
    if methodFlag {
	if name.txt == "__init" {
	    kind = nodeKindDeclConstr;
	}
	else {
	    kind = nodeKindDeclMethod;
	}
    }
    else {
	kind = nodeKindDeclFunc;
    }

    let scope = self.pushScope();
    repeat {
	let argName = self.getToken();
	if argName.txt == ")" {
	    token = argName;
	    break;
	}
	elseif argName.txt == "..." {
	    table.insert(
		argList,
		self.createNode(
		    nodeKindDeclArgDDD, argName.pos, typeInfoNone, argName ) );
	}
	else {
	    self.checkSymbol( argName );

	    self.checkNextToken( ":" );
	    let refType = self.analyzeRefType();
	    let arg = self.createNode( nodeKindDeclArg, argName.pos, refType.expType, 
				       { "name": argName, "argType": refType } );
	    self.scope.add( argName.txt, refType.expType );
	    table.insert( argList, arg );
	}
	token = self.getToken();
    } token.txt ~= ",";

    self.checkToken( token, ")" );

    token = self.getToken();
    let retTypeList = {};
    let retTypeInfoList = {};
    if token.txt == ":" {
	repeat {
	    let refType = self.analyzeRefType();
	    table.insert( retTypeList, refType );
	    table.insert( retTypeInfoList, refType.expType );
	    token = self.getToken();
	} token.txt ~= ",";
    }

    let typeInfo = TypeInfo.createFunc(
	name and name.txt or "", nil, retTypeInfoList );
    if name {
	scope.getParent().add( name.txt, typeInfo );
    }

    if token.txt == ";" {
	return self.createNoneNode();
    }

    self.pushback();
    let body = self.analyzeBlock( "func", scope );
    self.popScope();
    let info = { "name": name, "argList": argList, "staticFlag": staticFlag,
		 "body": body, "accessMode": accessMode,
		 "retTypeList": retTypeList,
		 "retTypeInfoList": retTypeInfoList };

    let node = self.createNode( kind, firstToken.pos, typeInfo, info );

    if className {
	info.className = className;
	self.popClass();
    }

    return node;
}

fn TransUnit.analyzeDeclVar(
    accessMode: str, staticFlag: bool, firstToken: stem ): stem
{

    let typeInfoList : TypeInfo[] = {};
	
    let varList = {};
    let token = nil;
    repeat {
	let varName = self.getSymbolToken();
	token = self.getToken();
	let typeInfo = typeInfoNone;
	let refType = nil;
	if token.txt == ":" {
	    refType = self.analyzeRefType();
	    typeInfo = refType.expType;
	    token = self.getToken();
	}
	table.insert( varList, { "name": varName, "refType": refType } );
	table.insert( typeInfoList, typeInfo );
    } token.txt ~= ",";

    let expList = nil;
    if token.txt == "=" {
	expList = self.analyzeExpList();
	if not expList {
	    self.error( "expList is nil" );
	}	
    }
    if expList {
        let nodeList: Node[] = expList.info;
        foreach exp, index in nodeList {
            if not typeInfoList[ index ] or typeInfoList[ index ] == typeInfoNone {
		typeInfoList[ index ] = exp[ "expType" ];
	    }
	}
    }

    self.checkNextToken( ";" );

    let declVarInfo = { "accessMode": accessMode,
			"varList": varList, "expList": expList,
			"typeInfoList": typeInfoList }; 
    let node = self.createNode(
	nodeKindDeclVar, firstToken.pos, typeInfoNone, declVarInfo );


    foreach typeInfo, index in typeInfoList {
	self.scope.add( varList[ index ].name.txt, typeInfo );
    }
    return node;
}

fn TransUnit.analyzeExpList(): Node {
    let expList = {};
    let firstExp = nil;
    repeat {
	let exp = self.analyzeExp();
	if not firstExp {
	    firstExp = exp;
	}
	table.insert( expList, exp );
	let token = self.getToken();
    } token.txt ~= ",";

    self.pushback();

    return self.createNode( nodeKindExpList, firstExp.pos, typeInfoNone, expList );
}

fn TransUnit.analyzeListConst( token: stem ): stem {
    let nextToken = self.getToken();
    let expList = nil;
    let itemTypeInfo = typeInfoNone;
    if nextToken.txt ~= "]" {
	self.pushback();
	expList = self.analyzeExpList();
	self.checkNextToken( "]" );
        let nodeList: Node[] = expList.info;
	foreach exp in nodeList {
	    if itemTypeInfo == typeInfoNone {
		itemTypeInfo = exp[ "expType" ];
	    }
	    elseif itemTypeInfo ~= exp[ "expType" ] {
		itemTypeInfo = typeInfoStem;
	    }
	}
    }
    let kind = nodeKindLiteralArray;
    if token.txt == '[' {
	kind = nodeKindLiteralList;
    }
    return self.createNode(
	kind, token.pos, TypeInfo.createList( [ itemTypeInfo ] ), expList );
}

fn TransUnit.analyzeMapConst( token: stem ): stem {
    let nextToken = nil;
    let map = {};
    let pairList = {};
    let keyTypeInfo = typeInfoNone;
    let valTypeInfo = typeInfoNone;
    repeat {
	nextToken = self.getToken();
	if nextToken.txt == "}" {
	    break;
	}
	self.pushback();

	let key = self.analyzeExp();
	if key.expType ~= keyTypeInfo {
	    if keyTypeInfo ~= typeInfoNone {
		keyTypeInfo = typeInfoStem;
	    }
	    else {
		keyTypeInfo = key.expType;
	    }
	}
	self.checkNextToken( ":" );
	let val = self.analyzeExp();
	if val.expType ~= valTypeInfo {
	    if valTypeInfo ~= typeInfoNone {
		valTypeInfo = typeInfoStem;
	    }
	    else {
		valTypeInfo = val.expType;
	    }
	}
	
	table.insert( pairList, { "key": key, "val": val } );
	map[ key ] = val;
	nextToken = self.getToken();
    } nextToken.txt ~= ",";

    let typeInfo = TypeInfo.createMap( keyTypeInfo, valTypeInfo );

    self.checkToken( nextToken, "}" );
    return self.createNode( nodeKindLiteralMap, token.pos, typeInfo, 
			    { "map": map, "pairList": pairList } );
}

fn TransUnit.analyzeExpRefItem( token: stem, exp: stem ): stem {
    let indexExp = self.analyzeExp();
    self.checkNextToken( "]" );

    let info = { "val": exp, "index": indexExp };
    let typeInfo = typeInfoStem;
    if exp.expType {
	if exp.expType.kind == TypeInfoKindMap {
	    typeInfo = exp.expType.getItemTypeInfoList()[2];
	}	
	elseif exp.expType.kind == TypeInfoKindArray or
	    exp.expType.kind == TypeInfoKindArray
	{	
	    typeInfo = exp.expType.getItemTypeInfoList()[1];
	}
    }
    
    return self.createNode( nodeKindExpRefItem, token.pos, typeInfo, info );
}

fn TransUnit.analyzeExpCont( firstToken: stem, exp: stem, skipFlag: bool ): stem {
    let nextToken = self.getToken();

    if not skipFlag {
	repeat {
	    let matchFlag = false;
	    if nextToken.txt == "[" {
		matchFlag = true;
		exp = self.analyzeExpRefItem( nextToken, exp );
		nextToken = self.getToken();
	    }   
	    if nextToken.txt == "(" {
		matchFlag = true;
		let work = self.getToken();
		let expList = nil;
		if work.txt ~= ")" {
		    self.pushback();
		    expList = self.analyzeExpList();
		    self.checkNextToken( ")" );
		}	
		let info = { "func": exp, "argList": expList };

		exp = self.createNode(
		    nodeKindExpCall, firstToken.pos, typeInfoNone, info );
		nextToken = self.getToken();
	    }   
	} not matchFlag;
    }

    if nextToken.txt == "." {
	return self.analyzeExpSymbol(
	    firstToken, self.getToken(), "field", exp, skipFlag );
    }

    self.pushback();
    return exp;

}

fn TransUnit.analyzeExpSymbol(
    firstToken: stem, token: stem, mode: str, prefixExp: stem, skipFlag: bool ): stem {
    let exp = nil;

    if mode == "field" {
	let info = { "field": token, "prefix": prefixExp };
	let typeInfo = typeInfoNone;
	if not prefixExp.expType {
	    self.error( "unknown prefix type: " .. getNodeKindName( prefixExp.kind ) );
	}
	if prefixExp.expType.getKind() == TypeInfoKindClass {
	    let classScope = self.typeInfo2Scope[ prefixExp.expType ];
	    let className = prefixExp.expType.txt;
	    if not classScope {
		self.error( "not found field: " .. className );
	    }
	    typeInfo = classScope.getTypeInfo( token.txt );
	    if not typeInfo {
		self.error( string.format(
		    "not found field typeInfo: %s.%s %s",
		    className, token.txt, classScope) );
	    }
	}
	exp = self.createNode( nodeKindRefField, firstToken.pos, typeInfo, info );
    }
    elseif mode == "symbol" {
	let typeInfo = self.scope.getTypeInfo( token.txt );
	if not typeInfo and token.txt == "self" {
	    let classInfo = self.classList[#self.classList];
	    typeInfo = classInfo.typeInfo;
	}
	if not typeInfo {
	    self.error( "not found type -- " .. token.txt );
	}
	exp = self.createNode( nodeKindExpRef, firstToken.pos, typeInfo, token );
    }
    elseif mode == "fn" {
	exp = self.analyzeDeclFunc( "pri", false, false, token, nil );
    }
    else {
	self.error( "illegal mode", mode );
    }

    return self.analyzeExpCont( firstToken, exp, skipFlag );
}

fn TransUnit.analyzeExpOp2( firstToken: stem, exp: stem ): stem {
    let nextToken = self.getToken();
    while true {
	if nextToken.txt == "@" {
	    let castType = self.analyzeRefType();
	    let info = { "exp": exp, "castType": castType };
	    exp = self.createNode( nodeKindExpCast, firstToken.pos, typeInfoNone, info );
	}
	elseif nextToken.kind == Parser.kind.Ope {
	    if Parser.isOp2( nextToken.txt ) {
		let exp2 = self.analyzeExp(
		    ( nextToken.txt == "and" ) or ( nextToken.txt == "*" ) );
		let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };
		exp = self.createNode( nodeKindExpOp2, firstToken.pos, typeInfoNone, info );
	    }
	    else {
		self.error( "illegal op" );
	    }
	}
	else {
	    self.pushback();
	    return exp;
	}
	nextToken = self.getToken();
    }
}

fn TransUnit.analyzeExp( skipOp2Flag: bool ): stem {
    let firstToken = self.getToken();
    let token = firstToken;
    let exp = nil;

    if token.kind == Parser.kind.Dlmt {
	if token.txt == "..." {
	    return self.createNode( nodeKindExpDDD, firstToken.pos, typeInfoNone, token );
	}

	if token.txt == '[' or token.txt == '[@' {
	    return self.analyzeListConst( token );
	}
	if token.txt == '{' {
	    return self.analyzeMapConst( token );
	}
	if token.txt == "(" {
	    exp = self.analyzeExp( false );
	    self.checkNextToken( ")" );
	    exp = self.createNode( nodeKindExpParen, firstToken.pos, typeInfoNone, exp );
	    exp = self.analyzeExpCont( firstToken, exp, false );
	}
    }

    if token.txt == "new" {
	let nextToken = self.getToken();
	exp = self.analyzeExpSymbol(
	    firstToken, nextToken, "symbol", nextToken, true );
      
	self.checkNextToken( "(" );
	nextToken = self.getToken();
	let argList: stem = nil;
	if nextToken.txt ~= ")" {
	    self.pushback();
	    argList = self.analyzeExpList();
	    self.checkNextToken( ")" );
	}	
	exp = self.createNode( nodeKindExpNew, firstToken.pos, exp.expType,
			       { "symbol": exp, "argList": argList } );
	exp = self.analyzeExpCont( firstToken, exp, false );
    }

    if token.kind == Parser.kind.Ope and Parser.isOp1( token.txt ) {
	'' 単項演算
	exp = self.analyzeExp( true );
	let typeInfo = typeInfoNone;
	if token.txt == "-" {
	    typeInfo = exp.expType;
	}	
	elseif token.txt == "#" {
	    typeInfo = typeInfoInt;
	}
	elseif token.txt == "not" {
	    typeInfo = typeInfoBool;
	}
	else {
	    self.error( "unknown op1" );
	}
	    
	exp = self.createNode( nodeKindExpOp1, firstToken.pos, typeInfo, 
			       { "op": token, "exp": exp } );   
	return self.analyzeExpOp2( firstToken, exp );
    }


    if token.kind == Parser.kind.Int {
	exp = self.createNode( nodeKindLiteralInt, firstToken.pos, typeInfoInt, 
			       { "token": token, "num": tonumber( token.txt ) } );
    }
    elseif token.kind == Parser.kind.Real {
	exp = self.createNode( nodeKindLiteralReal, firstToken.pos, typeInfoReal, 
			       { "token": token, "num": tonumber( token.txt ) } );
    }
    elseif token.kind == Parser.kind.Char {
	let num = 0;
	if #(token.txt) == 1 {
	    num = token.txt.byte( 1 );
	}
	else {
	    num = quotedChar2Code[ token.txt.sub( 2, 2 ) ];
	}
	exp = self.createNode( nodeKindLiteralChar, firstToken.pos, typeInfoChar, 
			       { "token": token, "num": num } );
    }
    elseif token.kind == Parser.kind.Str {
	let nextToken = self.getToken();
	let formatArgList = {};
	if nextToken.txt == "(" {
	    repeat {
		let arg = self.analyzeExp();
		table.insert( formatArgList, arg );
		nextToken = self.getToken();
	    } nextToken.txt ~= ",";
	    self.checkToken( nextToken, ")" );
	    nextToken = self.getToken();
	}
	exp = self.createNode( nodeKindLiteralString, firstToken.pos, typeInfoString, 
			       { "token": token, "argList": formatArgList } );
	token = nextToken;
	if token.txt == "[" {
	    exp = self.analyzeExpRefItem( token, exp );
	}
	else {
	    self.pushback();
	}
    }
    elseif token.txt == "fn" {
	exp = self.analyzeExpSymbol( firstToken, token, "fn", token, false );
    }
    elseif token.kind == Parser.kind.Symb {
	exp = self.analyzeExpSymbol( firstToken, token, "symbol", token, false );
    }
    elseif token.kind == Parser.kind.Type {
	exp = self.createNode( nodeKindExpRef, firstToken.pos, typeInfoNone, token );
    }
    elseif token.txt == "true" or token.txt == "false" {
	exp = self.createNode( nodeKindLiteralBool, firstToken.pos, typeInfoBool, token );
    }
    elseif token.txt == "nil" {
	exp = self.createNode( nodeKindLiteralNil, firstToken.pos, typeInfoNil, token );
    }

    if not exp {
	self.error( "illegal exp" );
    }

    if skipOp2Flag {
	return exp;
    }

    return self.analyzeExpOp2( firstToken, exp );
}

pub fn TransUnit.createAST( parser: str ): Map {

    self.registBuiltInScope();

    let rootInfo = {};
    rootInfo.childlen = {};
    let ast = self.createNode(
	nodeKindRoot, { "lineNo": 0, "column": 0 }, typeInfoNone, rootInfo );
    self.parser = parser;
    self.moduleName2Info = {};
    self.analyzeStatement( rootInfo.childlen );

    let token = self.getTokenNoErr();
    if token {
	error( string.format( "unknown:%d:%d:(%s) %s",
			      token.pos.lineNo, token.pos.column,
			      Parser.getKindTxt( token.kind ), token.txt ) );
    }

    return ast;
}

fn TransUnit.analyzeStatement( stmtList: stem[], termTxt: str ) {
    while true {
	let token = self.getTokenNoErr();
	if not token {
	    break;
	}

	let statement = self.analyzeDecl( "pri", false, token, token );

	if not statement {
	    if token.txt == termTxt {
		self.pushback();
		break;
	    }
	    elseif token.txt == "pub" or token.txt == "pro" or
		token.txt == "pri" or token.txt == "global" or token.txt == "static"
	    {
		let accessMode = (token.txt ~= "static") and token.txt or "pri";
		let staticFlag = (token.txt == "static");

		let nextToken = nil;
		if token.txt ~= "static" {
		    nextToken = self.getToken();
		}
		else {
		    nextToken = token;
		}
		statement = self.analyzeDecl( accessMode, staticFlag, token, nextToken );
	    }
	    elseif token.txt == "{" {
		self.pushback();
		statement = self.analyzeBlock( "{" );
	    }
	    elseif token.txt == "if" {
		statement = self.analyzeIf( token );
	    }
	    elseif token.txt == "while" {
		statement = self.analyzeWhile( token );
	    }
	    elseif token.txt == "repeat" {
		statement = self.analyzeRepeat( token );
	    }
	    elseif token.txt == "for" {
		statement = self.analyzeFor( token );
	    }
	    elseif token.txt == "apply" {
		statement = self.analyzeApply( token );
	    }
	    elseif token.txt == "foreach" {
		statement = self.analyzeForeach( token, false );
	    }
	    elseif token.txt == "forsort" {
		statement = self.analyzeForeach( token, true );
	    }
	    elseif token.txt == "return" {
		let expList = self.analyzeExpList();
		self.checkNextToken( ";" );
		statement = self.createNode(
		    nodeKindReturn, token.pos, typeInfoNone, expList );
	    }
	    elseif token.txt == "break" {
		self.checkNextToken( ";" );
		statement = self.createNode(
		    nodeKindBreak, token.pos, typeInfoNone, nil );}
	    elseif token.txt == "import" {
		statement = self.analyzeImport( token );
	    }
	    else {
		self.pushback();
		let exp = self.analyzeExp();
		self.checkNextToken( ";" );
		statement = self.createNode(
		    nodeKindStmtExp, token.pos, typeInfoNone, exp );
	    }
	}

	if not statement {
	    break;
	}
	table.insert( stmtList, statement );
    }
}
