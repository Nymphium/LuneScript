import lune.base.TransUnit;
import lune.base.Parser;
import lune.base.Util;

pub class Filter {
    pri let streamName: str;
    pri let stream: Util.outStream;
    pri let moduleName2Info: Map<str,stem>;
    pri let exeFlag: bool;
    pri let inMacro: bool;
    pri let indent: int;
    pri let curLineNo: int;
    '' クラス名 → TypeInfo
    pri let className2Scope: Map<str,TransUnit.Scope>;
    pri let className2TypeInfo: Map<str,TransUnit.TypeInfo>;
    '' クラス名 → Member Node List
    pri let className2MemberList: Map<str,TransUnit.Node[]>;
    '' public 変数名 → 変数情報
    pri let pubVarName2InfoMap: Map<str,stem>;
    '' public 関数名 → 関数情報
    pri let pubFuncName2InfoMap: Map<str,stem>;
    pri let needIndent: bool;
    pri let macroDepth: int;
    pri let moduleTypeInfo: TransUnit.TypeInfo;
    
    fn __init( streamName: str, stream: Util.outStream,
               exeFlag: bool, inMacro: bool, moduleTypeInfo: TransUnit.TypeInfo )
    {
        self.macroDepth = 0;
        self.streamName = streamName;
        self.stream = stream;
        self.moduleName2Info = {};
        self.exeFlag = exeFlag;
        self.inMacro = inMacro;
        self.indent = 0;
        self.curLineNo = 1;
        self.className2Scope = {};
        self.className2TypeInfo = {};
        self.className2MemberList = {};
        self.pubVarName2InfoMap = {};
        self.pubFuncName2InfoMap = {};
        self.needIndent = false;
        self.moduleTypeInfo = moduleTypeInfo;
    }
}

let stepIndent = 2;

let builtInModuleSet = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
builtInModuleSet[ "_luneScript" ] = true;



fn Filter.write( txt: str ) {
    if self.needIndent {
        self.stream.write( string.rep( " ", self.indent ) );
        self.needIndent = false;
    }

    apply cr of string.gmatch( txt, "\n" ) {
        self.curLineNo = self.curLineNo + 1;
    }
    self.stream.write( txt );
}

fn Filter.setIndent( indent: int ) {
    self.indent = indent;
}

fn Filter.writeln( txt: str, baseIndent: int ) {
    self.write( txt );
    self.write( "\n" );
    self.needIndent = true;
    self.indent = baseIndent;
}

Filter[ TransUnit.nodeKind.None ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "-- none", baseIndent );
};

Filter[ TransUnit.nodeKind.Import ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    let module = node.modulePath;
    let moduleName = string.gsub( module, ".*%.", "" );
    ''let moduleInfo = require( module );
    let moduleInfo = true;
    self.moduleName2Info[ moduleName ] = moduleInfo;
    if self.exeFlag {
        self.writeln(
            "local %s = _luneScript.loadModule( '%s' )" ( moduleName, module),
            baseIndent );
    }
    else {
        self.writeln( "local %s = require( '%s' )" ( moduleName, module ),
                      baseIndent );
    }
};

Filter[ TransUnit.nodeKind.Root ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "--%s" ( self.streamName ), baseIndent );
    self.writeln( "local moduleObj = {}", baseIndent );

    let rootNode:TransUnit.RootNode = node;

    let children:TransUnit.Node[] = rootNode.get_children();

    let typeId2ClassMap = rootNode.get_typeId2ClassMap();

    foreach child in children {
        TransUnit.nodeFilter( child, self, node, baseIndent );
        self.writeln( "", baseIndent );
    }

    self.writeln( "----- meta -----", baseIndent );

    let typeId2TypeInfo: Map<int,TransUnit.TypeInfo> = {};
    let typeId2UseFlag: Map<int,bool> = {};
    let pickupClassMap: Map<str,TransUnit.NamespaceInfo> = {};

    '' 公開される型情報を typeId2TypeInfo にピックアップする
    fn pickupTypeId( typeInfo: TransUnit.TypeInfo, forceFlag: bool ) {
        if typeInfo {
            if typeInfo.get_typeId() == TransUnit.rootTypeId {
                return;
            }
            if not forceFlag and typeInfo.get_accessMode() ~= "pub" {
                return;
            }
            if typeId2TypeInfo[ typeInfo.get_typeId() ] {
                return;
            }
            
            typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
	    if typeInfo.get_nilable() {
		pickupTypeId( typeInfo.get_orgTypeInfo() );
	    }
	    else {
                let parentInfo = typeInfo.get_parentInfo();
                pickupTypeId( parentInfo );

                let baseInfo = typeInfo.get_baseTypeInfo();
                if baseInfo {
                    pickupTypeId( baseInfo );
                }
                
		let typeInfoList: TransUnit.TypeInfo[] = typeInfo.get_itemTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo );
		    }
                }
		typeInfoList = typeInfo.get_retTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo );
		    }
                }
		typeInfoList = typeInfo.get_children();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        if itemTypeInfo.get_kind() == TransUnit.TypeInfoKindClass or
                            itemTypeInfo.get_kind() == TransUnit.TypeInfoKindFunc or
                            itemTypeInfo.get_kind() == TransUnit.TypeInfoKindMethod
                        {                       
                            pickupTypeId( itemTypeInfo );
                        }
		    }
                }
	    }
        }
    }



    foreach namespaceInfo in typeId2ClassMap {
        if namespaceInfo.typeInfo.get_accessMode() == "pub" {
            pickupClassMap[ namespaceInfo.name ] = namespaceInfo;
        }
    }
    

    

    self.writeln( "local _className2InfoMap = {}", baseIndent );
    self.writeln(
        "moduleObj._className2InfoMap = _className2InfoMap", baseIndent );

    forsort scope, className in self.className2Scope {
        self.writeln( "do", baseIndent + stepIndent );
        self.writeln( "local _classInfo%s = {}" (className), baseIndent + stepIndent );
        self.writeln( "_className2InfoMap.%s = _classInfo%s" (className, className),
                      baseIndent + stepIndent );

        let classTypeInfo = self.className2TypeInfo[ className ];
        pickupTypeId( classTypeInfo );
        pickupClassMap[ className ] = nil;
        
       foreach memberNode in self.className2MemberList[ className ] {
            let memberInfo = memberNode.get_info();
            if memberInfo.accessMode == "pub" {
                let memberName = memberInfo.name.txt;
                let memberTypeInfo:TransUnit.TypeInfo = memberNode.get_expType();
                self.writeln( "_classInfo%s.%s = {" ( className, memberName ),
                              baseIndent + stepIndent );
                self.writeln(
                    "  name='%s', staticFlag = %s, " ( memberName,
                                                       memberInfo.staticFlag ) ..
                    "accessMode = '%s', methodFlag = false, typeId = %d }"
                    ( memberInfo.accessMode,
                      memberTypeInfo.get_typeId() ),
                    baseIndent + stepIndent );
            }
        }
        
        self.writeln( "end", baseIndent );
   }


    forsort namespaceInfo, className in pickupClassMap {
        let scope = namespaceInfo.scope;

        if not TransUnit.isBuiltin( namespaceInfo.typeInfo.get_typeId()) {
            self.writeln( "do", baseIndent + stepIndent );
            self.writeln( "local _classInfo%s = {}"
                          (className), baseIndent + stepIndent );
            self.writeln( "_className2InfoMap.%s = _classInfo%s"
                          (className, className), baseIndent + stepIndent );

            pickupTypeId( namespaceInfo.typeInfo );

            forsort typeInfo, fieldName in scope.get_symbol2TypeInfoMap() {
                if typeInfo.get_kind() ~= TransUnit.TypeInfoKindMethod
                {
                    if typeInfo.get_accessMode() == "pub" {
                        self.writeln( "_classInfo%s.%s = {" ( className, fieldName ),
                                      baseIndent + stepIndent );
                        self.writeln(
                            "  name='%s', staticFlag = %s, "
                            ( fieldName,  typeInfo.get_staticFlag() ) ..
                            "accessMode = '%s', methodFlag = false, typeId = %d }"
                            ( typeInfo.get_accessMode(), typeInfo.get_typeId() ),
                            baseIndent + stepIndent );
                    }
                }
            }
            self.writeln( "end", baseIndent );
        }
    }
    


    self.writeln( "local _varName2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._varName2InfoMap = _varName2InfoMap", baseIndent );

    forsort varInfo, varName in self.pubVarName2InfoMap {
        self.writeln( string.format( "_varName2InfoMap.%s = {", varName ),
                      baseIndent );
        self.writeln(
            "  name='%s', accessMode = '%s', typeId = %d }"
            ( varName, varInfo[ "accessMode" ],
              (varInfo[ "typeInfo" ]@TransUnit.TypeInfo).get_typeId() ),
            baseIndent );
        pickupTypeId( varInfo[ "typeInfo" ], true );
    }

    forsort funcInfo, funcName in self.pubFuncName2InfoMap {
        pickupTypeId( funcInfo[ "typeInfo" ] );
    }

    

    self.writeln( "local _typeInfoList = {}", baseIndent );
    self.writeln( "moduleObj._typeInfoList = _typeInfoList", baseIndent );
    let listIndex = 1;

    let wroteTypeIdSet:Map<int,bool> = {};
    fn outputTypeInfo( typeInfo: TransUnit.TypeInfo ) {
        let typeId = typeInfo.get_typeId();
        if wroteTypeIdSet[ typeId ] {
            return;
        }
        wroteTypeIdSet[ typeId ] = true;
        if typeId2TypeInfo[ typeId ] and not TransUnit.isBuiltin( typeId )
        {               
            self.write( "_typeInfoList[%d] = " (listIndex) );
            listIndex = listIndex + 1;
            typeInfo.serialize( self );
        }
    }
    
    forsort typeInfo, typeId in typeId2TypeInfo {
        outputTypeInfo( typeInfo );
    }

    self.writeln( "----- meta -----", baseIndent );


    self.writeln( "return moduleObj", baseIndent );
};

Filter[ TransUnit.nodeKind.Block ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    let word = "";
    if node.blockKind == "if" or node.blockKind == "elseif" {
        word = "then";
    }
    elseif node.blockKind == "else" {
        word = "";
    }
    elseif node.blockKind == "while" {
        word = "do";
    }
    elseif node.blockKind == "repeat" {
        word = "";
    }
    elseif node.blockKind == "for" {
        word = "do";
    }
    elseif node.blockKind == "apply" {
        word = "do";
    }
    elseif node.blockKind == "foreach" {
        word = "do";
    }
    elseif node.blockKind == "macro" {
        word = "";
    }
    elseif node.blockKind == "func" {
        word = "";
    }
    elseif node.blockKind == "default" {
        word = "";
    }
    elseif node.blockKind == "{" {
        word = "do";
    }
    elseif node.blockKind == "macro" {
        word = "";
    }
    self.writeln( word, baseIndent + stepIndent );
    let stmtList:TransUnit.Node[] = node.stmtList;
    foreach statement in stmtList {
        TransUnit.nodeFilter( statement, self, node, baseIndent + stepIndent );
        self.writeln( "", baseIndent + stepIndent );
    }

    self.setIndent( baseIndent ) ;
    if node.blockKind == "{" {
        self.write( "end", baseIndent );
    }
};

Filter[ TransUnit.nodeKind.StmtExp ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
};

Filter[ TransUnit.nodeKind.DeclClass ] =
    fn( self: Filter, node: TransUnit.Node, parent:stem, baseIndent:int )
{
    let nodeInfo = node@TransUnit.DeclClassNode;
    let classNameToken = nodeInfo.get_name()@Parser.Token;
    let className = classNameToken.txt;

    if nodeInfo.get_accessMode() == "pub" {
        self.className2Scope[ className ] = nodeInfo.get_scope();
        self.className2TypeInfo[ className ] = node.get_expType();
    }
    self.className2MemberList[ className ] = nodeInfo.get_memberList();

    self.writeln( string.format( "local %s = {}", className ), baseIndent );

    let baseInfo: TransUnit.TypeInfo = node.get_expType().get_baseTypeInfo();
    if baseInfo {
        self.writeln(
            "setmetatable( %s, { __index = %s } )"
            ( className, baseInfo.getTxt() ), baseIndent );
    }
    
    if nodeInfo.get_accessMode() == "pub" {
        self.writeln( string.format( "moduleObj.%s = %s", className, className ),
                      baseIndent );
    }
    let hasConstrFlag = false;
    let memberList: TransUnit.Node[] = {};
    let fieldList: Map<str,int> = nodeInfo.get_fieldList();
    let outerMethodSet: Map<str,bool> = nodeInfo.get_outerMethodSet();
    foreach field in fieldList {
        let ignoreFlag = false;
        if field[ "kind" ] == TransUnit.nodeKind.DeclConstr {
            hasConstrFlag = true;
        }
        if field[ "kind" ] == TransUnit.nodeKind.DeclMember {
            table.insert( memberList, field );
        }
        if field[ "kind" ] == TransUnit.nodeKind.DeclMethod {
            let methodNode = field@TransUnit.DeclMethodNode;
            let declInfo = methodNode.get_declInfo();
            let methodNameToken = declInfo.get_name()@Parser.Token;
            if outerMethodSet[ methodNameToken.txt ] {
                ignoreFlag = true;
            }
        }

        if ( not ignoreFlag ) {
            TransUnit.nodeFilter( field, self, node, baseIndent );
        }
    }
    if not hasConstrFlag {
        let argTxt = "";
        foreach member, index in memberList {
            if index > 1 {
                argTxt = argTxt .. ", ";
            }
            argTxt = argTxt .. member[ "info" ].name.txt;
        }

        self.writeln( ```
function %s.new( %s )
  local obj = {}
  setmetatable( obj, { __index = %s } )
  if obj.__init then
    obj:__init( %s )
  end
  return obj
end
function %s:__init( %s )
            ``` ( className, argTxt, className, argTxt, className, argTxt ),
            baseIndent );
        foreach member in memberList {
            let memberName = member[ "info" ].name.txt;
            self.writeln( string.format( "self.%s = %s", memberName, memberName ),
                          baseIndent + stepIndent);         
        }
        self.writeln( 'end', baseIndent );
    }

    '' accessor
    let scope = nodeInfo.get_scope()@TransUnit.Scope;
    foreach memberNode in nodeInfo.get_memberList() {
        ''let methodNodeInfo = memberNode@TransUnit.DeclMemberNode;
        let memberNameToken = memberNode.get_name()@Parser.Token;
        let memberName = memberNameToken.txt;
        let getterName = "get_" .. memberName;
        let typeInfo:TransUnit.TypeInfo = scope.getTypeInfo( getterName );
        let autoFlag = not typeInfo or typeInfo.get_autoFlag();
        if memberNode.get_getterMode() ~= "none" and autoFlag
        {       
            self.writeln( ```
function %s:%s()
   return self.%s
end``` ( className, getterName, memberName ), baseIndent );
        }
        let setterName = "set_" .. memberName;
        typeInfo = scope.getTypeInfo( setterName );
        if memberNode.get_setterMode() ~= "none" and autoFlag
        {       
            self.writeln( ```
function %s:%s()
   return self.%s
end``` ( className, setterName, memberName ), baseIndent );
        }
    }
};

Filter[ TransUnit.nodeKind.DeclMember ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    '' dump( baseIndent, node, node.info.name.txt )
    '' node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};



Filter[ TransUnit.nodeKind.ExpMacroExp ] = 
    fn( self: Filter, node: TransUnit.ExpMacroExpNode, parent:stem, baseIndent:int )
{
    let stmtList = node.get_stmtList();
    if  stmtList {
        foreach stmt in stmtList {
            TransUnit.nodeFilter( stmt, self, node, baseIndent );
            self.writeln( "", baseIndent );
        }
    }
};

Filter[ TransUnit.nodeKind.DeclMacro ] = 
    fn( self: Filter, node: TransUnit.DeclMacroNode, parent:stem, baseIndent:int )
{
    if self.inMacro {
        let nodeInfo = node.get_declInfo();
        let name:Parser.Token = nodeInfo.get_name();
        
        self.write( "local function %s(" ( name.txt ) );
        '' self.write( "local function %s(" ( name.txt ) );

        let argTxt = "";
        foreach arg, index in nodeInfo.get_argList()@TransUnit.Node[] {
            if index > 1 {
                self.write( ", " );
                argTxt = argTxt .. ", ";
            }   
            TransUnit.nodeFilter( arg, self, node, baseIndent );
            argTxt = argTxt .. arg[ "info" ].name.txt;
        }

        self.writeln( ")", baseIndent );

        self.writeln( "local macroVar = {}", baseIndent );
        self.writeln( "macroVar._names = {}", baseIndent );

        self.macroDepth = self.macroDepth + 1;

        if nodeInfo.get_ast() {
            TransUnit.nodeFilter( nodeInfo.get_ast(), self, node, baseIndent );
        }
        
        self.macroDepth = self.macroDepth - 1;
        
        self.writeln( "", baseIndent );
        self.writeln( "return macroVar", baseIndent );
        self.writeln( "end", baseIndent );
        self.writeln( "return %s" ( name.txt ), baseIndent );
    }
};

Filter[ TransUnit.nodeKind.ExpMacroStat ] = 
    fn( self: Filter, node: TransUnit.ExpMacroStatNode, parent:stem, baseIndent:int )
{
    foreach token, index in node.get_expStrList() {
        if index ~= 1 {
            self.write( '..' );
        }
        
        TransUnit.nodeFilter( token, self, node, baseIndent );
    }
};


Filter[ TransUnit.nodeKind.ExpNew ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.symbol,  self, node, baseIndent );
    self.write( ".new(" );
    if node.argList {
        TransUnit.nodeFilter( node.argList,  self, node, baseIndent );
    }
    self.write( ")" );
};

Filter[ TransUnit.nodeKind.DeclConstr ] =
    fn( self: Filter, node: TransUnit.DeclConstrNode, parent:stem, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let classNameToken = declInfo.get_className()@Parser.Token;
    let className = classNameToken.txt;
    self.write( string.format( "function %s.new( ", className ) );

    let argTxt = "";
    let argList: TransUnit.Node[] = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
            argTxt = argTxt .. ", ";
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
        argTxt = argTxt .. arg[ "info" ].name.txt;
    }
    self.writeln( " )", baseIndent + stepIndent );
    self.writeln( "local obj = {}", baseIndent + stepIndent );
    self.writeln( string.format( "setmetatable( obj, { __index = %s } )", className ),
                  baseIndent + stepIndent );
    self.writeln( string.format( "if obj.__init then obj:__init( %s ); end",
                                 argTxt ), baseIndent );
    self.writeln( "return obj", baseIndent );
    self.writeln( "end", baseIndent );


    '' foreach refType, index in declInfo.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
    TransUnit.nodeFilter( declInfo.get_body(),  self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


Filter[ TransUnit.nodeKind.ExpCallSuper ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    let typeInfo:TransUnit.TypeInfo = node.superType;
    self.write( "%s.__init( self, " ( typeInfo.getTxt() ) );

    if node.expList {
        TransUnit.nodeFilter( node.expList, self, node, baseIndent );
    }
    self.writeln( ")", baseIndent );
};


Filter[ TransUnit.nodeKind.DeclMethod ] =
    fn( self: Filter, node: TransUnit.DeclMethodNode, parent:stem, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let delimit = ":";
    if declInfo.get_staticFlag() {
        delimit = ".";
    }
    let methodNodeToken = declInfo.get_name()@Parser.Token;
    let methodName = methodNodeToken.txt;
    let classNameToken = declInfo.get_className()@Parser.Token;
    self.write( "function %s%s%s( "
                ( classNameToken.txt, delimit, methodName ) );

    let argList: TransUnit.Node[] = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in declInfo.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    TransUnit.nodeFilter( declInfo.get_body(), self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


Filter[ TransUnit.nodeKind.DeclVar ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    if node.info.accessMode ~= "global" {
        self.write( "local " );
    }

    let varName = "";
    let varList: stem[] = node.info.varList;
    foreach var, index in varList  {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var[ "name" ].txt );
    }

    if node.info.expList {
        self.write( " = " );
        TransUnit.nodeFilter( node.info.expList, self, node, baseIndent );
    }

    if node.info.unwrap {
	self.writeln( "", baseIndent );
	self.write( "if " );
	foreach var, index in varList {
            if index > 1 {
		self.write( " or " );
            }   
	    self.write( " not " .. var[ "name" ].txt );
	}
	self.write( " then" );
	TransUnit.nodeFilter( node.info.unwrap, self, node, baseIndent );
	self.writeln( "end", baseIndent );
    }

    if node.info.accessMode == "pub" {
        self.writeln( "", baseIndent );
        let varList:stem[] = node.info.varList;
        foreach var, index in varList {
            let name: str = var[ "name" ].txt;
            self.writeln( "moduleObj.%s = %s" ( name, name ),
                          baseIndent );
            self.pubVarName2InfoMap[ name ] =  {
                "funcFlag": false, "staticFlag": node.info.staticFlag,
                "accessMode": node.info.accessMode,
                "typeInfo": node.info.typeInfoList[ index ]
            };
        }
    }

    if self.macroDepth > 0 {
        self.writeln( "", baseIndent );
	foreach var, index in varList {
            let varName = var[ "name" ].txt;
            self.writeln( "table.insert( macroVar._names, '%s' )" ( varName ),
                          baseIndent );
	    self.writeln( "macroVar.%s = %s" ( varName, varName ), baseIndent );
	}
    }
};

Filter[ TransUnit.nodeKind.DeclArg ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%s", node.name.txt ) );

    '' TransUnit.nodeFilter( '' node.info.argType,  self, node, baseIndent )
};

Filter[ TransUnit.nodeKind.DeclArgDDD ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "..." );
};

Filter[ TransUnit.nodeKind.ExpDDD ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "..." );
};

Filter[ TransUnit.nodeKind.DeclFunc ] =
    fn( self: Filter, node: TransUnit.DeclFuncNode, parent:stem, baseIndent:int )
{
    let nodeInfo = node.get_declInfo();
    let nameToken:Parser.Token = nodeInfo.get_name();
    let name = nameToken and nameToken.txt or "";
    let letTxt = "";
    if nodeInfo.get_accessMode() ~= "global" and #name ~= 0 {
        letTxt = "local ";
    }
    self.write( string.format( "%sfunction %s( ", letTxt, name ) );

    let argList: stem[] = nodeInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in nodeInfo.get_retTypeList() {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    TransUnit.nodeFilter( nodeInfo.get_body(),  self, node, baseIndent );
    self.writeln( "end", baseIndent );

    ''if nodeInfo.get_accessMode() == "pub" {
    let expType: TransUnit.TypeInfo = node.get_expType();
    if expType.get_accessMode() == "pub" {
        self.write( "moduleObj.%s = %s" ( name, name ) );

        self.pubFuncName2InfoMap[ name ] = {
            "funcFlag": true, "accessMode": nodeInfo.get_accessMode(),
            "typeInfo": node.get_expType()
        };
    }
};

Filter[ TransUnit.nodeKind.RefType ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( (node.refFlag and "&" or "") .. (node.mutFlag and "mut " or "") );
    TransUnit.nodeFilter( node.name,  self, node, baseIndent );
    if node.array == "array" {
        self.write( "[@]" );
    }
    elseif node.array == "list" {
        self.write( "[]" );
    }
};

Filter[ TransUnit.nodeKind.If ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    let valList:stem[] = node.stmtList;
    foreach val, index in valList {
        if index == 1 {
            self.write( "if " );
            TransUnit.nodeFilter( val[ "exp" ],  self, node, baseIndent );
        }
        elseif val[ "kind" ] == "elseif" {
            self.write( "elseif " );
            TransUnit.nodeFilter( val[ "exp" ],  self, node, baseIndent );
        }
        else {
            self.write( "else" );
        }
        self.write( " " );
        TransUnit.nodeFilter( val[ "block" ], self, node, baseIndent );
    }
    self.write( "end" );
};

Filter[ TransUnit.nodeKind.Switch ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "do", baseIndent + 2 );
    self.write( "local _switchExp = " );
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent + 2 );
    self.writeln( "", baseIndent + 2 );

    foreach caseInfo, index in node.caseList@stem[] {
        if index == 1 {
            self.write( "if " );
        }
        else {
            self.write( "elseif " );
        }
        let expList = caseInfo.expList;
        foreach expNode, index in expList.expList@stem[] {
            if index ~= 1 {
                self.write( " or " );
            }

            self.write( "_switchExp == " );
            TransUnit.nodeFilter( expNode, self, node, baseIndent + 2 );
        }   
        self.write( " then" );
        TransUnit.nodeFilter( caseInfo.block, self, node, baseIndent + 2 );
    }
    if node.default {
        self.write( "else " );
        TransUnit.nodeFilter( node.default, self, node, baseIndent + 2 );
    }
    self.writeln( "end", baseIndent );
    
    self.writeln( "end", baseIndent );
};

Filter[ TransUnit.nodeKind.While ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "while " );

    TransUnit.nodeFilter( node.exp, self, node, baseIndent );
    self.write( " " );
    TransUnit.nodeFilter( node.block, self, node, baseIndent );
    self.write( "end" );
};

Filter[ TransUnit.nodeKind.Repeat ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "repeat " );
    TransUnit.nodeFilter( node.block,  self, node, baseIndent );
    self.write( "until " );
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
};

Filter[ TransUnit.nodeKind.For ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "for %s = ", node.val.txt ) );
    TransUnit.nodeFilter( node.init,  self, node, baseIndent );
    self.write( ", " );
    TransUnit.nodeFilter( node.to,  self, node, baseIndent );
    if node.delta {
        self.write( ", " );
        TransUnit.nodeFilter( node.delta,  self, node, baseIndent );
    }
    self.write( " " );
    TransUnit.nodeFilter( node.block,  self, node, baseIndent );
    self.write( "end" );
};

Filter[ TransUnit.nodeKind.Apply ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "for " );
    let varList:stem[] = node.varList;
    foreach var, index in varList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var[ "txt" ] );
    }
    self.write( " in " );
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
    self.write( " " );
    TransUnit.nodeFilter( node.block,  self, node, baseIndent );
    self.write( "end" );
};

Filter[ TransUnit.nodeKind.Foreach ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "for " );
    self.write( node.key and node.key.txt or "__index" );
    self.write( ", " );
    self.write( node.val.txt );

    self.write( " in pairs( " );
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
    self.write( " ) " );
    TransUnit.nodeFilter( node.block,  self, node, baseIndent );
    self.write( "end" );
};

Filter[ TransUnit.nodeKind.Forsort ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "do", baseIndent + stepIndent );
    self.writeln( "local __sorted = {}", baseIndent + stepIndent );
    self.write( "local __map = " );
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent + stepIndent );
    self.writeln( "", baseIndent + stepIndent );
    self.writeln( "for __key in pairs( __map ) do", baseIndent + stepIndent * 2 );
    self.writeln( "table.insert( __sorted, __key )", baseIndent + stepIndent );
    self.writeln( "end", baseIndent + stepIndent );

    self.writeln( "table.sort( __sorted )", baseIndent + stepIndent );


    self.write( "for __index, " );
    let key = node.key and node.key.txt or "__key";
    self.write( key );
    self.writeln( " in ipairs( __sorted ) do", baseIndent + stepIndent * 2 );
    self.writeln( string.format( "%s = __map[ %s ]", node.val.txt, key ),
                  baseIndent + stepIndent * 2 );
    TransUnit.nodeFilter( node.block,  self, node, baseIndent + stepIndent * 2 );
    self.writeln( "end", baseIndent + stepIndent );
    self.writeln( "end", baseIndent );
    self.writeln( "end", baseIndent );
};


Filter[ TransUnit.nodeKind.ExpCall ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.func, self, node, baseIndent );
    self.write( "( " );
    if node.argList {
        TransUnit.nodeFilter( node.argList,  self, node, baseIndent );
    }
    self.write( " )" );
};


Filter[ TransUnit.nodeKind.ExpList ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    let expList: TransUnit.Node[] = node.expList;
    foreach exp, index in expList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( exp, self, node, baseIndent );
    }
};


Filter[ TransUnit.nodeKind.ExpOp1 ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    let op = node.op.txt;
    if op == ",,," or op == ",,,," {
        TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
    }
    elseif op == ",," {
        self.write( "_luneGetLocal( " );
        TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
        self.write( " )" );
    }
    else {
        if op == "not" {
            op = op .. " ";
        }   
        self.write( op );
        TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
    }
};

Filter[ TransUnit.nodeKind.ExpCast ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
    ''TransUnit.nodeFilter( '' node.info.castType,  self, node, baseIndent )
};


Filter[ TransUnit.nodeKind.ExpParen ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "(" );
    TransUnit.nodeFilter( node.exp,  self, node, baseIndent );
    self.write( " )" );
};

Filter[ TransUnit.nodeKind.ExpOp2 ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.exp1,  self, node, baseIndent );

    self.write( " " .. node.op.txt .. " " );

    TransUnit.nodeFilter( node.exp2,  self, node, baseIndent );
};

Filter[ TransUnit.nodeKind.ExpRef ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( node.token.txt );
};

Filter[ TransUnit.nodeKind.ExpRefItem ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    if node.val.kind == TransUnit.nodeKind.LiteralString {
        self.write( "string.byte( " );
        TransUnit.nodeFilter( node.val, self, node, baseIndent );
        self.write( ", " );
        TransUnit.nodeFilter( node.index, self, node, baseIndent );
        self.write( " )" );
    }
    else {
        TransUnit.nodeFilter( node.val, self, node, baseIndent );
        self.write( "[" );
        TransUnit.nodeFilter( node.index, self, node, baseIndent );
        self.write( "]" );
    }
};

Filter[ TransUnit.nodeKind.RefField ] =
    fn( self: Filter, node: TransUnit.RefFieldNode, parent:stem, baseIndent:int )
    {
        TransUnit.nodeFilter( node.get_prefix(),  self, node, baseIndent );
        let delimit = ".";
        if parent.kind == TransUnit.nodeKind.ExpCall {
            if node.get_expType().get_kind() == TransUnit.TypeInfoKindMethod {
                delimit = ":";
            }   
            else {
                delimit = ".";
            }   
        }
        let fieldToken = node.get_field()@Parser.Token;
        self.write( delimit .. fieldToken.txt );
    };  

Filter[ TransUnit.nodeKind.Return ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "return " );

    if node.expList {
        TransUnit.nodeFilter( node.expList,  self, node, baseIndent );
    }
};

Filter[ TransUnit.nodeKind.LiteralList ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );

    if node.expList {
        TransUnit.nodeFilter( node.expList, self, node, baseIndent );
    }

    self.write( "}" );
};

Filter[ TransUnit.nodeKind.LiteralMap ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );
    let pairList:stem[] = node.pairList;
    foreach pair, index in pairList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( "[" );
        TransUnit.nodeFilter( pair[ "key" ], self, node, baseIndent );
        self.write( "] = " );
        TransUnit.nodeFilter( pair[ "val" ], self, node, baseIndent );
        index = index + 1;
    }

    self.write( "}" );
};


Filter[ TransUnit.nodeKind.LiteralArray ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );

    if node.expList {
        TransUnit.nodeFilter( node.expList, self, node, baseIndent );
    }

    self.write( "}" );
};


Filter[ TransUnit.nodeKind.LiteralChar ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%g", node.num ) );
};

Filter[ TransUnit.nodeKind.LiteralInt ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%d", node.num ) );
};

Filter[ TransUnit.nodeKind.LiteralReal ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%s", node.num ) );
};

Filter[ TransUnit.nodeKind.LiteralString ] =
    fn( self: Filter, node: TransUnit.LiteralStringNode, parent:stem, baseIndent:int )
{
    let txt = (node.get_token()@Parser.Token).txt;
    if string.find( txt, '^```' ) {
        txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
    }
    let argList:TransUnit.Node[] = node.get_argList();
    if argList and #argList > 0 {
        self.write( string.format( 'string.format( %s, ', txt ) );
        let argList = node.get_argList();
        foreach val, index in argList {
            if index > 1 {
                self.write( ", " );
            }
            TransUnit.nodeFilter( val,  self, node, baseIndent );
        }
        self.write( ")" );
    }
    else {
        self.write( txt );
    }
};

Filter[ TransUnit.nodeKind.LiteralBool ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( node.token.txt );
};

Filter[ TransUnit.nodeKind.LiteralNil ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "nil" );
};

Filter[ TransUnit.nodeKind.Break ] =
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( "break" );
};
                    
Filter[ TransUnit.nodeKind.LiteralSymbol ] = 
    fn( self: Filter, node: stem, parent:stem, baseIndent:int )
{
    self.write( '%s' ( node.txt ) );
};


pub class MacroEvalImp extend TransUnit.MacroEval {
    pub override fn eval( node: TransUnit.Node ): Map<str,stem>
    {   
        let nodeInfo = node.get_info()@TransUnit.DeclMacroInfo;

        let oStream = new Util.memStream();
        let conv = new Filter( "macro", oStream, false, true );

        conv[ TransUnit.nodeKind.DeclMacro ]( conv, node, nil, 0 );

        ''Util.errorLog( 'hoooo: %s' (oStream.get_txt()) );
        
        let chunk, err = load( oStream.get_txt() );
        if err {
            error( err );
        }
        let mod: stem = chunk();
        if not mod {
            error( "macro load error" );
        }   
        return mod;
    }
}

