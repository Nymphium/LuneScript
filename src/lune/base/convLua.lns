import lune.base.TransUnit;

pub class filterObj {
    pri let streamName: str;
    pri let stream: stem;
    pri let moduleName2Info: Map<str,stem>;
    pri let exeFlag: bool;
    pri let indent: int;
    pri let curLineNo: int;
    '' クラス名 → TypeInfo
    pri let className2Scope: Map<str,TransUnit.Scope>;
    '' クラス名 → Member Node List
    pri let className2MemberList: Map<str,TransUnit.Node[]>;
    '' public 変数名 → 変数情報
    pri let pubVarName2InfoMap: Map<str,stem>;
    '' public 関数名 → 関数情報
    pri let pubFuncName2InfoMap: Map<str,stem>;
    pri let needIndent: bool;
    __init( streamName: str, stream: stem, exeFlag: bool ) {
        self.streamName = streamName;
        self.stream = stream;
        self.moduleName2Info = {};
        self.exeFlag = exeFlag;
        self.indent = 0;
        self.curLineNo = 1;
        self.className2Scope = {};
        self.className2MemberList = {};
        self.pubVarName2InfoMap = {};
        self.pubFuncName2InfoMap = {};
        self.needIndent = false;
        return self;
    }
}

let stepIndent = 2;

let builtInModuleSet = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
builtInModuleSet[ "_luneScript" ] = true;



fn filterObj.write( txt: str ) {
    if self.needIndent {
        self.stream.write( string.rep( " ", self.indent ) );
        self.needIndent = false;
    }

    apply cr of string.gmatch( txt, "\n" ) {
        self.curLineNo = self.curLineNo + 1;
    }
    self.stream.write( txt );
}

fn filterObj.setIndent( indent: int ) {
    self.indent = indent;
}

fn filterObj.writeln( txt: str, baseIndent: int ) {
    self.write( txt );
    self.write( "\n" );
    self.needIndent = true;
    self.indent = baseIndent;
}

filterObj[ TransUnit.nodeKind.None ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "-- none", baseIndent );
};

filterObj[ TransUnit.nodeKind.Import ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let module = node.info;
    let moduleName = string.gsub( module, ".*%.", "" );
    ''let moduleInfo = require( module );
    let moduleInfo = true;
    self.moduleName2Info[ moduleName ] = moduleInfo;
    if self.exeFlag {
        self.writeln(
            "local %s = _luneScript.loadModule( '%s' )" ( moduleName, module),
            baseIndent );
    }
    else {
        self.writeln( "local %s = require( '%s' )" ( moduleName, module ),
                      baseIndent );
    }
};

filterObj[ TransUnit.nodeKind.Root ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "--%s" ( self.streamName ), baseIndent );
    self.writeln( "local moduleObj = {}", baseIndent );

    let childlen:TransUnit.Node[] = node.info.childlen;
    foreach child in childlen {
        TransUnit.nodeFilter( child, self, node, baseIndent );
        self.writeln( "", baseIndent );
    }

    self.writeln( "----- meta -----", baseIndent );

    let typeId2TypeInfo: Map<int,TransUnit.TypeInfo> = {};
    let typeId2VarInfo: Map<int,stem> = {};

    '' 公開される型情報を typeId2TypeInfo にピックアップする
    fn pickupTypeId( typeInfo: TransUnit.TypeInfo ) {
        if not typeId2TypeInfo[ typeInfo.get_typeId() ] {
            typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
            let typeInfoList: TransUnit.TypeInfo[] = typeInfo.get_itemTypeInfoList();
            foreach itemTypeInfo in typeInfoList {
                pickupTypeId( itemTypeInfo );
            }
            typeInfoList = typeInfo.get_retTypeInfoList();
            foreach itemTypeInfo in typeInfoList {
                pickupTypeId( itemTypeInfo );
            }
        }
    }
    '' foreach scope in self.className2Scope {
    ''     let work = scope@Map<str,stem>;
    ''     foreach typeInfo in work.symbol2TypeInfoMap@Map<str,stem> {
    ''         if typeInfo.accessMode == "pub" and not typeInfo.externalFlag {
    ''             pickupTypeId( typeInfo );
    ''         }
    ''     }
    '' }



    self.writeln( "local _className2InfoMap = {}", baseIndent );
    self.writeln(
        "moduleObj._className2InfoMap = _className2InfoMap", baseIndent );

    forsort scope, className in self.className2Scope {
        self.writeln( "local _classInfo%s = {}" (className), baseIndent );
        self.writeln( "_className2InfoMap.%s = _classInfo%s" (className, className),
                      baseIndent );
        let work = scope;
        forsort typeInfo, declName in work.get_symbol2TypeInfoMap()@Map<str,stem> {
            if typeInfo.accessMode == "pub" and not typeInfo.externalFlag {
                if typeInfo.kind == TransUnit.TypeInfoKindFunc {
                    let fieldName = declName;
                    self.writeln( "_classInfo%s.%s = {" ( className, fieldName ),
                                  baseIndent );

                    self.writeln(
                        "  name='%s', staticFlag = %s, " ( fieldName,
                                                           typeInfo.staticFlag ) ..
                        "accessMode = '%s', methodFlag = true, typeId = %d }"
                        ( typeInfo.accessMode, typeInfo.get_typeId() ),
                        baseIndent );
                    pickupTypeId( typeInfo );
                }
            }
        }
        foreach memberNode in self.className2MemberList[ className ] {
            let memberInfo = memberNode.get_info();
            if memberInfo.accessMode == "pub" {
                let memberName = memberInfo.name.txt;
                let memberTypeInfo = memberName.expType;
                self.writeln( "_classInfo%s.%s = {" ( className, memberName ),
                              baseIndent );
                self.writeln(
                    "  name='%s', staticFlag = %s, " ( memberName,
                                                       memberInfo.staticFlag ) ..
                    "accessMode = '%s', methodFlag = false, typeId = %d }"
                    ( memberInfo.accessMode, memberNode.get_expType().typeId ),
                    baseIndent );
                pickupTypeId( memberInfo.refType );
            }
        }
    }


    self.writeln( "local _varName2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._varName2InfoMap = _varName2InfoMap", baseIndent );

    forsort varInfo, varName in self.pubVarName2InfoMap {
        self.writeln( string.format( "_varName2InfoMap.%s = {", varName ),
                      baseIndent );
        self.writeln(
            "  name='%s', accessMode = '%s', typeId = %d }"
            ( varName, varInfo[ "accessMode" ],
              varInfo[ "typeInfo" ].get_typeId() ),
            baseIndent );
        pickupTypeId( varInfo[ "typeInfo" ] );
    }

    self.writeln( "local _funcName2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._funcName2InfoMap = _funcName2InfoMap", baseIndent );

    forsort funcInfo, funcName in self.pubFuncName2InfoMap {
        self.writeln( string.format( "_funcName2InfoMap.%s = {", funcName ),
                      baseIndent );
        self.writeln(
            "  accessMode = '%s', typeId = %d }"
            ( funcInfo[ "accessMode" ], funcInfo[ "typeInfo" ].get_typeId() ),
            baseIndent );
        pickupTypeId( funcInfo[ "typeInfo" ] );
    }


    self.writeln( "moduleObj._typeInfoList = {", baseIndent );

    forsort typeInfo, typeId in typeId2TypeInfo {
        self.write( typeInfo.serialize() );
        self.writeln( "," , baseIndent + 2 );
    }
    self.writeln( "}" , baseIndent );



    self.writeln( "----- meta -----", baseIndent );


    self.writeln( "return moduleObj", baseIndent );
};

filterObj[ TransUnit.nodeKind.Block ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let word = "";
    if node.info.kind == "if" or node.info.kind == "elseif" {
        word = "then";
    }
    elseif node.info.kind == "else" {
        word = "";
    }
    elseif node.info.kind == "while" {
        word = "do";
    }
    elseif node.info.kind == "repeat" {
        word = "";
    }
    elseif node.info.kind == "for" {
        word = "do";
    }
    elseif node.info.kind == "apply" {
        word = "do";
    }
    elseif node.info.kind == "foreach" {
        word = "do";
    }
    elseif node.info.kind == "func" {
        word = "";
    }
    elseif node.info.kind == "default" {
        word = "";
    }
    elseif node.info.kind == "{" {
        word = "do";
    }
    self.writeln( word, baseIndent + stepIndent );
    let stmtList:TransUnit.Node[] = node.info.stmtList;
    foreach statement in stmtList {
        TransUnit.nodeFilter( statement, self, node, baseIndent + stepIndent );
        self.writeln( "", baseIndent + stepIndent );
    }

    self.setIndent( baseIndent ) ;
    if node.info.kind == "{" {
        self.write( "end", baseIndent );
    }
};

filterObj[ TransUnit.nodeKind.StmtExp ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.DeclClass ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let className = node.info.name.txt;
    self.className2Scope[ className ] = node.info.scope;
    self.className2MemberList[ className ] = node.info.memberList;

    self.writeln( string.format( "local %s = {}", className ), baseIndent );
    if node.info.accessMode == "pub" {
        self.writeln( string.format( "moduleObj.%s = %s", className, className ),
                      baseIndent );
    }
    let hasConstrFlag = false;
    let memberList: TransUnit.Node[] = {};
    let fieldList: Map<str,int> = node.info.fieldList;
    let outerMethodSet: Map<str,bool> = node.info.outerMethodSet;
    foreach field in fieldList {
        let ignoreFlag = false;
        if field[ "kind" ] == TransUnit.nodeKind.DeclConstr {
            hasConstrFlag = true;
        }
        if field[ "kind" ] == TransUnit.nodeKind.DeclMember {
            table.insert( memberList, field );
        }
        if field[ "kind" ] == TransUnit.nodeKind.DeclMethod {
            if outerMethodSet[ field.info.name.txt ] {
                ignoreFlag = true;
            }
        }

        if ( not ignoreFlag ) {
            TransUnit.nodeFilter( field, self, node, baseIndent );
        }
    }
    if not hasConstrFlag {
        let argTxt = "";
        foreach member, index in memberList {
            if index > 1 {
                argTxt = argTxt .. ", ";
            }
            argTxt = argTxt .. member[ "info" ].name.txt;
        }

        self.writeln( ```
function %s.new( %s )
  local obj = {}
  setmetatable( obj, { __index = %s } )
  return obj.__init and obj:__init( %s ) or nil;
end
function %s:__init( %s )
            ``` ( className, argTxt, className, argTxt, className, argTxt ),
            baseIndent );
        foreach member in memberList {
            let memberName = member[ "info" ].name.txt;
            self.writeln( string.format( "self.%s = %s", memberName, memberName ),
                          baseIndent + stepIndent);         
        }
        self.writeln( ```
  return self
end
            ```, baseIndent );
    }

    '' accessor
    let scope = node.info.scope@TransUnit.Scope;
    foreach memberNode in node.info.memberList@stem[] {
        let memberName = memberNode.info.name.txt;
        let getterName = "get_" .. memberName;
        let typeInfo = scope.getTypeInfo( getterName );
        if memberNode.info.getterMode ~= "none" and ( not typeInfo or typeInfo.autoFlag )
        {       
            self.writeln( ```
function %s:%s()
   return self.%s
end``` ( className, getterName, memberName ), baseIndent );
        }
        let setterName = "set_" .. memberName;
        typeInfo = scope.getTypeInfo( setterName );
        if memberNode.info.setterMode ~= "none" and ( not typeInfo or typeInfo.autoFlag )
        {       
            self.writeln( ```
function %s:%s()
   return self.%s
end``` ( className, setterName, memberName ), baseIndent );
        }
    }
};

filterObj[ TransUnit.nodeKind.DeclMember ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    '' dump( baseIndent, node, node.info.name.txt )
    '' node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};


filterObj[ TransUnit.nodeKind.ExpNew ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.symbol,  self, node, baseIndent );
    self.write( ".new(" );
    if node.info.argList {
        TransUnit.nodeFilter( node.info.argList,  self, node, baseIndent );
    }
    self.write( ")" );
};

filterObj[ TransUnit.nodeKind.DeclConstr ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let className = node.info.className.txt;
    self.write( string.format( "function %s.new( ", className ) );

    let argTxt = "";
    let argList: TransUnit.Node[] = node.info.argList;
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
            argTxt = argTxt .. ", ";
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
        argTxt = argTxt .. arg[ "info" ].name.txt;
    }
    self.writeln( " )", baseIndent + stepIndent );
    self.writeln( "local obj = {}", baseIndent + stepIndent );
    self.writeln( string.format( "setmetatable( obj, { __index = %s } )", className ),
                  baseIndent + stepIndent );
    self.writeln( string.format( "return obj.__init and obj:__init( %s ) or nil;",
                                 argTxt ), baseIndent );
    self.writeln( "end", baseIndent );


    '' foreach refType, index in node.info.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
    TransUnit.nodeFilter( node.info.body,  self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


filterObj[ TransUnit.nodeKind.DeclMethod ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let delimit = ":";
    if node.info.staticFlag {
        delimit = ".";
    }
    let methodName = node.info.name.txt;
    self.write( "function %s%s%s( "
                ( node.info.className.txt, delimit, methodName ) );

    let argList: TransUnit.Node[] = node.info.argList;
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in node.info.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    TransUnit.nodeFilter( node.info.body,  self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


filterObj[ TransUnit.nodeKind.DeclVar ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    if node.info.accessMode ~= "global" {
        self.write( "local " );
    }

    let varName = "";
    let varList: stem[] = node.info.varList;
    foreach var, index in varList  {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var[ "name" ].txt );
    }

    if node.info.expList {
        self.write( " = " );
        TransUnit.nodeFilter( node.info.expList,  self, node, baseIndent );
    }

    if node.info.accessMode == "pub" {
        self.writeln( "", baseIndent );
        let varList:stem[] = node.info.varList;
        foreach var, index in varList {
            let name: str = var[ "name" ].txt;
            self.writeln( "moduleObj.%s = %s" ( name, name ),
                          baseIndent );
            self.pubVarName2InfoMap[ name ] =  {
                "funcFlag": false, "staticFlag": node.info.staticFlag,
                "accessMode": node.info.accessMode,
                "typeInfo": node.info.typeInfoList[ index ]
            };
        }
    }
};

filterObj[ TransUnit.nodeKind.DeclArg ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%s", node.info.name.txt ) );

    '' TransUnit.nodeFilter( '' node.info.argType,  self, node, baseIndent )
};

filterObj[ TransUnit.nodeKind.DeclArgDDD ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "..." );
};

filterObj[ TransUnit.nodeKind.ExpDDD ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "..." );
};

filterObj[ TransUnit.nodeKind.DeclFunc ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let nameToken = node.info.name;
    let name = nameToken and nameToken.txt or "";
    let letTxt = "";
    if node.info.accessMode ~= "global" and #name ~= 0 {
        letTxt = "local ";
    }
    self.write( string.format( "%sfunction %s( ", letTxt, name ) );

    let argList: stem[] = node.info.argList;
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in node.info.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    TransUnit.nodeFilter( node.info.body,  self, node, baseIndent );
    self.writeln( "end", baseIndent );

    ''if node.info.accessMode == "pub" {
    if node.expType.get_accessMode() == "pub" {
        self.write( "moduleObj.%s = %s" ( name, name ) );

        self.pubFuncName2InfoMap[ name ] = {
            "funcFlag": true, "accessMode": node.info.accessMode,
            "typeInfo": node.expType
        };
    }
};

filterObj[ TransUnit.nodeKind.RefType ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write(
        (node.info.refFlag and "&" or "") .. (node.info.mutFlag and "mut " or "") );
    TransUnit.nodeFilter( node.info.name,  self, node, baseIndent );
    if node.info.array == "array" {
        self.write( "[@]" );
    }
    elseif node.info.array == "list" {
        self.write( "[]" );
    }
};

filterObj[ TransUnit.nodeKind.If ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let valList:stem[] = node.info;
    foreach val, index in valList {
        if index == 1 {
            self.write( "if " );
            TransUnit.nodeFilter( val[ "exp" ],  self, node, baseIndent );
        }
        elseif val[ "kind" ] == "elseif" {
            self.write( "elseif " );
            TransUnit.nodeFilter( val[ "exp" ],  self, node, baseIndent );
        }
        else {
            self.write( "else" );
        }
        self.write( " " );
        TransUnit.nodeFilter( val[ "block" ], self, node, baseIndent );
    }
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Switch ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "do", baseIndent + 2 );
    self.write( "local _switchExp = " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent + 2 );
    self.writeln( "", baseIndent + 2 );

    foreach caseInfo, index in node.info.caseList@stem[] {
        if index == 1 {
            self.write( "if " );
        }
        else {
            self.write( "elseif " );
        }
        let expList = caseInfo.expList;
        foreach expNode, index in expList.info@stem[] {
            if index ~= 1 {
                self.write( " or " );
            }

            self.write( "_switchExp == " );
            TransUnit.nodeFilter( expNode, self, node, baseIndent + 2 );
        }   
        self.write( " then" );
        TransUnit.nodeFilter( caseInfo.block, self, node, baseIndent + 2 );
    }
    if node.info.default {
        self.write( "else " );
        TransUnit.nodeFilter( node.info.default, self, node, baseIndent + 2 );
        self.writeln( "end", baseIndent );
    }
    
    self.writeln( "end", baseIndent );
};

filterObj[ TransUnit.nodeKind.While ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "while " );

    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
    self.write( " " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Repeat ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "repeat " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "until " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.For ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "for %s = ", node.info.val.txt ) );
    TransUnit.nodeFilter( node.info.init,  self, node, baseIndent );
    self.write( ", " );
    TransUnit.nodeFilter( node.info.to,  self, node, baseIndent );
    if node.info.delta {
        self.write( ", " );
        TransUnit.nodeFilter( node.info.delta,  self, node, baseIndent );
    }
    self.write( " " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Apply ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "for " );
    let varList:stem[] = node.info.varList;
    foreach var, index in varList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var[ "txt" ] );
    }
    self.write( " in " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
    self.write( " " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Foreach ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "for " );
    self.write( node.info.key and node.info.key.txt or "__index" );
    self.write( ", " );
    self.write( node.info.val.txt );

    self.write( " in pairs( " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
    self.write( " ) " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Forsort ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "do", baseIndent + stepIndent );
    self.writeln( "local __sorted = {}", baseIndent + stepIndent );
    self.write( "local __map = " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent + stepIndent );
    self.writeln( "", baseIndent + stepIndent );
    self.writeln( "for __key in pairs( __map ) do", baseIndent + stepIndent * 2 );
    self.writeln( "table.insert( __sorted, __key )", baseIndent + stepIndent );
    self.writeln( "end", baseIndent + stepIndent );

    self.writeln( "table.sort( __sorted )", baseIndent + stepIndent );


    self.write( "for __index, " );
    let key = node.info.key and node.info.key.txt or "__key";
    self.write( key );
    self.writeln( " in ipairs( __sorted ) do", baseIndent + stepIndent * 2 );
    self.writeln( string.format( "%s = __map[ %s ]", node.info.val.txt, key ),
                  baseIndent + stepIndent * 2 );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent + stepIndent * 2 );
    self.writeln( "end", baseIndent + stepIndent );
    self.writeln( "end", baseIndent );
    self.writeln( "end", baseIndent );
};


filterObj[ TransUnit.nodeKind.ExpCall ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.func,  self, node, baseIndent );
    self.write( "( " );
    if node.info.argList {
        TransUnit.nodeFilter( node.info.argList,  self, node, baseIndent );
    }
    self.write( " )" );
};


filterObj[ TransUnit.nodeKind.ExpList ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let expList: TransUnit.Node[] = node.info;
    foreach exp, index in expList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( exp, self, node, baseIndent );
    }
};

filterObj[ TransUnit.nodeKind.ExpOp1 ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let op = node.info.op.txt;
    if op == "not" {
        op = op .. " ";
    }
    self.write( op );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.ExpCast ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info,  self, node, baseIndent );
    ''TransUnit.nodeFilter( '' node.info.castType,  self, node, baseIndent )
};


filterObj[ TransUnit.nodeKind.ExpParen ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "(" );
    TransUnit.nodeFilter( node.info,  self, node, baseIndent );
    self.write( " )" );
};

filterObj[ TransUnit.nodeKind.ExpOp2 ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.exp1,  self, node, baseIndent );

    self.write( " " .. node.info.op.txt .. " " );

    TransUnit.nodeFilter( node.info.exp2,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.ExpRef ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( node.info.txt );
};

filterObj[ TransUnit.nodeKind.ExpRefItem ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    if node.info.val.kind == TransUnit.nodeKind.LiteralString {
        self.write( "string.byte( " );
        TransUnit.nodeFilter( node.info.val, self, node, baseIndent );
        self.write( ", " );
        TransUnit.nodeFilter( node.info.index, self, node, baseIndent );
        self.write( " )" );
    }
    else {
        TransUnit.nodeFilter( node.info.val, self, node, baseIndent );
        self.write( "[" );
        TransUnit.nodeFilter( node.info.index, self, node, baseIndent );
        self.write( "]" );
    }
};

filterObj[ TransUnit.nodeKind.RefField ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.prefix,  self, node, baseIndent );
    let delimit = ".";
    if parent.kind == TransUnit.nodeKind.ExpCall {
        let prefixSymbol = node.info.prefix.info.txt;
        if node.expType.get_staticFlag() {
            delimit = ".";
        }
        else {
            delimit = ":";
        }
    }
    self.write( delimit .. node.info.field.txt );
};

filterObj[ TransUnit.nodeKind.Return ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "return " );

    TransUnit.nodeFilter( node.info,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.LiteralList ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );

    if node.info {
        TransUnit.nodeFilter( node.info, self, node, baseIndent );
    }

    self.write( "}" );
};

filterObj[ TransUnit.nodeKind.LiteralMap ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );
    let pairList:stem[] = node.info.pairList;
    foreach pair, index in pairList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( "[" );
        TransUnit.nodeFilter( pair[ "key" ], self, node, baseIndent );
        self.write( "] = " );
        TransUnit.nodeFilter( pair[ "val" ], self, node, baseIndent );
        index = index + 1;
    }

    self.write( "}" );
};


filterObj[ TransUnit.nodeKind.LiteralArray ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );

    if node.info {
        TransUnit.nodeFilter( node.info, self, node, baseIndent );
    }

    self.write( "}" );
};


filterObj[ TransUnit.nodeKind.LiteralChar ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%g", node.info.num ) );
};

filterObj[ TransUnit.nodeKind.LiteralInt ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%d", node.info.num ) );
};

filterObj[ TransUnit.nodeKind.LiteralReal ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%s", node.info.num ) );
};

filterObj[ TransUnit.nodeKind.LiteralString ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let txt = node.info.token.txt;
    if string.find( txt, '^```' ) {
        txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
    }
    if #node.info.argList > 0 {
        self.write( string.format( "string.format( %s, ", txt ) );
        let argList:stem[] = node.info.argList;
        foreach val, index in argList {
            if index > 1 {
                self.write( ", " );
            }
            TransUnit.nodeFilter( val,  self, node, baseIndent );
        }
        self.write( ")" );
    }
    else {
        self.write( txt );
    }
};

filterObj[ TransUnit.nodeKind.LiteralBool ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( node.info.txt );
};

filterObj[ TransUnit.nodeKind.LiteralNil ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "nil" );
};

filterObj[ TransUnit.nodeKind.Break ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "break" );
};
