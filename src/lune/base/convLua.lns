/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.TransUnit;
import lune.base.Util;

class VerInfo {
    let staticFlag: bool;
    let accessMode: str;
    let typeInfo: TransUnit.TypeInfo;
};

class FuncInfo {
    let accessMode: str;
    let typeInfo: TransUnit.TypeInfo;
}

pub class convFilter extend TransUnit.Filter {
    pri let streamName: str;
    pri let stream: Util.outStream;
    pri let moduleName2Info: Map<str,stem>;
    pri let convMode: str;
    pri let inMacro: bool;
    pri let indent: int;
    pri let curLineNo: int;
    // クラス名 → TypeInfo
    pri let className2Scope: Map<str,TransUnit.Scope>;
    pri let className2TypeInfo: Map<str,TransUnit.TypeInfo>;
    // クラス名 → Member Node List
    pri let className2MemberList: Map<str,TransUnit.DeclMemberNode[]>;
    // public 変数名 → 変数情報
    pri let pubVarName2InfoMap: Map<str,VerInfo>;
    // public 関数名 → 関数情報
    pri let pubFuncName2InfoMap: Map<str,FuncInfo>;
    pri let needIndent: bool;
    pri let macroDepth: int;
    pri let moduleTypeInfo: TransUnit.TypeInfo;
    
    fn __init( streamName: str, stream: Util.outStream,
               convMode: str, inMacro: bool, moduleTypeInfo: TransUnit.TypeInfo )
    {
        //Util.errorLog( "__init: %s" (mode) );
        self.macroDepth = 0;
        self.streamName = streamName;
        self.stream = stream;
        self.moduleName2Info = {};
        self.convMode = convMode;
        self.inMacro = inMacro;
        self.indent = 0;
        self.curLineNo = 1;
        self.className2Scope = {};
        self.className2TypeInfo = {};
        self.className2MemberList = {};
        self.pubVarName2InfoMap = {};
        self.pubFuncName2InfoMap = {};
        self.needIndent = false;
        self.moduleTypeInfo = moduleTypeInfo;
    }
}

fn filter( node: TransUnit.Node, filter: convFilter,
           parent: TransUnit.Node, baseIndent:int )
{
    node.processFilter( filter, parent, baseIndent );
}

let stepIndent = 2;

let builtInModuleSet:Map<str,bool> = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
builtInModuleSet[ "_luneScript" ] = true;

fn convFilter.write( txt: str ) {
    if self.needIndent {
        self.stream.write( string.rep( " ", self.indent ) );
        self.needIndent = false;
    }

    apply cr of string.gmatch( txt, "\n" ) {
        self.curLineNo = self.curLineNo + 1;
    }
    self.stream.write( txt );
}

fn convFilter.setIndent( indent: int ) {
    self.indent = indent;
}

fn convFilter.writeln( txt: str, baseIndent: int ) {
    self.write( txt );
    self.write( "\n" );
    self.needIndent = true;
    self.indent = baseIndent;
}

pub override fn convFilter.processNone( node: NoneNode, parent: Node, baseIndent:int )
{
    self.writeln( "-- none", baseIndent );
};

pub override fn convFilter.processImport( 
    node: ImportNode, parent: Node, baseIndent:int )
{
    let module = node.get_modulePath();
    let moduleName = string.gsub( module, ".*%.", "" );
    //let moduleInfo = require( module );
    let moduleInfo = true;
    self.moduleName2Info[ moduleName ] = moduleInfo;
    if self.convMode == "exe" or self.convMode == "ast"  {
        self.writeln(
            "local %s = _luneScript.loadModule( '%s' )" ( moduleName, module),
            baseIndent );
    }
    else {
        self.writeln( "local %s = require( '%s' )" ( moduleName, module ),
                      baseIndent );
    }
};

fn convFilter.outputMeta( node: RootNode, baseIndent: int )
{
    switch self.convMode {
        case "lua", "save" {
            return;
        }
    }
    
    self.writeln( "----- meta -----", baseIndent );

    let typeId2TypeInfo: Map<int,TransUnit.TypeInfo> = {};
    let typeId2UseFlag: Map<int,bool> = {};
    let pickupClassMap: Map<str,TransUnit.NamespaceInfo> = {};

    // 公開される型情報を typeId2TypeInfo にピックアップする
    fn pickupTypeId( typeInfo: TransUnit.TypeInfo, forceFlag: bool ) {
        if typeInfo {
            if typeInfo.get_typeId() == TransUnit.rootTypeId {
                return;
            }
            if not forceFlag and typeInfo.get_accessMode() ~= "pub" {
                return;
            }
            if typeId2TypeInfo[ typeInfo.get_typeId() ] {
                return;
            }
            
            typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
	    if typeInfo.get_nilable() {
		pickupTypeId( typeInfo.get_orgTypeInfo(), true );
	    }
	    else {
                let parentInfo = typeInfo.get_parentInfo();
                pickupTypeId( parentInfo, true );

                let baseInfo = typeInfo.get_baseTypeInfo();
                if baseInfo.$typeId ~= TransUnit.rootTypeId {
                    pickupTypeId( baseInfo, true );
                }
                
		let typeInfoList: TransUnit.TypeInfo[] = typeInfo.get_itemTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo, true );
		    }
                }
		typeInfoList = typeInfo.get_argTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo, true );
		    }
                }
		typeInfoList = typeInfo.get_retTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo, true );
		    }
                }
		typeInfoList = typeInfo.get_children();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        if itemTypeInfo.get_kind() == TransUnit.TypeInfoKindClass or
                            itemTypeInfo.get_kind() == TransUnit.TypeInfoKindFunc or
                            itemTypeInfo.get_kind() == TransUnit.TypeInfoKindMethod
                        {                       
                            pickupTypeId( itemTypeInfo, true );
                        }
		    }
                }

                pickupTypeId( typeInfo.get_nilableTypeInfo(), true );
	    }
        }
    }



    let typeId2ClassMap = node.get_typeId2ClassMap();
    foreach namespaceInfo in typeId2ClassMap {
        if namespaceInfo.typeInfo.get_accessMode() == "pub" {
            pickupClassMap[ namespaceInfo.name ] = namespaceInfo;
        }
    }


    self.writeln( "local _typeId2ClassInfoMap = {}", baseIndent );
    self.writeln( "moduleObj._typeId2ClassInfoMap = _typeId2ClassInfoMap",
                  baseIndent );
    self.writeln( "local _className2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._className2InfoMap = _className2InfoMap",
                  baseIndent );     

    forsort scope, className in self.className2Scope {
        let classTypeInfo = unwrap self.className2TypeInfo[ className ];
        let classTypeId = classTypeInfo.get_typeId();
        pickupTypeId( classTypeInfo );
        pickupClassMap[ className ] = nil;
        
        self.writeln( "do", baseIndent + stepIndent );
        self.writeln( "local _classInfo%d = {}" (classTypeId), baseIndent + stepIndent );
        self.writeln( "_className2InfoMap.%s = _classInfo%d" (className, classTypeId),
                      baseIndent + stepIndent );
        self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                      (classTypeId, classTypeId), baseIndent + stepIndent );

        
        foreach memberNode in unwrap self.className2MemberList[ className ] {
            if memberNode.$accessMode == "pub" {
                let memberName = memberNode.$name.txt;
                let memberTypeInfo:TransUnit.TypeInfo = memberNode.get_expType();
                self.writeln( "_classInfo%d.%s = {" ( classTypeId, memberName ),
                              baseIndent + stepIndent );
                self.writeln(
                    "  name='%s', staticFlag = %s, " ( memberName,
                                                       memberNode.$staticFlag ) ..
                    "accessMode = '%s', methodFlag = false, typeId = %d }"
                    ( memberNode.$accessMode,
                      memberTypeInfo.get_typeId() ),
                    baseIndent + stepIndent );
            }
        }
        
        self.writeln( "end", baseIndent );
    }


    forsort namespaceInfo, className in pickupClassMap {
        let scope = namespaceInfo.scope;
        let classTypeId = namespaceInfo.typeInfo.get_typeId();

        if not TransUnit.isBuiltin( classTypeId ) {
            self.writeln( "do", baseIndent + stepIndent );
            self.writeln( "local _classInfo%s = {}"
                          (classTypeId), baseIndent + stepIndent );
            self.writeln( "_className2InfoMap.%s = _classInfo%d"
                          (className, classTypeId), baseIndent + stepIndent );
            self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                          ( classTypeId, classTypeId), baseIndent + stepIndent );
            

            pickupTypeId( namespaceInfo.typeInfo );

            forsort typeInfo, fieldName in scope.get_symbol2TypeInfoMap() {
                if typeInfo.get_kind() ~= TransUnit.TypeInfoKindMethod
                {
                    if typeInfo.get_accessMode() == "pub" {
                        self.writeln( "_classInfo%d.%s = {" ( classTypeId, fieldName ),
                                      baseIndent + stepIndent );
                        self.writeln(
                            "  name='%s', staticFlag = %s, "
                            ( fieldName,  typeInfo.get_staticFlag() ) ..
                            "accessMode = '%s', methodFlag = false, typeId = %d }"
                            ( typeInfo.get_accessMode(), typeInfo.get_typeId() ),
                            baseIndent + stepIndent );
                    }
                }
            }
            self.writeln( "end", baseIndent );
        }
    }
    


    self.writeln( "local _varName2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._varName2InfoMap = _varName2InfoMap", baseIndent );

    forsort varInfo, varName in self.pubVarName2InfoMap {
        self.writeln( string.format( "_varName2InfoMap.%s = {", varName ),
                      baseIndent );
        self.writeln(
            "  name='%s', accessMode = '%s', typeId = %d }"
            ( varName, varInfo.accessMode,
              varInfo.typeInfo.get_typeId() ),
            baseIndent );
        pickupTypeId( varInfo.typeInfo, true );
    }

    forsort funcInfo, funcName in self.pubFuncName2InfoMap {
        pickupTypeId( funcInfo.typeInfo );
    }

    

    self.writeln( "local _typeInfoList = {}", baseIndent );
    self.writeln( "moduleObj._typeInfoList = _typeInfoList", baseIndent );
    let listIndex = 1;

    let wroteTypeIdSet:Map<int,bool> = {};
    fn outputTypeInfo( typeInfo: TransUnit.TypeInfo ) {
        let typeId = typeInfo.get_typeId();
        if wroteTypeIdSet[ typeId ] {
            return;
        }
        wroteTypeIdSet[ typeId ] = true;
        if typeId2TypeInfo[ typeId ] and not TransUnit.isBuiltin( typeId )
        {               
            self.write( "_typeInfoList[%d] = " (listIndex) );
            listIndex = listIndex + 1;
            typeInfo.serialize( self@TransUnit.OutStream );
        }
    }
    
    forsort typeInfo, typeId in typeId2TypeInfo {
        outputTypeInfo( typeInfo );
    }

    self.writeln( "----- meta -----", baseIndent );
}

pub override fn convFilter.processRoot( 
    node: RootNode, parent: Node, baseIndent:int )
{
    self.writeln( "--%s" ( self.streamName ), baseIndent );
    self.writeln( "local moduleObj = {}", baseIndent );

    let children:TransUnit.Node[] = node.get_children();

    foreach child in children {
        filter( child, self, node, baseIndent );
        self.writeln( "", baseIndent );
    }

    self.outputMeta( node, baseIndent );

    self.writeln( "return moduleObj", baseIndent );
};

pub override fn convFilter.processBlock( 
    node: BlockNode, parent: Node, baseIndent:int )
{
    let word = "";
    if node.get_blockKind() == "if" or node.get_blockKind() == "elseif" {
        word = "then";
    }
    elseif node.get_blockKind() == "else" {
        word = "";
    }
    elseif node.get_blockKind() == "while" {
        word = "do";
    }
    elseif node.get_blockKind() == "repeat" {
        word = "";
    }
    elseif node.get_blockKind() == "for" {
        word = "do";
    }
    elseif node.get_blockKind() == "apply" {
        word = "do";
    }
    elseif node.get_blockKind() == "foreach" {
        word = "do";
    }
    elseif node.get_blockKind() == "macro" {
        word = "";
    }
    elseif node.get_blockKind() == "func" {
        word = "";
    }
    elseif node.get_blockKind() == "default" {
        word = "";
    }
    elseif node.get_blockKind() == "{" {
        word = "do";
    }
    elseif node.get_blockKind() == "macro" {
        word = "";
    }
     elseif node.get_blockKind() == "let!" {
        word = "";
    }
    elseif node.get_blockKind() == "if!" {
        word = "";
    }
    self.writeln( word, baseIndent + stepIndent );
    let stmtList = node.get_stmtList();
    foreach statement in stmtList {
        filter( statement, self, node, baseIndent + stepIndent );
        self.writeln( "", baseIndent + stepIndent );
    }

    self.setIndent( baseIndent ) ;
    if node.get_blockKind() == "{" {
        self.write( "end", baseIndent );
    }
};

pub override fn convFilter.processStmtExp( 
    node: StmtExpNode, parent: Node, baseIndent:int )
{
    filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processDeclClass( 
    node: DeclClassNode, parent: Node, baseIndent:int )
{
    let nodeInfo = node;
    let classNameToken = nodeInfo.get_name();
    let className = classNameToken.txt;

    if nodeInfo.get_accessMode() == "pub" {
        self.className2Scope[ className ] = nodeInfo.get_scope();
        self.className2TypeInfo[ className ] = node.get_expType();
    }
    self.className2MemberList[ className ] = nodeInfo.get_memberList();

    self.writeln( string.format( "local %s = {}", className ), baseIndent );

    let baseInfo = node.get_expType().get_baseTypeInfo();
    if baseInfo.get_typeId() ~= TransUnit.rootTypeId {
        self.writeln(
            "setmetatable( %s, { __index = %s } )"
            ( className, (unwrap baseInfo).getTxt() ), baseIndent );
    }
    
    if nodeInfo.get_accessMode() == "pub" {
        self.writeln( string.format( "moduleObj.%s = %s", className, className ),
                      baseIndent );
    }
    let hasConstrFlag = false;
    let memberList: TransUnit.DeclMemberNode[] = [];
    let fieldList: Node[] = nodeInfo.get_fieldList();
    let outerMethodSet: Map<str,bool> = nodeInfo.get_outerMethodSet();
    foreach field in fieldList {
        let ignoreFlag = false;
        if field.$kind == TransUnit.nodeKind.DeclConstr {
            hasConstrFlag = true;
        }
        if field.$kind == TransUnit.nodeKind.DeclMember {
            memberList.insert( field@DeclMemberNode );
        }
        if field.$kind == TransUnit.nodeKind.DeclMethod {
            let methodNode = field@DeclMethodNode;
            let declInfo = methodNode.get_declInfo();
            let methodNameToken = declInfo.get_name();
            if outerMethodSet[ (unwrap methodNameToken).txt ] {
                ignoreFlag = true;
            }
        }

        if ( not ignoreFlag ) {
            filter( field, self, node, baseIndent );
        }
    }
    if not hasConstrFlag {
        let argTxt = "";
        foreach member, index in memberList {
            if index > 1 {
                argTxt = argTxt .. ", ";
            }
            argTxt = argTxt .. member.$name.txt;
        }

        self.writeln( ```
function %s.new( %s )
  local obj = {}
  setmetatable( obj, { __index = %s } )
  if obj.__init then
    obj:__init( %s )
  end        
  return obj 
 end         
function %s:__init( %s ) 
            ```
            ( className, argTxt, className, argTxt, className, argTxt ),
                baseIndent );
        foreach member in memberList {
            let memberName = member.$name.txt;
            self.writeln( string.format( "self.%s = %s", memberName, memberName ),
                          baseIndent + stepIndent);         
        }
        self.writeln( 'end', baseIndent );
    }

    // accessor
    let scope = nodeInfo.get_scope();
    foreach memberNode in nodeInfo.get_memberList() {
        let memberNameToken = memberNode.get_name();
        let memberName = memberNameToken.txt;
        let getterName = "get_" .. memberName;
        let typeInfo = scope.getTypeInfo( getterName );
        let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
        if memberNode.get_getterMode() ~= "none" and autoFlag
        {       
            self.writeln( ```
function %s:%s()
  return self.%s
end``` ( className, getterName, memberName ), baseIndent );
        }
        let setterName = "set_" .. memberName;
        typeInfo = scope.getTypeInfo( setterName );
        autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
        if memberNode.get_setterMode() ~= "none" and autoFlag
        {       
            self.writeln( ```
function %s:%s( %s )
  self.%s = %s
end``` ( className, setterName, memberName, memberName, memberName ), baseIndent );
        }
    }
};

pub override fn convFilter.processDeclMember( 
    node: DeclMemberNode, parent: Node, baseIndent:int )
{
    // dump( baseIndent, node, node.info.name.txt )
    // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};



pub override fn convFilter.processExpMacroExp( 
    node: ExpMacroExpNode, parent: Node, baseIndent:int ) 
{
    let stmtList = node.get_stmtList();
    if  stmtList {
        foreach stmt in stmtList {
            filter( stmt, self, node, baseIndent );
            self.writeln( "", baseIndent );
        }
    }
};

pub override fn convFilter.processDeclMacro( 
    node: DeclMacroNode, parent: Node, baseIndent:int ) 
{
    if self.inMacro {
        let nodeInfo = node.get_declInfo();
        let name = nodeInfo.get_name();
        
        self.write( "local function %s(" ( name.txt ) );
        // self.write( "local function %s(" ( name.txt ) );

        let argTxt = "";
        foreach arg, index in nodeInfo.get_argList() {
            if index > 1 {
                self.write( ", " );
                argTxt = argTxt .. ", ";
            }   
            filter( arg, self, node, baseIndent );
            if arg.get_kind() == TransUnit.nodeKind.DeclArg {
                argTxt = argTxt .. (arg@DeclArgNode).$name.txt;
            }
            else {
                error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
            }
        }

        self.writeln( ")", baseIndent );

        self.writeln( "local macroVar = {}", baseIndent );
        self.writeln( "macroVar._names = {}", baseIndent );

        self.macroDepth = self.macroDepth + 1;

        if! nodeInfo.get_ast() {
            filter( _exp, self, node, baseIndent );
        }
        
        self.macroDepth = self.macroDepth - 1;
        
        self.writeln( "", baseIndent );
        self.writeln( "return macroVar", baseIndent );
        self.writeln( "end", baseIndent );
        self.writeln( "return %s" ( name.txt ), baseIndent );
    }
};

pub override fn convFilter.processExpMacroStat( 
    node: ExpMacroStatNode, parent: Node, baseIndent:int ) 
{
    foreach token, index in node.get_expStrList() {
        if index ~= 1 {
            self.write( '..' );
        }
        
        filter( token, self, node, baseIndent );
    }
};


pub override fn convFilter.processExpNew( 
    node: ExpNewNode, parent: Node, baseIndent:int )
{
    filter( node.get_symbol(),  self, node, baseIndent );
    self.write( ".new(" );
    if! node.get_argList() {
        filter( _exp,  self, node, baseIndent );
    }
    self.write( ")" );
};

pub override fn convFilter.processDeclConstr( 
    node: DeclConstrNode, parent: Node, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let classNameToken = unwrap declInfo.get_className();
    let className = classNameToken.txt;
    self.write( string.format( "function %s.new( ", className ) );

    let argTxt = "";
    let argList: TransUnit.Node[] = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
            argTxt = argTxt .. ", ";
        }
        filter( arg, self, node, baseIndent );

        if arg.get_kind() == TransUnit.nodeKind.DeclArg {
            argTxt = argTxt .. (arg@DeclArgNode).$name.txt;
        }
        else {
            let name = unwrap node.get_declInfo().$name;
            error( "not support ... in macro -- %s" (name.txt) );
        }
    }
    self.writeln( " )", baseIndent + stepIndent );
    self.writeln( "local obj = {}", baseIndent + stepIndent );
    self.writeln( string.format( "setmetatable( obj, { __index = %s } )", className ),
                  baseIndent + stepIndent );
    self.writeln( string.format( "if obj.__init then obj:__init( %s ); end",
                                 argTxt ), baseIndent );
    self.writeln( "return obj", baseIndent );
    self.writeln( "end", baseIndent );


    // foreach refType, index in declInfo.retTypeList {
    //    if index > 1 {
    //   self.write( ", " )
    //    }
    //filter( //    refType,  self, node, baseIndent )
    // }
    self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
    if! declInfo.get_body() {
        filter( _exp,  self, node, baseIndent );
    }
    self.writeln( "end", baseIndent );
};


pub override fn convFilter.processExpCallSuper( 
    node: ExpCallSuperNode, parent: Node, baseIndent:int )
{
    let typeInfo:TransUnit.TypeInfo = node.get_superType();
    self.write( "%s.__init( self, " ( typeInfo.getTxt() ) );

    if node.get_expList() {
        filter( node.get_expList(), self, node, baseIndent );
    }
    self.writeln( ")", baseIndent );
};


pub override fn convFilter.processDeclMethod( 
    node: DeclMethodNode, parent: Node, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let delimit = ":";
    if declInfo.get_staticFlag() {
        delimit = ".";
    }
    let methodNodeToken = unwrap declInfo.get_name();
    let methodName = methodNodeToken.txt;
    let classNameToken = unwrap declInfo.get_className();
    self.write( "function %s%s%s( "
                ( classNameToken.txt, delimit, methodName ) );

    let argList: TransUnit.Node[] = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        filter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    // foreach refType, index in declInfo.retTypeList {
    //    if index > 1 {
    //   self.write( ", " )
    //    }
    //filter( //    refType,  self, node, baseIndent )
    // }
    if !declInfo.get_body() {
        filter( _exp, self, node, baseIndent );
    }
    self.writeln( "end", baseIndent );
};


pub override fn convFilter.processUnwrapSet(
    node: UnwrapSetNode, parent: Node, baseIndent:int )
{
    let dstExpList = node.$dstExpList;
    filter( dstExpList, self, node, baseIndent );
    self.write( " = " );
    filter( node.$srcExpList, self, node, baseIndent );
    self.writeln( "", baseIndent );

    self.write( "if " );
    foreach expNode, index in dstExpList.$expList {
        if index > 1 {
	    self.write( " or " );
        }   
	self.write( "not " );
        filter( expNode, self, node, baseIndent );
    }
    self.writeln( " then", baseIndent + stepIndent );

    foreach expNode, index in dstExpList.$expList {
        self.write( "local _exp%d = " (index));
        filter( expNode, self, node, baseIndent + stepIndent );
        self.writeln( "", baseIndent + stepIndent );
    }

    if node.$unwrapBlock {
        filter( unwrap node.$unwrapBlock, self, node, baseIndent + stepIndent );
    }
    self.writeln( "end", baseIndent );
}

pub override fn convFilter.processIfUnwrap(
    node: IfUnwrapNode, parent: Node, baseIndent:int )
{
    self.writeln( "do", baseIndent + stepIndent );
    self.write( "local _exp = " );
    filter( node.$exp, self, node, baseIndent + stepIndent );
    self.writeln( "", baseIndent + stepIndent );

    self.writeln( "if _exp then", baseIndent + stepIndent );
    filter( node.$block, self, node, baseIndent + stepIndent * 2 );

    if node.$nilBlock {
        self.writeln( "else", baseIndent + stepIndent );

        filter( unwrap node.$nilBlock, self, node, baseIndent + stepIndent * 2 );
    }
    self.writeln( "end", baseIndent );
    self.writeln( "end", baseIndent );
}

pub override fn convFilter.processDeclVar( 
    node: DeclVarNode, parent: Node, baseIndent:int )
{
    if node.$syncBlock {
        self.writeln( "do", baseIndent + stepIndent );
        foreach varInfo in node.$syncVarList {
            self.writeln( "local _sync_%s" (varInfo.$name.txt),
                          baseIndent + stepIndent );
        }
        self.writeln( "do", baseIndent + stepIndent * 2 );
    }

    if node.$mode ~= "unwrap" and node.get_accessMode() ~= "global" {
        self.write( "local " );
    }

    let varName = "";
    let varList = node.get_varList();
    foreach var, index in varList  {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var.$name.txt );
    }

    if! node.get_expList() {
        self.write( " = " );
        filter( _exp, self, node, baseIndent );
    }

    self.writeln( "", baseIndent );

    if! node.$unwrapBlock {
	self.writeln( "", baseIndent + stepIndent * 2 );
	self.write( "if " );
	foreach var, index in varList {
            if index > 1 {
		self.write( " or " );
            }   
	    self.write( " not " .. var.$name.txt );
	}
	self.writeln( " then", baseIndent + stepIndent * 3 );

        foreach var, index in varList  {
            self.writeln( "local _%s = %s" (var.$name.txt, var.$name.txt ),
                          baseIndent + stepIndent * 3 );
        }

	filter( _exp, self, node, baseIndent + stepIndent * 2 );

        if! node.$thenBlock {
            self.writeln( "else", baseIndent + stepIndent * 3 );
	    filter( _exp, self, node, baseIndent + stepIndent * 3);
        }   
        
	self.writeln( "end", baseIndent + stepIndent * 1 );
    }

    if! node.$syncBlock {
	filter( _exp, self, node, baseIndent + stepIndent * 1);

        foreach varInfo in node.$syncVarList {
            self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt),
                          baseIndent + stepIndent );
        }
        self.writeln( "end", baseIndent + stepIndent );
        
        foreach varInfo in node.$syncVarList {
            self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt),
                          baseIndent + stepIndent );
        }
        self.writeln( "end", baseIndent );
    }
    

    if node.get_accessMode() == "pub" {
        self.writeln( "", baseIndent );
        let varList = node.get_varList();
        foreach var, index in varList {
            let name: str = var.$name.txt;
            self.writeln( "moduleObj.%s = %s" ( name, name ),
                          baseIndent );
            self.pubVarName2InfoMap[ name ] = new VerInfo(
                node.get_staticFlag(),
                node.get_accessMode(), node.get_typeInfoList()[ index ] );
        }
    }

    if self.macroDepth > 0 {
        self.writeln( "", baseIndent );
	foreach var, index in varList {
            let varName = var.$name.txt;
            self.writeln( "table.insert( macroVar._names, '%s' )" ( varName ),
                          baseIndent );
	    self.writeln( "macroVar.%s = %s" ( varName, varName ), baseIndent );
	}
    }
};

pub override fn convFilter.processDeclArg( 
    node: DeclArgNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%s", node.get_name().txt ) );

    // filter( // node.info.argType,  self, node, baseIndent )
};

pub override fn convFilter.processDeclArgDDD( 
    node: DeclArgDDDNode, parent: Node, baseIndent:int )
{
    self.write( "..." );
};

pub override fn convFilter.processExpDDD( 
    node: ExpDDDNode, parent: Node, baseIndent:int )
{
    self.write( "..." );
};

pub override fn convFilter.processDeclFunc( 
    node: DeclFuncNode, parent: Node, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let nameToken = declInfo.get_name();
    let name = "";
    if! nameToken {
        name = _exp.txt;
    }
    let letTxt = "";
    if declInfo.get_accessMode() ~= "global" and #name ~= 0 {
        letTxt = "local ";
    }
    self.write( string.format( "%sfunction %s( ", letTxt, name ) );

    let argList = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        filter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    // foreach refType, index in declInfo.get_retTypeList() {
    //    if index > 1 {
    //   self.write( ", " )
    //    }
    //filter( //    refType,  self, node, baseIndent )
    // }
    if! declInfo.get_body() { 
        filter( _exp,  self, node, baseIndent );
    }
    self.writeln( "end", baseIndent );

    //if declInfo.get_accessMode() == "pub" {
    let expType: TransUnit.TypeInfo = node.get_expType();
    if expType.get_accessMode() == "pub" {
        self.write( "moduleObj.%s = %s" ( name, name ) );

        self.pubFuncName2InfoMap[ name ] = new FuncInfo(
            declInfo.get_accessMode(), node.get_expType() );
    }
};

pub override fn convFilter.processRefType( 
    node: RefTypeNode, parent: Node, baseIndent:int )
{
    self.write( (node.get_refFlag() and "&" or "") ..
                (node.get_mutFlag() and "mut " or "") );
    filter( node.get_name(),  self, node, baseIndent );
    if node.get_array() == "array" {
        self.write( "[@]" );
    }
    elseif node.get_array() == "list" {
        self.write( "[]" );
    }
};

pub override fn convFilter.processIf( 
    node: IfNode, parent: Node, baseIndent:int )
{
    let valList = node.get_stmtList();
    foreach val, index in valList {
        if index == 1 {
            self.write( "if " );
            filter( val.$exp,  self, node, baseIndent );
        }
        elseif val.$kind == "elseif" {
            self.write( "elseif " );
            filter( val.$exp,  self, node, baseIndent );
        }
        else {
            self.write( "else" );
        }
        self.write( " " );
        filter( val.$block, self, node, baseIndent );
    }
    self.write( "end" );
};

pub override fn convFilter.processSwitch( 
    node: SwitchNode, parent: Node, baseIndent:int )
{
    self.writeln( "do", baseIndent + 2 );
    self.write( "local _switchExp = " );
    filter( node.get_exp(),  self, node, baseIndent + 2 );
    self.writeln( "", baseIndent + 2 );

    foreach caseInfo, index in node.get_caseList() {
        if index == 1 {
            self.write( "if " );
        }
        else {
            self.write( "elseif " );
        }
        let expList = caseInfo.get_expList();
        foreach expNode, index in expList.get_expList() {
            if index ~= 1 {
                self.write( " or " );
            }

            self.write( "_switchExp == " );
            filter( expNode, self, node, baseIndent + 2 );
        }   
        self.write( " then" );
        filter( caseInfo.$block, self, node, baseIndent + 2 );
    }
    if! node.get_default() {
        self.write( "else " );
        filter( _exp, self, node, baseIndent + 2 );
    }
    self.writeln( "end", baseIndent );
    
    self.writeln( "end", baseIndent );
};

pub override fn convFilter.processWhile( 
    node: WhileNode, parent: Node, baseIndent:int )
{
    self.write( "while " );

    filter( node.get_exp(), self, node, baseIndent );
    self.write( " " );
    filter( node.get_block(), self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processRepeat( 
    node: RepeatNode, parent: Node, baseIndent:int )
{
    self.write( "repeat " );
    filter( node.get_block(),  self, node, baseIndent );
    self.write( "until " );
    filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processFor( 
    node: ForNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "for %s = ", node.get_val().txt ) );
    filter( node.get_init(),  self, node, baseIndent );
    self.write( ", " );
    filter( node.get_to(),  self, node, baseIndent );
    if! node.get_delta() {
        self.write( ", " );
        filter( _exp,  self, node, baseIndent );
    }
    self.write( " " );
    filter( node.get_block(),  self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processApply( 
    node: ApplyNode, parent: Node, baseIndent:int )
{
    self.write( "for " );
    let varList = node.get_varList();
    foreach var, index in varList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var.txt );
    }
    self.write( " in " );
    filter( node.$exp,  self, node, baseIndent );
    self.write( " " );
    filter( node.$block,  self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processForeach( 
    node: ForeachNode, parent: Node, baseIndent:int )
{
    self.write( "for " );
    if! node.$key {
        self.write( _exp.txt );
    }
    else {
        self.write( "__index" );
    }
    self.write( ", " );
    self.write( node.$val.txt );

    self.write( " in pairs( " );
    filter( node.$exp,  self, node, baseIndent );
    self.write( " ) " );
    filter( node.$block,  self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processForsort( 
    node: ForsortNode, parent: Node, baseIndent:int )
{
    self.writeln( "do", baseIndent + stepIndent );
    self.writeln( "local __sorted = {}", baseIndent + stepIndent );
    self.write( "local __map = " );
    filter( node.$exp,  self, node, baseIndent + stepIndent );
    self.writeln( "", baseIndent + stepIndent );
    self.writeln( "for __key in pairs( __map ) do", baseIndent + stepIndent * 2 );
    self.writeln( "table.insert( __sorted, __key )", baseIndent + stepIndent );
    self.writeln( "end", baseIndent + stepIndent );

    self.writeln( "table.sort( __sorted )", baseIndent + stepIndent );


    self.write( "for __index, " );
    let key = "__key";
    if! node.$key {
        key = _exp.txt;
    }
    self.write( key );
    self.writeln( " in ipairs( __sorted ) do", baseIndent + stepIndent * 2 );
    self.writeln( string.format( "%s = __map[ %s ]", node.$val.txt, key ),
                  baseIndent + stepIndent * 2 );
    filter( node.$block, self, node, baseIndent + stepIndent * 2 );
    self.writeln( "end", baseIndent + stepIndent );
    self.writeln( "end", baseIndent );
    self.writeln( "end", baseIndent );
};


pub override fn convFilter.processExpUnwrap(
    node: ExpUnwrapNode, parent: Node, baseIndent:int )
{
    filter( node.$exp,  self, node );
    self.write( " or " );
    if! node.$default {
        filter( _exp, self, node );
    }
    else {
        self.write( "_luneScript.error( 'unwrap val is nil' )" );
    }
}
    

pub override fn convFilter.processExpCall( 
    node: ExpCallNode, parent: Node, baseIndent:int )
{
    let wroteFuncFlag = false;
    if node.$func.$kind == TransUnit.nodeKind.RefField {
        let refField = node.$func@TransUnit.RefFieldNode;
        if refField.$prefix.$expType.$kind == TransUnit.TypeInfoKindList {
            wroteFuncFlag = true;
            self.write( "table.%s( " (refField.$field.txt ) );
            filter( refField.$prefix, self, refField, baseIndent );
        }
    }

    if not wroteFuncFlag {
        filter( node.$func, self, node, baseIndent );
        self.write( "( " );
    }

    
    if! node.$argList {
        if wroteFuncFlag {
            if #_exp.$expList > 0 {
                self.write( ", " );
            }
        }
        filter( _exp,  self, node, baseIndent );
    }
    self.write( " )" );
};


pub override fn convFilter.processExpList( 
    node: ExpListNode, parent: Node, baseIndent:int )
{
    let expList = node.get_expList();
    //let expList = node.$expList;
    foreach exp, index in expList {
        if index > 1 {
            self.write( ", " );
        }
        filter( exp, self, node, baseIndent );
    }
};


pub override fn convFilter.processExpOp1( 
    node: ExpOp1Node, parent: Node, baseIndent:int )
{
    let op = node.$op.txt;
    // if op == ",,," or op == ",,,," {
    //     filter( node.$exp,  self, node, baseIndent );
    // }
    if op == ",,," {
        filter( node.$exp,  self, node, baseIndent );
    }
    elseif op == ",,,," {
        if node.$macroMode == "expand" {
            filter( node.$exp,  self, node, baseIndent );
        }
        else {
            self.write( "_luneSym2Str( " );
            filter( node.$exp,  self, node, baseIndent );
            self.write( " )" );
        }
    }
    elseif op == ",," {
        self.write( "_luneGetLocal( " );
        filter( node.$exp,  self, node, baseIndent );
        self.write( " )" );
    }
    else {
        if op == "not" {
            op = op .. " ";
        }   
        self.write( op );
        filter( node.$exp,  self, node, baseIndent );
    }
};

pub override fn convFilter.processExpCast( 
    node: ExpCastNode, parent: Node, baseIndent:int )
{
    if node.$expType == TransUnit.builtinTypeInt {
        self.write( "math.floor(" );
        filter( node.$exp,  self, node, baseIndent );
        self.write( ")" );
    }
    else {
        filter( node.$exp,  self, node, baseIndent );
    }
};


pub override fn convFilter.processExpParen( 
    node: ExpParenNode, parent: Node, baseIndent:int )
{
    self.write( "(" );
    filter( node.$exp,  self, node, baseIndent );
    self.write( " )" );
};

pub override fn convFilter.processExpOp2( 
    node: ExpOp2Node, parent: Node, baseIndent:int )
{
    let intCast = false;
    if node.$expType == TransUnit.builtinTypeInt and node.$op.txt == "/" {
        intCast = true;
        self.write( "math.floor(" );
    }
    
    filter( node.$exp1,  self, node, baseIndent );

    self.write( " " .. node.$op.txt .. " " );

    filter( node.$exp2,  self, node, baseIndent );

    if intCast {
        self.write( ")" );
    }
};

pub override fn convFilter.processExpRef( 
    node: ExpRefNode, parent: Node, baseIndent:int )
{
    self.write( node.$token.txt );
};

pub override fn convFilter.processExpRefItem( 
    node: ExpRefItemNode, parent: Node, baseIndent:int )
{
    if node.$val.$kind == TransUnit.nodeKind.LiteralString {
        self.write( "string.byte( " );
        filter( node.$val, self, node, baseIndent );
        self.write( ", " );
        filter( node.$index, self, node, baseIndent );
        self.write( " )" );
    }
    else {
        filter( node.$val, self, node, baseIndent );
        self.write( "[" );
        filter( node.$index, self, node, baseIndent );
        self.write( "]" );
    }
};

pub override fn convFilter.processRefField( 
    node: RefFieldNode, parent: Node, baseIndent:int )
{
    let prefix = node.get_prefix();

    filter( prefix,  self, node, baseIndent );
    let delimit = ".";
    if parent.$kind == TransUnit.nodeKind.ExpCall {
        if node.get_expType().get_kind() == TransUnit.TypeInfoKindMethod {
            delimit = ":";
        }   
        else {
            delimit = ".";
        }   
    }
    let fieldToken = node.get_field();
    self.write( delimit .. fieldToken.txt );
};

pub override fn convFilter.processGetField(
    node: GetFieldNode, parent: Node, baseIndent:int )
{
    filter( node.get_prefix(),  self, node, baseIndent );
    let delimit = ".";
    if node.get_getterTypeInfo().get_kind() == TransUnit.TypeInfoKindMethod {
        delimit = ":";
    }   
    else {
        delimit = ".";
    }
    let fieldTxt = node.get_field().txt;
    if node.get_getterTypeInfo() {
        fieldTxt = "get_%s()" ( fieldTxt );
    }
    self.write( delimit .. fieldTxt );
};  


pub override fn convFilter.processReturn( 
    node: ReturnNode, parent: Node, baseIndent:int )
{
    self.write( "return " );

    if! node.$expList {
        filter( _exp,  self, node, baseIndent );
    }
};

pub override fn convFilter.processLiteralList( 
    node: LiteralListNode, parent: Node, baseIndent:int )
{
    self.write( "{" );

    if! node.$expList {
        filter( _exp, self, node, baseIndent );
    }

    self.write( "}" );
};

pub override fn convFilter.processLiteralMap( 
    node: LiteralMapNode, parent: Node, baseIndent:int )
{
    self.write( "{" );
    let pairList = node.$pairList;
    foreach pair, index in pairList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( "[" );
        filter( pair.$key, self, node, baseIndent );
        self.write( "] = " );
        filter( pair.$val, self, node, baseIndent );
        index = index + 1;
    }

    self.write( "}" );
};


pub override fn convFilter.processLiteralArray( 
    node: LiteralArrayNode, parent: Node, baseIndent:int )
{
    self.write( "{" );

    if! node.$expList {
        filter( _exp, self, node, baseIndent );
    }

    self.write( "}" );
};


pub override fn convFilter.processLiteralChar( 
    node: LiteralCharNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%g", node.$num ) );
};

pub override fn convFilter.processLiteralInt( 
    node: LiteralIntNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%d", node.$num ) );
};

pub override fn convFilter.processLiteralReal( 
    node: LiteralRealNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%s", node.$num ) );
};

pub override fn convFilter.processLiteralString( 
    node: LiteralStringNode, parent: Node, baseIndent:int )
{
    let txt = node.get_token().txt;
    if string.find( txt, '^```' ) {
        txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
    }
    let argList:TransUnit.Node[] = node.get_argList();
    if argList and #argList > 0 {
        self.write( string.format( 'string.format( %s, ', txt ) );
        let argList = node.get_argList();
        foreach val, index in argList {
            if index > 1 {
                self.write( ", " );
            }
            filter( val,  self, node, baseIndent );
        }
        self.write( ")" );
    }
    else {
        self.write( txt );
    }
};

pub override fn convFilter.processLiteralBool( 
    node: LiteralBoolNode, parent: Node, baseIndent:int )
{
    self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralNil( 
    node: LiteralNilNode, parent: Node, baseIndent:int )
{
    self.write( "nil" );
};

pub override fn convFilter.processBreak( 
    node: BreakNode, parent: Node, baseIndent:int )
{
    self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol( 
    node: LiteralSymbolNode, parent: Node, baseIndent:int ) 
{
    self.write( '%s' ( node.$token.txt ) );
};


pub class MacroEvalImp extend TransUnit.MacroEval {
    pri let mode: str;

    pub override fn eval( node: TransUnit.DeclMacroNode ): form
    {   
        let oStream = new Util.memStream();
        let conv = new convFilter( "macro", oStream, "exe", true );

        conv.processDeclMacro( node, node, 0 );

        // Util.errorLog( 'hoooo: %s' (oStream.get_txt()) );
        
        let chunk, err = load( oStream.get_txt() );
        if err {
            error( err );
        }
        let mod = chunk()@form;
        if not mod {
            error( "macro load error" );
        }   
        return mod;
    }
}

