import lune.base.TransUnit;
import lune.base.Parser;
import lune.base.Util;

pub class filterObj {
    pri let streamName: str;
    pri let stream: Util.outStream;
    pri let moduleName2Info: Map<str,stem>;
    pri let exeFlag: bool;
    pri let inMacro: bool;
    pri let indent: int;
    pri let curLineNo: int;
    '' クラス名 → TypeInfo
    pri let className2Scope: Map<str,TransUnit.Scope>;
    pri let className2TypeInfo: Map<str,TransUnit.TypeInfo>;
    '' クラス名 → Member Node List
    pri let className2MemberList: Map<str,TransUnit.Node[]>;
    '' public 変数名 → 変数情報
    pri let pubVarName2InfoMap: Map<str,stem>;
    '' public 関数名 → 関数情報
    pri let pubFuncName2InfoMap: Map<str,stem>;
    pri let needIndent: bool;
    pri let macroDepth: int;
    pri let typeId2MacroChunk: Map<int,stem>;
    fn __init( streamName: str, stream: Util.outStream,
               exeFlag: bool, inMacro: bool )
    {
        self.macroDepth = 0;
        self.streamName = streamName;
        self.stream = stream;
        self.moduleName2Info = {};
        self.exeFlag = exeFlag;
        self.inMacro = inMacro;
        self.indent = 0;
        self.curLineNo = 1;
        self.className2Scope = {};
        self.className2TypeInfo = {};
        self.className2MemberList = {};
        self.pubVarName2InfoMap = {};
        self.pubFuncName2InfoMap = {};
        self.needIndent = false;
        self.typeId2MacroChunk = {};
    }
}

let stepIndent = 2;

let builtInModuleSet = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
builtInModuleSet[ "_luneScript" ] = true;



fn filterObj.write( txt: str ) {
    if self.needIndent {
        self.stream.write( string.rep( " ", self.indent ) );
        self.needIndent = false;
    }

    apply cr of string.gmatch( txt, "\n" ) {
        self.curLineNo = self.curLineNo + 1;
    }
    self.stream.write( txt );
}

fn filterObj.setIndent( indent: int ) {
    self.indent = indent;
}

fn filterObj.writeln( txt: str, baseIndent: int ) {
    self.write( txt );
    self.write( "\n" );
    self.needIndent = true;
    self.indent = baseIndent;
}

filterObj[ TransUnit.nodeKind.None ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "-- none", baseIndent );
};

filterObj[ TransUnit.nodeKind.Import ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let module = node.info;
    let moduleName = string.gsub( module, ".*%.", "" );
    ''let moduleInfo = require( module );
    let moduleInfo = true;
    self.moduleName2Info[ moduleName ] = moduleInfo;
    if self.exeFlag {
        self.writeln(
            "local %s = _luneScript.loadModule( '%s' )" ( moduleName, module),
            baseIndent );
    }
    else {
        self.writeln( "local %s = require( '%s' )" ( moduleName, module ),
                      baseIndent );
    }
};

filterObj[ TransUnit.nodeKind.Root ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "--%s" ( self.streamName ), baseIndent );
    self.writeln( "local moduleObj = {}", baseIndent );

    let children:TransUnit.Node[] = node.info.children;

    foreach child in children {
        TransUnit.nodeFilter( child, self, node, baseIndent );
        self.writeln( "", baseIndent );
    }

    self.writeln( "----- meta -----", baseIndent );

    let typeId2TypeInfo: Map<int,TransUnit.TypeInfo> = {};
    let typeId2UseFlag: Map<int,bool> = {};

    '' 公開される型情報を typeId2TypeInfo にピックアップする
    fn pickupTypeId( typeInfo: TransUnit.TypeInfo, forceFlag: bool ) {
        if typeInfo {
            if not forceFlag and typeInfo.get_accessMode() ~= "pub" {
                return;
            }
            if typeId2TypeInfo[ typeInfo.get_typeId() ] {
                return;
            }
            
            typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
	    if typeInfo.get_nilable() {
		pickupTypeId( typeInfo.get_orgTypeInfo() );
	    }
	    else {
                let parentInfo = typeInfo.get_parentInfo();
                pickupTypeId( parentInfo );

                let baseInfo = typeInfo.get_baseTypeInfo();
                if baseInfo {
                    pickupTypeId( baseInfo );
                }
                
		let typeInfoList: TransUnit.TypeInfo[] = typeInfo.get_itemTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo );
		    }
                }
		typeInfoList = typeInfo.get_retTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo );
		    }
                }
		typeInfoList = typeInfo.get_children();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        if itemTypeInfo.get_kind() == TransUnit.TypeInfoKindClass or
                            itemTypeInfo.get_kind() == TransUnit.TypeInfoKindFunc
                        {                       
                            pickupTypeId( itemTypeInfo );
                        }
		    }
                }
	    }
        }
    }


    

    

    self.writeln( "local _className2InfoMap = {}", baseIndent );
    self.writeln(
        "moduleObj._className2InfoMap = _className2InfoMap", baseIndent );

    forsort scope, className in self.className2Scope {
        self.writeln( "local _classInfo%s = {}" (className), baseIndent );
        self.writeln( "_className2InfoMap.%s = _classInfo%s" (className, className),
                      baseIndent );

        pickupTypeId( self.className2TypeInfo[ className ] );
        
        foreach memberNode in self.className2MemberList[ className ] {
            let memberInfo = memberNode.get_info();
            if memberInfo.accessMode == "pub" {
                let memberName = memberInfo.name.txt;
                let memberTypeInfo:TransUnit.TypeInfo = memberNode.get_expType();
                self.writeln( "_classInfo%s.%s = {" ( className, memberName ),
                              baseIndent );
                self.writeln(
                    "  name='%s', staticFlag = %s, " ( memberName,
                                                       memberInfo.staticFlag ) ..
                    "accessMode = '%s', methodFlag = false, typeId = %d }"
                    ( memberInfo.accessMode,
                      memberTypeInfo.get_typeId() ),
                    baseIndent );
            }
        }
    }


    self.writeln( "local _varName2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._varName2InfoMap = _varName2InfoMap", baseIndent );

    forsort varInfo, varName in self.pubVarName2InfoMap {
        self.writeln( string.format( "_varName2InfoMap.%s = {", varName ),
                      baseIndent );
        self.writeln(
            "  name='%s', accessMode = '%s', typeId = %d }"
            ( varName, varInfo[ "accessMode" ],
              varInfo[ "typeInfo" ].get_typeId() ),
            baseIndent );
        pickupTypeId( varInfo[ "typeInfo" ], true );
    }

    forsort funcInfo, funcName in self.pubFuncName2InfoMap {
        pickupTypeId( funcInfo[ "typeInfo" ] );
    }

    
    '' self.writeln( "moduleObj._typeInfoList = {", baseIndent );
    '' foreach typeInfo, typeId in typeId2TypeInfo {
    ''     if typeId == TransUnit.rootTypeId {
    ''         foreach child in typeInfo.get_children()@TransUnit.TypeInfo[] {
    ''             let child:TransUnit.TypeInfo = child;
    ''             let childTypeId = child.get_typeId();
    ''             if typeId2TypeInfo[ childTypeId ] and
    ''                 not TransUnit.isBuiltin( childTypeId )
    ''             {               
    ''                 child.serialize( self );
    ''             }
    ''         }
    ''         break;
    ''     }
    '' }
    '' self.writeln( "}" , baseIndent );


    self.writeln( "local _typeInfoList = {}", baseIndent );
    self.writeln( "moduleObj._typeInfoList = _typeInfoList", baseIndent );
    let listIndex = 1;
    forsort typeInfo, typeId in typeId2TypeInfo {
        foreach child in typeInfo.get_children()@TransUnit.TypeInfo[] {
            let child:TransUnit.TypeInfo = child;
            let childTypeId = child.get_typeId();
            if typeId2TypeInfo[ childTypeId ] and
                not TransUnit.isBuiltin( childTypeId )
            {               
                self.write( "_typeInfoList[%d] = " (listIndex) );
                listIndex = listIndex + 1;
                child.serialize( self );
            }
        }
    }

    self.writeln( "----- meta -----", baseIndent );


    self.writeln( "return moduleObj", baseIndent );
};

filterObj[ TransUnit.nodeKind.Block ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let word = "";
    if node.info.kind == "if" or node.info.kind == "elseif" {
        word = "then";
    }
    elseif node.info.kind == "else" {
        word = "";
    }
    elseif node.info.kind == "while" {
        word = "do";
    }
    elseif node.info.kind == "repeat" {
        word = "";
    }
    elseif node.info.kind == "for" {
        word = "do";
    }
    elseif node.info.kind == "apply" {
        word = "do";
    }
    elseif node.info.kind == "foreach" {
        word = "do";
    }
    elseif node.info.kind == "macro" {
        word = "";
    }
    elseif node.info.kind == "func" {
        word = "";
    }
    elseif node.info.kind == "default" {
        word = "";
    }
    elseif node.info.kind == "{" {
        word = "do";
    }
    self.writeln( word, baseIndent + stepIndent );
    let stmtList:TransUnit.Node[] = node.info.stmtList;
    foreach statement in stmtList {
        TransUnit.nodeFilter( statement, self, node, baseIndent + stepIndent );
        self.writeln( "", baseIndent + stepIndent );
    }

    self.setIndent( baseIndent ) ;
    if node.info.kind == "{" {
        self.write( "end", baseIndent );
    }
};

filterObj[ TransUnit.nodeKind.StmtExp ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.DeclClass ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let className = node.info.name.txt;

    if node.info.accessMode == "pub" {
        self.className2Scope[ className ] = node.info.scope;
        self.className2TypeInfo[ className ] = node.expType;
    }
    self.className2MemberList[ className ] = node.info.memberList;

    self.writeln( string.format( "local %s = {}", className ), baseIndent );

    let baseInfo: TransUnit.TypeInfo = node.expType.get_baseTypeInfo();
    if baseInfo {
        self.writeln(
            "setmetatable( %s, { __index = %s } )"
            ( className, baseInfo.getTxt() ), baseIndent );
    }
    
    if node.info.accessMode == "pub" {
        self.writeln( string.format( "moduleObj.%s = %s", className, className ),
                      baseIndent );
    }
    let hasConstrFlag = false;
    let memberList: TransUnit.Node[] = {};
    let fieldList: Map<str,int> = node.info.fieldList;
    let outerMethodSet: Map<str,bool> = node.info.outerMethodSet;
    foreach field in fieldList {
        let ignoreFlag = false;
        if field[ "kind" ] == TransUnit.nodeKind.DeclConstr {
            hasConstrFlag = true;
        }
        if field[ "kind" ] == TransUnit.nodeKind.DeclMember {
            table.insert( memberList, field );
        }
        if field[ "kind" ] == TransUnit.nodeKind.DeclMethod {
            if outerMethodSet[ field.info.name.txt ] {
                ignoreFlag = true;
            }
        }

        if ( not ignoreFlag ) {
            TransUnit.nodeFilter( field, self, node, baseIndent );
        }
    }
    if not hasConstrFlag {
        let argTxt = "";
        foreach member, index in memberList {
            if index > 1 {
                argTxt = argTxt .. ", ";
            }
            argTxt = argTxt .. member[ "info" ].name.txt;
        }

        self.writeln( ```
function %s.new( %s )
  local obj = {}
  setmetatable( obj, { __index = %s } )
  if obj.__init then
    obj:__init( %s )
  end
  return obj
end
function %s:__init( %s )
            ``` ( className, argTxt, className, argTxt, className, argTxt ),
            baseIndent );
        foreach member in memberList {
            let memberName = member[ "info" ].name.txt;
            self.writeln( string.format( "self.%s = %s", memberName, memberName ),
                          baseIndent + stepIndent);         
        }
        self.writeln( 'end', baseIndent );
    }

    '' accessor
    let scope = node.info.scope@TransUnit.Scope;
    foreach memberNode in node.info.memberList@stem[] {
        let memberName = memberNode.info.name.txt;
        let getterName = "get_" .. memberName;
        let typeInfo:TransUnit.TypeInfo = scope.getTypeInfo( getterName );
        let autoFlag = not typeInfo or typeInfo.get_autoFlag();
        if memberNode.info.getterMode ~= "none" and autoFlag
        {       
            self.writeln( ```
function %s:%s()
   return self.%s
end``` ( className, getterName, memberName ), baseIndent );
        }
        let setterName = "set_" .. memberName;
        typeInfo = scope.getTypeInfo( setterName );
        if memberNode.info.setterMode ~= "none" and autoFlag
        {       
            self.writeln( ```
function %s:%s()
   return self.%s
end``` ( className, setterName, memberName ), baseIndent );
        }
    }
};

filterObj[ TransUnit.nodeKind.DeclMember ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    '' dump( baseIndent, node, node.info.name.txt )
    '' node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};

filterObj[ TransUnit.nodeKind.ExpMacroExp ] = 
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let stream = new Util.memStream();

    let typeId:int = node.info.func.expType.get_typeId();
    let chunk = self.typeId2MacroChunk[ typeId ];
    ''chunk[ node.info.func.expType.getTxt() ]();
    
};

filterObj[ TransUnit.nodeKind.DeclMacro ] = 
    fn( self: filterObj, node: TransUnit.Node, parent:stem, baseIndent:int )
{
    if self.inMacro {
        let nodeInfo = node.get_info()@TransUnit.DeclMacroInfo;
        
        let name:Parser.Token = nodeInfo.get_name();
        
        self.writeln( "local module = {}", baseIndent );
        self.write( "function module.%s(" ( name.txt ) );

        let argTxt = "";
        foreach arg, index in nodeInfo.get_argList() {
            if index > 1 {
                self.write( ", " );
                argTxt = argTxt .. ", ";
            }   
            TransUnit.nodeFilter( arg, self, node, baseIndent );
            argTxt = argTxt .. arg[ "info" ].name.txt;
        }

        self.writeln( ")", baseIndent );

        self.writeln( "local macroVar = {}", baseIndent );

        self.macroDepth = self.macroDepth + 1;
        
        TransUnit.nodeFilter( nodeInfo.get_ast(), self, node, baseIndent );
        
        self.macroDepth = self.macroDepth - 1;
        
        self.writeln( "", baseIndent );
        self.writeln( "return macroVar", baseIndent );
        self.writeln( "end", baseIndent );
        self.writeln( "return module", baseIndent );
    }
    else {
        let oStream = new Util.memStream();
        let conv = new filterObj( "macro", oStream, false, true );

        conv[ TransUnit.nodeKind.DeclMacro ]( conv, node, parent, baseIndent );

        TransUnit.errorLog( oStream.get_txt() );
        let chunk, err = load( oStream.get_txt() );
        if err {
            error( err );
        }
        let mod: stem = chunk();
        if not mod {
            error( "macro load error" );
        }
        print( "hoge", node.get_expType().get_typeId(), mod );
        self.typeId2MacroChunk[ node.get_expType().get_typeId() ] = mod;
        
        '' let iStream = new Parser.TxtStream( oStream.get_txt() );
        '' let parser = new Parser.StreamParser( iStream, "macro", false );
        '' let transUnit = new TransUnit.TransUnit();

        '' let ast = transUnit.createAST( parser );
        
        
        '' let ast = transUnit.createAST( )
    }
};

filterObj[ TransUnit.nodeKind.ExpMacroStat ] = 
    fn( self: filterObj, node: TransUnit.Node, parent:stem, baseIndent:int )
{
    let nodeInfo = node.get_info()@TransUnit.Node[];
    
    foreach token, index in nodeInfo {
        if index ~= 1 {
            self.write( '..' );
        }
        
        TransUnit.nodeFilter( token, self, node, baseIndent );
    }
};


filterObj[ TransUnit.nodeKind.ExpNew ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.symbol,  self, node, baseIndent );
    self.write( ".new(" );
    if node.info.argList {
        TransUnit.nodeFilter( node.info.argList,  self, node, baseIndent );
    }
    self.write( ")" );
};

filterObj[ TransUnit.nodeKind.DeclConstr ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let className = node.info.className.txt;
    self.write( string.format( "function %s.new( ", className ) );

    let argTxt = "";
    let argList: TransUnit.Node[] = node.info.argList;
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
            argTxt = argTxt .. ", ";
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
        argTxt = argTxt .. arg[ "info" ].name.txt;
    }
    self.writeln( " )", baseIndent + stepIndent );
    self.writeln( "local obj = {}", baseIndent + stepIndent );
    self.writeln( string.format( "setmetatable( obj, { __index = %s } )", className ),
                  baseIndent + stepIndent );
    self.writeln( string.format( "if obj.__init then obj:__init( %s ); end",
                                 argTxt ), baseIndent );
    self.writeln( "return obj", baseIndent );
    self.writeln( "end", baseIndent );


    '' foreach refType, index in node.info.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
    TransUnit.nodeFilter( node.info.body,  self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


filterObj[ TransUnit.nodeKind.DeclMethod ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let delimit = ":";
    if node.info.staticFlag {
        delimit = ".";
    }
    let methodName = node.info.name.txt;
    self.write( "function %s%s%s( "
                ( node.info.className.txt, delimit, methodName ) );

    let argList: TransUnit.Node[] = node.info.argList;
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in node.info.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    TransUnit.nodeFilter( node.info.body,  self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


filterObj[ TransUnit.nodeKind.DeclVar ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    if node.info.accessMode ~= "global" {
        self.write( "local " );
    }

    let varName = "";
    let varList: stem[] = node.info.varList;
    foreach var, index in varList  {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var[ "name" ].txt );
    }

    if node.info.expList {
        self.write( " = " );
        TransUnit.nodeFilter( node.info.expList, self, node, baseIndent );
    }

    if node.info.unwrap {
	self.writeln( "", baseIndent );
	self.write( "if " );
	foreach var, index in varList {
            if index > 1 {
		self.write( " or " );
            }   
	    self.write( " not " .. var[ "name" ].txt );
	}
	self.write( " then" );
	TransUnit.nodeFilter( node.info.unwrap, self, node, baseIndent );
	self.writeln( "end", baseIndent );
    }

    if node.info.accessMode == "pub" {
        self.writeln( "", baseIndent );
        let varList:stem[] = node.info.varList;
        foreach var, index in varList {
            let name: str = var[ "name" ].txt;
            self.writeln( "moduleObj.%s = %s" ( name, name ),
                          baseIndent );
            self.pubVarName2InfoMap[ name ] =  {
                "funcFlag": false, "staticFlag": node.info.staticFlag,
                "accessMode": node.info.accessMode,
                "typeInfo": node.info.typeInfoList[ index ]
            };
        }
    }

    if self.macroDepth > 0 {
	foreach var, index in varList {
	    self.writeln(
                "macroVar.%s = %s" ( var[ "name" ].txt, var[ "name" ].txt ),
                baseIndent );
	}
    }
};

filterObj[ TransUnit.nodeKind.DeclArg ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%s", node.info.name.txt ) );

    '' TransUnit.nodeFilter( '' node.info.argType,  self, node, baseIndent )
};

filterObj[ TransUnit.nodeKind.DeclArgDDD ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "..." );
};

filterObj[ TransUnit.nodeKind.ExpDDD ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "..." );
};

filterObj[ TransUnit.nodeKind.DeclFunc ] =
    fn( self: filterObj, node: TransUnit.Node, parent:stem, baseIndent:int )
{
    let nodeInfo = node.get_info()@TransUnit.DeclFuncInfo;
    let nameToken:Parser.Token = nodeInfo.get_name();
    let name = nameToken and nameToken.txt or "";
    let letTxt = "";
    if nodeInfo.get_accessMode() ~= "global" and #name ~= 0 {
        letTxt = "local ";
    }
    self.write( string.format( "%sfunction %s( ", letTxt, name ) );

    let argList: stem[] = nodeInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in nodeInfo.get_retTypeList() {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''TransUnit.nodeFilter( ''    refType,  self, node, baseIndent )
    '' }
    TransUnit.nodeFilter( nodeInfo.get_body(),  self, node, baseIndent );
    self.writeln( "end", baseIndent );

    ''if nodeInfo.get_accessMode() == "pub" {
    let expType: TransUnit.TypeInfo = node.get_expType();
    if expType.get_accessMode() == "pub" {
        self.write( "moduleObj.%s = %s" ( name, name ) );

        self.pubFuncName2InfoMap[ name ] = {
            "funcFlag": true, "accessMode": nodeInfo.get_accessMode(),
            "typeInfo": node.get_expType()
        };
    }
};

filterObj[ TransUnit.nodeKind.RefType ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write(
        (node.info.refFlag and "&" or "") .. (node.info.mutFlag and "mut " or "") );
    TransUnit.nodeFilter( node.info.name,  self, node, baseIndent );
    if node.info.array == "array" {
        self.write( "[@]" );
    }
    elseif node.info.array == "list" {
        self.write( "[]" );
    }
};

filterObj[ TransUnit.nodeKind.If ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let valList:stem[] = node.info;
    foreach val, index in valList {
        if index == 1 {
            self.write( "if " );
            TransUnit.nodeFilter( val[ "exp" ],  self, node, baseIndent );
        }
        elseif val[ "kind" ] == "elseif" {
            self.write( "elseif " );
            TransUnit.nodeFilter( val[ "exp" ],  self, node, baseIndent );
        }
        else {
            self.write( "else" );
        }
        self.write( " " );
        TransUnit.nodeFilter( val[ "block" ], self, node, baseIndent );
    }
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Switch ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "do", baseIndent + 2 );
    self.write( "local _switchExp = " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent + 2 );
    self.writeln( "", baseIndent + 2 );

    foreach caseInfo, index in node.info.caseList@stem[] {
        if index == 1 {
            self.write( "if " );
        }
        else {
            self.write( "elseif " );
        }
        let expList = caseInfo.expList;
        foreach expNode, index in expList.info@stem[] {
            if index ~= 1 {
                self.write( " or " );
            }

            self.write( "_switchExp == " );
            TransUnit.nodeFilter( expNode, self, node, baseIndent + 2 );
        }   
        self.write( " then" );
        TransUnit.nodeFilter( caseInfo.block, self, node, baseIndent + 2 );
    }
    if node.info.default {
        self.write( "else " );
        TransUnit.nodeFilter( node.info.default, self, node, baseIndent + 2 );
        self.writeln( "end", baseIndent );
    }
    
    self.writeln( "end", baseIndent );
};

filterObj[ TransUnit.nodeKind.While ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "while " );

    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
    self.write( " " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Repeat ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "repeat " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "until " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.For ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "for %s = ", node.info.val.txt ) );
    TransUnit.nodeFilter( node.info.init,  self, node, baseIndent );
    self.write( ", " );
    TransUnit.nodeFilter( node.info.to,  self, node, baseIndent );
    if node.info.delta {
        self.write( ", " );
        TransUnit.nodeFilter( node.info.delta,  self, node, baseIndent );
    }
    self.write( " " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Apply ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "for " );
    let varList:stem[] = node.info.varList;
    foreach var, index in varList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var[ "txt" ] );
    }
    self.write( " in " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
    self.write( " " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Foreach ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "for " );
    self.write( node.info.key and node.info.key.txt or "__index" );
    self.write( ", " );
    self.write( node.info.val.txt );

    self.write( " in pairs( " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
    self.write( " ) " );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent );
    self.write( "end" );
};

filterObj[ TransUnit.nodeKind.Forsort ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.writeln( "do", baseIndent + stepIndent );
    self.writeln( "local __sorted = {}", baseIndent + stepIndent );
    self.write( "local __map = " );
    TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent + stepIndent );
    self.writeln( "", baseIndent + stepIndent );
    self.writeln( "for __key in pairs( __map ) do", baseIndent + stepIndent * 2 );
    self.writeln( "table.insert( __sorted, __key )", baseIndent + stepIndent );
    self.writeln( "end", baseIndent + stepIndent );

    self.writeln( "table.sort( __sorted )", baseIndent + stepIndent );


    self.write( "for __index, " );
    let key = node.info.key and node.info.key.txt or "__key";
    self.write( key );
    self.writeln( " in ipairs( __sorted ) do", baseIndent + stepIndent * 2 );
    self.writeln( string.format( "%s = __map[ %s ]", node.info.val.txt, key ),
                  baseIndent + stepIndent * 2 );
    TransUnit.nodeFilter( node.info.block,  self, node, baseIndent + stepIndent * 2 );
    self.writeln( "end", baseIndent + stepIndent );
    self.writeln( "end", baseIndent );
    self.writeln( "end", baseIndent );
};


filterObj[ TransUnit.nodeKind.ExpCall ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.func, self, node, baseIndent );
    self.write( "( " );
    if node.info.argList {
        TransUnit.nodeFilter( node.info.argList,  self, node, baseIndent );
    }
    self.write( " )" );
};


filterObj[ TransUnit.nodeKind.ExpList ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let expList: TransUnit.Node[] = node.info;
    foreach exp, index in expList {
        if index > 1 {
            self.write( ", " );
        }
        TransUnit.nodeFilter( exp, self, node, baseIndent );
    }
};


filterObj[ TransUnit.nodeKind.ExpOp1 ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    let op = node.info.op.txt;
    if op == ",,," {
        self.write( "_luneGetLocal( " );
        TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
        self.write( " )" );
    }
    elseif op == ",," {
        self.write( "_luneGetLocal( " );
        TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
        self.write( " )" );
    }
    else {
        if op == "not" {
            op = op .. " ";
        }   
        self.write( op );
        TransUnit.nodeFilter( node.info.exp,  self, node, baseIndent );
    }
};

filterObj[ TransUnit.nodeKind.ExpCast ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info,  self, node, baseIndent );
    ''TransUnit.nodeFilter( '' node.info.castType,  self, node, baseIndent )
};


filterObj[ TransUnit.nodeKind.ExpParen ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "(" );
    TransUnit.nodeFilter( node.info,  self, node, baseIndent );
    self.write( " )" );
};

filterObj[ TransUnit.nodeKind.ExpOp2 ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.exp1,  self, node, baseIndent );

    self.write( " " .. node.info.op.txt .. " " );

    TransUnit.nodeFilter( node.info.exp2,  self, node, baseIndent );
};

filterObj[ TransUnit.nodeKind.ExpRef ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( node.info.txt );
};

filterObj[ TransUnit.nodeKind.ExpRefItem ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    if node.info.val.kind == TransUnit.nodeKind.LiteralString {
        self.write( "string.byte( " );
        TransUnit.nodeFilter( node.info.val, self, node, baseIndent );
        self.write( ", " );
        TransUnit.nodeFilter( node.info.index, self, node, baseIndent );
        self.write( " )" );
    }
    else {
        TransUnit.nodeFilter( node.info.val, self, node, baseIndent );
        self.write( "[" );
        TransUnit.nodeFilter( node.info.index, self, node, baseIndent );
        self.write( "]" );
    }
};

filterObj[ TransUnit.nodeKind.RefField ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    TransUnit.nodeFilter( node.info.prefix,  self, node, baseIndent );
    let delimit = ".";
    if parent.kind == TransUnit.nodeKind.ExpCall {
        let prefixSymbol = node.info.prefix.info.txt;
        if node.expType.get_staticFlag() {
            delimit = ".";
        }
        else {
            delimit = ":";
        }
    }
    self.write( delimit .. node.info.field.txt );
};

filterObj[ TransUnit.nodeKind.Return ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "return " );

    if node.info {
        TransUnit.nodeFilter( node.info,  self, node, baseIndent );
    }
};

filterObj[ TransUnit.nodeKind.LiteralList ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );

    if node.info {
        TransUnit.nodeFilter( node.info, self, node, baseIndent );
    }

    self.write( "}" );
};

filterObj[ TransUnit.nodeKind.LiteralMap ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );
    let pairList:stem[] = node.info.pairList;
    foreach pair, index in pairList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( "[" );
        TransUnit.nodeFilter( pair[ "key" ], self, node, baseIndent );
        self.write( "] = " );
        TransUnit.nodeFilter( pair[ "val" ], self, node, baseIndent );
        index = index + 1;
    }

    self.write( "}" );
};


filterObj[ TransUnit.nodeKind.LiteralArray ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "{" );

    if node.info {
        TransUnit.nodeFilter( node.info, self, node, baseIndent );
    }

    self.write( "}" );
};


filterObj[ TransUnit.nodeKind.LiteralChar ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%g", node.info.num ) );
};

filterObj[ TransUnit.nodeKind.LiteralInt ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%d", node.info.num ) );
};

filterObj[ TransUnit.nodeKind.LiteralReal ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( string.format( "%s", node.info.num ) );
};

filterObj[ TransUnit.nodeKind.LiteralString ] =
    fn( self: filterObj, node: TransUnit.Node, parent:stem, baseIndent:int )
{
    let nodeInfo = node.get_info()@TransUnit.LiteralStringInfo;
    let txt = (nodeInfo.get_token()@Parser.Token).txt;
    if string.find( txt, '^```' ) {
        txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
    }
    if nodeInfo.get_argList() and #nodeInfo.get_argList() > 0 {
        self.write( string.format( "string.format( %s, ", txt ) );
        let argList = nodeInfo.get_argList();
        foreach val, index in argList {
            if index > 1 {
                self.write( ", " );
            }
            TransUnit.nodeFilter( val,  self, node, baseIndent );
        }
        self.write( ")" );
    }
    else {
        self.write( txt );
    }
};

filterObj[ TransUnit.nodeKind.LiteralBool ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( node.info.txt );
};

filterObj[ TransUnit.nodeKind.LiteralNil ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "nil" );
};

filterObj[ TransUnit.nodeKind.Break ] =
    fn( self: filterObj, node: stem, parent:stem, baseIndent:int )
{
    self.write( "break" );
};
