import lune.base.TransUnit;
import lune.base.Parser;
import lune.base.Util;

class VerInfo {
    let staticFlag: bool;
    let accessMode: str;
    let typeInfo: TransUnit.TypeInfo;
};

class FuncInfo {
    let accessMode: str;
    let typeInfo: TransUnit.TypeInfo;
}

pub class convFilter extend TransUnit.Filter {
    pri let streamName: str;
    pri let stream: Util.outStream;
    pri let moduleName2Info: Map<str,stem>;
    pri let exeFlag: bool;
    pri let inMacro: bool;
    pri let indent: int;
    pri let curLineNo: int;
    '' クラス名 → TypeInfo
    pri let className2Scope: Map<str,TransUnit.Scope>;
    pri let className2TypeInfo: Map<str,TransUnit.TypeInfo>;
    '' クラス名 → Member Node List
    pri let className2MemberList: Map<str,TransUnit.DeclMemberNode[]>;
    '' public 変数名 → 変数情報
    pri let pubVarName2InfoMap: Map<str,VerInfo>;
    '' public 関数名 → 関数情報
    pri let pubFuncName2InfoMap: Map<str,FuncInfo>;
    pri let needIndent: bool;
    pri let macroDepth: int;
    pri let moduleTypeInfo: TransUnit.TypeInfo;
    
    fn __init( streamName: str, stream: Util.outStream,
               exeFlag: bool, inMacro: bool, moduleTypeInfo: TransUnit.TypeInfo )
    {
        self.macroDepth = 0;
        self.streamName = streamName;
        self.stream = stream;
        self.moduleName2Info = {};
        self.exeFlag = exeFlag;
        self.inMacro = inMacro;
        self.indent = 0;
        self.curLineNo = 1;
        self.className2Scope = {};
        self.className2TypeInfo = {};
        self.className2MemberList = {};
        self.pubVarName2InfoMap = {};
        self.pubFuncName2InfoMap = {};
        self.needIndent = false;
        self.moduleTypeInfo = moduleTypeInfo;
    }
}

fn filter( node: TransUnit.Node, filter: convFilter,
           parent: TransUnit.Node, baseIndent:int )
{
    node.processFilter( filter, parent, baseIndent );
}

let stepIndent = 2;

let builtInModuleSet = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
builtInModuleSet[ "_luneScript" ] = true;

fn convFilter.write( txt: str ) {
    if self.needIndent {
        self.stream.write( string.rep( " ", self.indent ) );
        self.needIndent = false;
    }

    apply cr of string.gmatch( txt, "\n" ) {
        self.curLineNo = self.curLineNo + 1;
    }
    self.stream.write( txt );
}

fn convFilter.setIndent( indent: int ) {
    self.indent = indent;
}

fn convFilter.writeln( txt: str, baseIndent: int ) {
    self.write( txt );
    self.write( "\n" );
    self.needIndent = true;
    self.indent = baseIndent;
}

pub override fn convFilter.processNone( node: NoneNode, parent: Node, baseIndent:int )
{
    self.writeln( "-- none", baseIndent );
};

pub override fn convFilter.processImport( 
    node: ImportNode, parent: Node, baseIndent:int )
{
    let module = node.get_modulePath();
    let moduleName = string.gsub( module, ".*%.", "" );
    ''let moduleInfo = require( module );
    let moduleInfo = true;
    self.moduleName2Info[ moduleName ] = moduleInfo;
    if self.exeFlag {
        self.writeln(
            "local %s = _luneScript.loadModule( '%s' )" ( moduleName, module),
            baseIndent );
    }
    else {
        self.writeln( "local %s = require( '%s' )" ( moduleName, module ),
                      baseIndent );
    }
};

pub override fn convFilter.processRoot( 
    node: RootNode, parent: Node, baseIndent:int )
{
    self.writeln( "--%s" ( self.streamName ), baseIndent );
    self.writeln( "local moduleObj = {}", baseIndent );

    let children:TransUnit.Node[] = node.get_children();

    let typeId2ClassMap = node.get_typeId2ClassMap();

    foreach child in children {
        filter( child, self, node, baseIndent );
        self.writeln( "", baseIndent );
    }

    self.writeln( "----- meta -----", baseIndent );

    let typeId2TypeInfo: Map<int,TransUnit.TypeInfo> = {};
    let typeId2UseFlag: Map<int,bool> = {};
    let pickupClassMap: Map<str,TransUnit.NamespaceInfo> = {};

    '' 公開される型情報を typeId2TypeInfo にピックアップする
    fn pickupTypeId( typeInfo: TransUnit.TypeInfo, forceFlag: bool ) {
        if typeInfo {
            if typeInfo.get_typeId() == TransUnit.rootTypeId {
                return;
            }
            if not forceFlag and typeInfo.get_accessMode() ~= "pub" {
                return;
            }
            if typeId2TypeInfo[ typeInfo.get_typeId() ] {
                return;
            }
            
            typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
	    if typeInfo.get_nilable() {
		pickupTypeId( typeInfo.get_orgTypeInfo() );
	    }
	    else {
                let parentInfo = typeInfo.get_parentInfo();
                pickupTypeId( parentInfo );

                let baseInfo = typeInfo.get_baseTypeInfo();
                if baseInfo {
                    pickupTypeId( baseInfo );
                }
                
		let typeInfoList: TransUnit.TypeInfo[] = typeInfo.get_itemTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo );
		    }
                }
		typeInfoList = typeInfo.get_retTypeInfoList();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        pickupTypeId( itemTypeInfo );
		    }
                }
		typeInfoList = typeInfo.get_children();
                if typeInfoList {
		    foreach itemTypeInfo in typeInfoList {
                        if itemTypeInfo.get_kind() == TransUnit.TypeInfoKindClass or
                            itemTypeInfo.get_kind() == TransUnit.TypeInfoKindFunc or
                            itemTypeInfo.get_kind() == TransUnit.TypeInfoKindMethod
                        {                       
                            pickupTypeId( itemTypeInfo );
                        }
		    }
                }
	    }
        }
    }



    foreach namespaceInfo in typeId2ClassMap {
        if namespaceInfo.typeInfo.get_accessMode() == "pub" {
            pickupClassMap[ namespaceInfo.name ] = namespaceInfo;
        }
    }


    self.writeln( "local _typeId2ClassInfoMap = {}", baseIndent );
    self.writeln( "moduleObj._typeId2ClassInfoMap = _typeId2ClassInfoMap",
                  baseIndent );
    self.writeln( "local _className2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._className2InfoMap = _className2InfoMap",
                  baseIndent );     

    forsort scope, className in self.className2Scope {
        let classTypeInfo = self.className2TypeInfo[ className ];
        let classTypeId = classTypeInfo.get_typeId();
        pickupTypeId( classTypeInfo );
        pickupClassMap[ className ] = nil;
        
        self.writeln( "do", baseIndent + stepIndent );
        self.writeln( "local _classInfo%d = {}" (classTypeId), baseIndent + stepIndent );
        self.writeln( "_className2InfoMap.%s = _classInfo%d" (className, classTypeId),
                      baseIndent + stepIndent );
        self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                      (classTypeId, classTypeId), baseIndent + stepIndent );

        
        foreach memberNode in self.className2MemberList[ className ] {
            if memberNode.$accessMode == "pub" {
                let memberName = memberNode.$name.txt;
                let memberTypeInfo:TransUnit.TypeInfo = memberNode.get_expType();
                self.writeln( "_classInfo%d.%s = {" ( classTypeId, memberName ),
                              baseIndent + stepIndent );
                self.writeln(
                    "  name='%s', staticFlag = %s, " ( memberName,
                                                       memberNode.$staticFlag ) ..
                    "accessMode = '%s', methodFlag = false, typeId = %d }"
                    ( memberNode.$accessMode,
                      memberTypeInfo.get_typeId() ),
                    baseIndent + stepIndent );
            }
        }
        
        self.writeln( "end", baseIndent );
    }


    forsort namespaceInfo, className in pickupClassMap {
        let scope = namespaceInfo.scope;
        let classTypeId = namespaceInfo.typeInfo.get_typeId();

        if not TransUnit.isBuiltin( classTypeId ) {
            self.writeln( "do", baseIndent + stepIndent );
            self.writeln( "local _classInfo%s = {}"
                          (classTypeId), baseIndent + stepIndent );
            self.writeln( "_className2InfoMap.%s = _classInfo%d"
                          (className, classTypeId), baseIndent + stepIndent );
            self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                          ( classTypeId, classTypeId), baseIndent + stepIndent );
            

            pickupTypeId( namespaceInfo.typeInfo );

            forsort typeInfo, fieldName in scope.get_symbol2TypeInfoMap() {
                if typeInfo.get_kind() ~= TransUnit.TypeInfoKindMethod
                {
                    if typeInfo.get_accessMode() == "pub" {
                        self.writeln( "_classInfo%d.%s = {" ( classTypeId, fieldName ),
                                      baseIndent + stepIndent );
                        self.writeln(
                            "  name='%s', staticFlag = %s, "
                            ( fieldName,  typeInfo.get_staticFlag() ) ..
                            "accessMode = '%s', methodFlag = false, typeId = %d }"
                            ( typeInfo.get_accessMode(), typeInfo.get_typeId() ),
                            baseIndent + stepIndent );
                    }
                }
            }
            self.writeln( "end", baseIndent );
        }
    }
    


    self.writeln( "local _varName2InfoMap = {}", baseIndent );
    self.writeln( "moduleObj._varName2InfoMap = _varName2InfoMap", baseIndent );

    forsort varInfo, varName in self.pubVarName2InfoMap {
        self.writeln( string.format( "_varName2InfoMap.%s = {", varName ),
                      baseIndent );
        self.writeln(
            "  name='%s', accessMode = '%s', typeId = %d }"
            ( varName, varInfo.accessMode,
              varInfo.typeInfo.get_typeId() ),
            baseIndent );
        pickupTypeId( varInfo.typeInfo, true );
    }

    forsort funcInfo, funcName in self.pubFuncName2InfoMap {
        pickupTypeId( funcInfo.typeInfo );
    }

    

    self.writeln( "local _typeInfoList = {}", baseIndent );
    self.writeln( "moduleObj._typeInfoList = _typeInfoList", baseIndent );
    let listIndex = 1;

    let wroteTypeIdSet:Map<int,bool> = {};
    fn outputTypeInfo( typeInfo: TransUnit.TypeInfo ) {
        let typeId = typeInfo.get_typeId();
        if wroteTypeIdSet[ typeId ] {
            return;
        }
        wroteTypeIdSet[ typeId ] = true;
        if typeId2TypeInfo[ typeId ] and not TransUnit.isBuiltin( typeId )
        {               
            self.write( "_typeInfoList[%d] = " (listIndex) );
            listIndex = listIndex + 1;
            typeInfo.serialize( self );
        }
    }
    
    forsort typeInfo, typeId in typeId2TypeInfo {
        outputTypeInfo( typeInfo );
    }

    self.writeln( "----- meta -----", baseIndent );


    self.writeln( "return moduleObj", baseIndent );
};

pub override fn convFilter.processBlock( 
    node: BlockNode, parent: Node, baseIndent:int )
{
    let word = "";
    if node.get_blockKind() == "if" or node.get_blockKind() == "elseif" {
        word = "then";
    }
    elseif node.get_blockKind() == "else" {
        word = "";
    }
    elseif node.get_blockKind() == "while" {
        word = "do";
    }
    elseif node.get_blockKind() == "repeat" {
        word = "";
    }
    elseif node.get_blockKind() == "for" {
        word = "do";
    }
    elseif node.get_blockKind() == "apply" {
        word = "do";
    }
    elseif node.get_blockKind() == "foreach" {
        word = "do";
    }
    elseif node.get_blockKind() == "macro" {
        word = "";
    }
    elseif node.get_blockKind() == "func" {
        word = "";
    }
    elseif node.get_blockKind() == "default" {
        word = "";
    }
    elseif node.get_blockKind() == "{" {
        word = "do";
    }
    elseif node.get_blockKind() == "macro" {
        word = "";
    }
    self.writeln( word, baseIndent + stepIndent );
    let stmtList = node.get_stmtList();
    foreach statement in stmtList {
        filter( statement, self, node, baseIndent + stepIndent );
        self.writeln( "", baseIndent + stepIndent );
    }

    self.setIndent( baseIndent ) ;
    if node.get_blockKind() == "{" {
        self.write( "end", baseIndent );
    }
};

pub override fn convFilter.processStmtExp( 
    node: StmtExpNode, parent: Node, baseIndent:int )
{
    filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processDeclClass( 
    node: DeclClassNode, parent: Node, baseIndent:int )
{
    let nodeInfo = node;
    let classNameToken = nodeInfo.get_name();
    let className = classNameToken.txt;

    if nodeInfo.get_accessMode() == "pub" {
        self.className2Scope[ className ] = nodeInfo.get_scope();
        self.className2TypeInfo[ className ] = node.get_expType();
    }
    self.className2MemberList[ className ] = nodeInfo.get_memberList();

    self.writeln( string.format( "local %s = {}", className ), baseIndent );

    let baseInfo: TransUnit.TypeInfo = node.get_expType().get_baseTypeInfo();
    if baseInfo {
        self.writeln(
            "setmetatable( %s, { __index = %s } )"
            ( className, baseInfo.getTxt() ), baseIndent );
    }
    
    if nodeInfo.get_accessMode() == "pub" {
        self.writeln( string.format( "moduleObj.%s = %s", className, className ),
                      baseIndent );
    }
    let hasConstrFlag = false;
    let memberList: TransUnit.DeclMemberNode[] = {};
    let fieldList: Map<str,int> = nodeInfo.get_fieldList();
    let outerMethodSet: Map<str,bool> = nodeInfo.get_outerMethodSet();
    foreach field in fieldList {
        let ignoreFlag = false;
        if field.kind == TransUnit.nodeKind.DeclConstr {
            hasConstrFlag = true;
        }
        if field.kind == TransUnit.nodeKind.DeclMember {
            table.insert( memberList, field );
        }
        if field.kind == TransUnit.nodeKind.DeclMethod {
            let methodNode = field@DeclMethodNode;
            let declInfo = methodNode.get_declInfo();
            let methodNameToken = declInfo.get_name();
            if outerMethodSet[ methodNameToken.txt ] {
                ignoreFlag = true;
            }
        }

        if ( not ignoreFlag ) {
            filter( field, self, node, baseIndent );
        }
    }
    if not hasConstrFlag {
        let argTxt = "";
        foreach member, index in memberList {
            if index > 1 {
                argTxt = argTxt .. ", ";
            }
            argTxt = argTxt .. member.$name.txt;
        }

        self.writeln( ```
            function %s.new( %s )
            local obj = {}
            setmetatable( obj, { __index = %s } )
            if obj.__init then
            obj:__init( %s )
            end       
            return obj
            end         
            function %s:__init( %s )
            ``` ( className, argTxt, className, argTxt, className, argTxt ),
                baseIndent );
        foreach member in memberList {
            let memberName = member.$name.txt;
            self.writeln( string.format( "self.%s = %s", memberName, memberName ),
                          baseIndent + stepIndent);         
        }
        self.writeln( 'end', baseIndent );
    }

    '' accessor
    let scope = nodeInfo.get_scope();
    foreach memberNode in nodeInfo.get_memberList() {
        let memberNameToken = memberNode.get_name();
        let memberName = memberNameToken.txt;
        let getterName = "get_" .. memberName;
        let typeInfo:TransUnit.TypeInfo = scope.getTypeInfo( getterName );
        let autoFlag = not typeInfo or typeInfo.get_autoFlag();
        if memberNode.get_getterMode() ~= "none" and autoFlag
        {       
            self.writeln( ```
                function %s:%s()
                return self.%s
                end``` ( className, getterName, memberName ), baseIndent );
        }
        let setterName = "set_" .. memberName;
        typeInfo = scope.getTypeInfo( setterName );
        if memberNode.get_setterMode() ~= "none" and autoFlag
        {       
            self.writeln( ```
                function %s:%s()
                return self.%s
                end``` ( className, setterName, memberName ), baseIndent );
        }
    }
};

pub override fn convFilter.processDeclMember( 
    node: DeclMemberNode, parent: Node, baseIndent:int )
{
    '' dump( baseIndent, node, node.info.name.txt )
    '' node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};



pub override fn convFilter.processExpMacroExp( 
    node: ExpMacroExpNode, parent: Node, baseIndent:int ) 
{
    let stmtList = node.get_stmtList();
    if  stmtList {
        foreach stmt in stmtList {
            filter( stmt, self, node, baseIndent );
            self.writeln( "", baseIndent );
        }
    }
};

pub override fn convFilter.processDeclMacro( 
    node: DeclMacroNode, parent: Node, baseIndent:int ) 
{
    if self.inMacro {
        let nodeInfo = node.get_declInfo();
        let name:Parser.Token = nodeInfo.get_name();
        
        self.write( "local function %s(" ( name.txt ) );
        '' self.write( "local function %s(" ( name.txt ) );

        let argTxt = "";
        foreach arg, index in nodeInfo.get_argList() {
            if index > 1 {
                self.write( ", " );
                argTxt = argTxt .. ", ";
            }   
            filter( arg, self, node, baseIndent );
            if arg.get_kind() == TransUnit.nodeKind.DeclArg {
                argTxt = argTxt .. (arg@DeclArgNode).$name.txt;
            }
            else {
                error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
            }
        }

        self.writeln( ")", baseIndent );

        self.writeln( "local macroVar = {}", baseIndent );
        self.writeln( "macroVar._names = {}", baseIndent );

        self.macroDepth = self.macroDepth + 1;

        if nodeInfo.get_ast() {
            filter( nodeInfo.get_ast(), self, node, baseIndent );
        }
        
        self.macroDepth = self.macroDepth - 1;
        
        self.writeln( "", baseIndent );
        self.writeln( "return macroVar", baseIndent );
        self.writeln( "end", baseIndent );
        self.writeln( "return %s" ( name.txt ), baseIndent );
    }
};

pub override fn convFilter.processExpMacroStat( 
    node: ExpMacroStatNode, parent: Node, baseIndent:int ) 
{
    foreach token, index in node.get_expStrList() {
        if index ~= 1 {
            self.write( '..' );
        }
        
        filter( token, self, node, baseIndent );
    }
};


pub override fn convFilter.processExpNew( 
    node: ExpNewNode, parent: Node, baseIndent:int )
{
    filter( node.get_symbol(),  self, node, baseIndent );
    self.write( ".new(" );
    if node.get_argList() {
        filter( node.get_argList(),  self, node, baseIndent );
    }
    self.write( ")" );
};

pub override fn convFilter.processDeclConstr( 
    node: DeclConstrNode, parent: Node, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let classNameToken = declInfo.get_className();
    let className = classNameToken.txt;
    self.write( string.format( "function %s.new( ", className ) );

    let argTxt = "";
    let argList: TransUnit.Node[] = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
            argTxt = argTxt .. ", ";
        }
        filter( arg, self, node, baseIndent );

        if arg.get_kind() == TransUnit.nodeKind.DeclArg {
            argTxt = argTxt .. (arg@DeclArgNode).$name.txt;
        }
        else {
            error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
        }
    }
    self.writeln( " )", baseIndent + stepIndent );
    self.writeln( "local obj = {}", baseIndent + stepIndent );
    self.writeln( string.format( "setmetatable( obj, { __index = %s } )", className ),
                  baseIndent + stepIndent );
    self.writeln( string.format( "if obj.__init then obj:__init( %s ); end",
                                 argTxt ), baseIndent );
    self.writeln( "return obj", baseIndent );
    self.writeln( "end", baseIndent );


    '' foreach refType, index in declInfo.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''filter( ''    refType,  self, node, baseIndent )
    '' }
    self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
    filter( declInfo.get_body(),  self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


pub override fn convFilter.processExpCallSuper( 
    node: ExpCallSuperNode, parent: Node, baseIndent:int )
{
    let typeInfo:TransUnit.TypeInfo = node.get_superType();
    self.write( "%s.__init( self, " ( typeInfo.getTxt() ) );

    if node.get_expList() {
        filter( node.get_expList(), self, node, baseIndent );
    }
    self.writeln( ")", baseIndent );
};


pub override fn convFilter.processDeclMethod( 
    node: DeclMethodNode, parent: Node, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let delimit = ":";
    if declInfo.get_staticFlag() {
        delimit = ".";
    }
    let methodNodeToken = declInfo.get_name();
    let methodName = methodNodeToken.txt;
    let classNameToken = declInfo.get_className();
    self.write( "function %s%s%s( "
                ( classNameToken.txt, delimit, methodName ) );

    let argList: TransUnit.Node[] = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        filter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in declInfo.retTypeList {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''filter( ''    refType,  self, node, baseIndent )
    '' }
    filter( declInfo.get_body(), self, node, baseIndent );
    self.writeln( "end", baseIndent );
};


pub override fn convFilter.processDeclVar( 
    node: DeclVarNode, parent: Node, baseIndent:int )
{
    if node.get_accessMode() ~= "global" {
        self.write( "local " );
    }

    let varName = "";
    let varList = node.get_varList();
    foreach var, index in varList  {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var.$name.txt );
    }

    if node.get_expList() {
        self.write( " = " );
        filter( node.get_expList(), self, node, baseIndent );
    }

    if node.get_unwrap() {
	self.writeln( "", baseIndent );
	self.write( "if " );
	foreach var, index in varList {
            if index > 1 {
		self.write( " or " );
            }   
	    self.write( " not " .. var.$name.txt );
	}
	self.write( " then" );
	filter( node.get_unwrap(), self, node, baseIndent );
	self.writeln( "end", baseIndent );
    }

    if node.get_accessMode() == "pub" {
        self.writeln( "", baseIndent );
        let varList = node.get_varList();
        foreach var, index in varList {
            let name: str = var.$name.txt;
            self.writeln( "moduleObj.%s = %s" ( name, name ),
                          baseIndent );
            self.pubVarName2InfoMap[ name ] = new VerInfo(
                node.get_staticFlag(),
                node.get_accessMode(), node.get_typeInfoList()[ index ] );
        }
    }

    if self.macroDepth > 0 {
        self.writeln( "", baseIndent );
	foreach var, index in varList {
            let varName = var.$name.txt;
            self.writeln( "table.insert( macroVar._names, '%s' )" ( varName ),
                          baseIndent );
	    self.writeln( "macroVar.%s = %s" ( varName, varName ), baseIndent );
	}
    }
};

pub override fn convFilter.processDeclArg( 
    node: DeclArgNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%s", node.get_name().txt ) );

    '' filter( '' node.info.argType,  self, node, baseIndent )
};

pub override fn convFilter.processDeclArgDDD( 
    node: DeclArgDDDNode, parent: Node, baseIndent:int )
{
    self.write( "..." );
};

pub override fn convFilter.processExpDDD( 
    node: ExpDDDNode, parent: Node, baseIndent:int )
{
    self.write( "..." );
};

pub override fn convFilter.processDeclFunc( 
    node: DeclFuncNode, parent: Node, baseIndent:int )
{
    let declInfo = node.get_declInfo();
    let nameToken:Parser.Token = declInfo.get_name();
    let name = nameToken and nameToken.txt or "";
    let letTxt = "";
    if declInfo.get_accessMode() ~= "global" and #name ~= 0 {
        letTxt = "local ";
    }
    self.write( string.format( "%sfunction %s( ", letTxt, name ) );

    let argList = declInfo.get_argList();
    foreach arg, index in argList {
        if index > 1 {
            self.write( ", " );
        }
        filter( arg, self, node, baseIndent );
    }
    self.write( " )", baseIndent );
    '' foreach refType, index in declInfo.get_retTypeList() {
    ''    if index > 1 {
    ''   self.write( ", " )
    ''    }
    ''filter( ''    refType,  self, node, baseIndent )
    '' }
    filter( declInfo.get_body(),  self, node, baseIndent );
    self.writeln( "end", baseIndent );

    ''if declInfo.get_accessMode() == "pub" {
    let expType: TransUnit.TypeInfo = node.get_expType();
    if expType.get_accessMode() == "pub" {
        self.write( "moduleObj.%s = %s" ( name, name ) );

        self.pubFuncName2InfoMap[ name ] = new FuncInfo(
            declInfo.get_accessMode(), node.get_expType() );
    }
};

pub override fn convFilter.processRefType( 
    node: RefTypeNode, parent: Node, baseIndent:int )
{
    self.write( (node.get_refFlag() and "&" or "") ..
                (node.get_mutFlag() and "mut " or "") );
    filter( node.get_name(),  self, node, baseIndent );
    if node.get_array() == "array" {
        self.write( "[@]" );
    }
    elseif node.get_array() == "list" {
        self.write( "[]" );
    }
};

pub override fn convFilter.processIf( 
    node: IfNode, parent: Node, baseIndent:int )
{
    let valList = node.get_stmtList();
    foreach val, index in valList {
        if index == 1 {
            self.write( "if " );
            filter( val.$exp,  self, node, baseIndent );
        }
        elseif val.$kind == "elseif" {
            self.write( "elseif " );
            filter( val.$exp,  self, node, baseIndent );
        }
        else {
            self.write( "else" );
        }
        self.write( " " );
        filter( val.$block, self, node, baseIndent );
    }
    self.write( "end" );
};

pub override fn convFilter.processSwitch( 
    node: SwitchNode, parent: Node, baseIndent:int )
{
    self.writeln( "do", baseIndent + 2 );
    self.write( "local _switchExp = " );
    filter( node.get_exp(),  self, node, baseIndent + 2 );
    self.writeln( "", baseIndent + 2 );

    foreach caseInfo, index in node.get_caseList() {
        if index == 1 {
            self.write( "if " );
        }
        else {
            self.write( "elseif " );
        }
        let expList = caseInfo.get_expList();
        foreach expNode, index in expList.get_expList() {
            if index ~= 1 {
                self.write( " or " );
            }

            self.write( "_switchExp == " );
            filter( expNode, self, node, baseIndent + 2 );
        }   
        self.write( " then" );
        filter( caseInfo.$block, self, node, baseIndent + 2 );
    }
    if node.get_default() {
        self.write( "else " );
        filter( node.get_default(), self, node, baseIndent + 2 );
    }
    self.writeln( "end", baseIndent );
    
    self.writeln( "end", baseIndent );
};

pub override fn convFilter.processWhile( 
    node: WhileNode, parent: Node, baseIndent:int )
{
    self.write( "while " );

    filter( node.get_exp(), self, node, baseIndent );
    self.write( " " );
    filter( node.get_block(), self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processRepeat( 
    node: RepeatNode, parent: Node, baseIndent:int )
{
    self.write( "repeat " );
    filter( node.get_block(),  self, node, baseIndent );
    self.write( "until " );
    filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processFor( 
    node: ForNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "for %s = ", node.get_val().txt ) );
    filter( node.get_init(),  self, node, baseIndent );
    self.write( ", " );
    filter( node.get_to(),  self, node, baseIndent );
    if node.get_delta() {
        self.write( ", " );
        filter( node.get_delta(),  self, node, baseIndent );
    }
    self.write( " " );
    filter( node.get_block(),  self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processApply( 
    node: ApplyNode, parent: Node, baseIndent:int )
{
    self.write( "for " );
    let varList = node.get_varList();
    foreach var, index in varList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( var.txt );
    }
    self.write( " in " );
    filter( node.$exp,  self, node, baseIndent );
    self.write( " " );
    filter( node.$block,  self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processForeach( 
    node: ForeachNode, parent: Node, baseIndent:int )
{
    self.write( "for " );
    self.write( node.$key and node.$key.txt or "__index" );
    self.write( ", " );
    self.write( node.$val.txt );

    self.write( " in pairs( " );
    filter( node.$exp,  self, node, baseIndent );
    self.write( " ) " );
    filter( node.$block,  self, node, baseIndent );
    self.write( "end" );
};

pub override fn convFilter.processForsort( 
    node: ForsortNode, parent: Node, baseIndent:int )
{
    self.writeln( "do", baseIndent + stepIndent );
    self.writeln( "local __sorted = {}", baseIndent + stepIndent );
    self.write( "local __map = " );
    filter( node.$exp,  self, node, baseIndent + stepIndent );
    self.writeln( "", baseIndent + stepIndent );
    self.writeln( "for __key in pairs( __map ) do", baseIndent + stepIndent * 2 );
    self.writeln( "table.insert( __sorted, __key )", baseIndent + stepIndent );
    self.writeln( "end", baseIndent + stepIndent );

    self.writeln( "table.sort( __sorted )", baseIndent + stepIndent );


    self.write( "for __index, " );
    let key = node.$key and node.$key.txt or "__key";
    self.write( key );
    self.writeln( " in ipairs( __sorted ) do", baseIndent + stepIndent * 2 );
    self.writeln( string.format( "%s = __map[ %s ]", node.$val.txt, key ),
                  baseIndent + stepIndent * 2 );
    filter( node.$block,  self, node, baseIndent + stepIndent * 2 );
    self.writeln( "end", baseIndent + stepIndent );
    self.writeln( "end", baseIndent );
    self.writeln( "end", baseIndent );
};


pub override fn convFilter.processExpCall( 
    node: ExpCallNode, parent: Node, baseIndent:int )
{
    filter( node.$func, self, node, baseIndent );
    self.write( "( " );
    if node.$argList {
        filter( node.$argList,  self, node, baseIndent );
    }
    self.write( " )" );
};


pub override fn convFilter.processExpList( 
    node: ExpListNode, parent: Node, baseIndent:int )
{
    let expList = node.get_expList();
    ''let expList = node.$expList;
    foreach exp, index in expList {
        if index > 1 {
            self.write( ", " );
        }
        filter( exp, self, node, baseIndent );
    }
};


pub override fn convFilter.processExpOp1( 
    node: ExpOp1Node, parent: Node, baseIndent:int )
{
    let op = node.$op.txt;
    if op == ",,," or op == ",,,," {
        filter( node.$exp,  self, node, baseIndent );
    }
    elseif op == ",," {
        self.write( "_luneGetLocal( " );
        filter( node.$exp,  self, node, baseIndent );
        self.write( " )" );
    }
    else {
        if op == "not" {
            op = op .. " ";
        }   
        self.write( op );
        filter( node.$exp,  self, node, baseIndent );
    }
};

pub override fn convFilter.processExpCast( 
    node: ExpCastNode, parent: Node, baseIndent:int )
{
    filter( node.$exp,  self, node, baseIndent );
    ''filter( '' node.$info.castType,  self, node, baseIndent )
};


pub override fn convFilter.processExpParen( 
    node: ExpParenNode, parent: Node, baseIndent:int )
{
    self.write( "(" );
    filter( node.$exp,  self, node, baseIndent );
    self.write( " )" );
};

pub override fn convFilter.processExpOp2( 
    node: ExpOp2Node, parent: Node, baseIndent:int )
{
    filter( node.$exp1,  self, node, baseIndent );

    self.write( " " .. node.$op.txt .. " " );

    filter( node.$exp2,  self, node, baseIndent );
};

pub override fn convFilter.processExpRef( 
    node: ExpRefNode, parent: Node, baseIndent:int )
{
    self.write( node.$token.txt );
};

pub override fn convFilter.processExpRefItem( 
    node: ExpRefItemNode, parent: Node, baseIndent:int )
{
    if node.$val.$kind == TransUnit.nodeKind.LiteralString {
        self.write( "string.byte( " );
        filter( node.$val, self, node, baseIndent );
        self.write( ", " );
        filter( node.$index, self, node, baseIndent );
        self.write( " )" );
    }
    else {
        filter( node.$val, self, node, baseIndent );
        self.write( "[" );
        filter( node.$index, self, node, baseIndent );
        self.write( "]" );
    }
};

pub override fn convFilter.processRefField( 
    node: RefFieldNode, parent: Node, baseIndent:int )
{
    filter( node.get_prefix(),  self, node, baseIndent );
    let delimit = ".";
    if parent.$kind == TransUnit.nodeKind.ExpCall {
        if node.get_expType().get_kind() == TransUnit.TypeInfoKindMethod {
            delimit = ":";
        }   
        else {
            delimit = ".";
        }   
    }
    let fieldToken = node.get_field();
    self.write( delimit .. fieldToken.txt );
};

pub override fn convFilter.processGetField(
    node: GetFieldNode, parent: Node, baseIndent:int )
{
    filter( node.get_prefix(),  self, node, baseIndent );
    let delimit = ".";
    if node.get_getterTypeInfo().get_kind() == TransUnit.TypeInfoKindMethod {
        delimit = ":";
    }   
    else {
        delimit = ".";
    }
    let fieldTxt = node.get_field().txt;
    if node.get_getterTypeInfo() {
        fieldTxt = "get_%s()" ( fieldTxt );
    }
    self.write( delimit .. fieldTxt );
};  


pub override fn convFilter.processReturn( 
    node: ReturnNode, parent: Node, baseIndent:int )
{
    self.write( "return " );

    if node.$expList {
        filter( node.$expList,  self, node, baseIndent );
    }
};

pub override fn convFilter.processLiteralList( 
    node: LiteralListNode, parent: Node, baseIndent:int )
{
    self.write( "{" );

    if node.$expList {
        filter( node.$expList, self, node, baseIndent );
    }

    self.write( "}" );
};

pub override fn convFilter.processLiteralMap( 
    node: LiteralMapNode, parent: Node, baseIndent:int )
{
    self.write( "{" );
    let pairList = node.$pairList;
    foreach pair, index in pairList {
        if index > 1 {
            self.write( ", " );
        }
        self.write( "[" );
        filter( pair.$key, self, node, baseIndent );
        self.write( "] = " );
        filter( pair.$val, self, node, baseIndent );
        index = index + 1;
    }

    self.write( "}" );
};


pub override fn convFilter.processLiteralArray( 
    node: LiteralArrayNode, parent: Node, baseIndent:int )
{
    self.write( "{" );

    if node.$expList {
        filter( node.$expList, self, node, baseIndent );
    }

    self.write( "}" );
};


pub override fn convFilter.processLiteralChar( 
    node: LiteralCharNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%g", node.$num ) );
};

pub override fn convFilter.processLiteralInt( 
    node: LiteralIntNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%d", node.$num ) );
};

pub override fn convFilter.processLiteralReal( 
    node: LiteralRealNode, parent: Node, baseIndent:int )
{
    self.write( string.format( "%s", node.$num ) );
};

pub override fn convFilter.processLiteralString( 
    node: LiteralStringNode, parent: Node, baseIndent:int )
{
    let txt = node.get_token().txt;
    if string.find( txt, '^```' ) {
        txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
    }
    let argList:TransUnit.Node[] = node.get_argList();
    if argList and #argList > 0 {
        self.write( string.format( 'string.format( %s, ', txt ) );
        let argList = node.get_argList();
        foreach val, index in argList {
            if index > 1 {
                self.write( ", " );
            }
            filter( val,  self, node, baseIndent );
        }
        self.write( ")" );
    }
    else {
        self.write( txt );
    }
};

pub override fn convFilter.processLiteralBool( 
    node: LiteralBoolNode, parent: Node, baseIndent:int )
{
    self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralNil( 
    node: LiteralNilNode, parent: Node, baseIndent:int )
{
    self.write( "nil" );
};

pub override fn convFilter.processBreak( 
    node: BreakNode, parent: Node, baseIndent:int )
{
    self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol( 
    node: LiteralSymbolNode, parent: Node, baseIndent:int ) 
{
    self.write( '%s' ( node.$token.txt ) );
};


pub class MacroEvalImp extend TransUnit.MacroEval {
    pub override fn eval( node: TransUnit.DeclMacroNode ): Map<str,stem>
    {   
        let oStream = new Util.memStream();
        let conv = new convFilter( "macro", oStream, false, true );

        conv.processDeclMacro( node, nil, 0 );

        ''Util.errorLog( 'hoooo: %s' (oStream.get_txt()) );
        
        let chunk, err = load( oStream.get_txt() );
        if err {
            error( err );
        }
        let mod: stem = chunk();
        if not mod {
            error( "macro load error" );
        }   
        return mod;
    }
}

