import test.simple;

let classA = new simple.ClassA();
print( classA.func( 0 ) );
print( classA.func( 0 ) );
print( classA.sub() );

let classB = new simple.ClassB( 123 );
print( "classB.func()", classB.func() );
print( "classB.sub()", classB.sub() );
let hoge = classB.func2();
print( "Hoge.func()", hoge.func() );

let func3ret = classB.func3() ;
foreach val in func3ret {
    print( val );
}

print( "12%d" ( 10 ) );

{
    let val = 1;
    print( "%g" (val@real));
}

print( "op", {},  1 and "2" and 3.0 and {} );
print( "op", 3.0, 1 and "2" and 3.0 or  {} );
print( "op", "2", 1 and "2" or  3.0 and {} );
print( "op", "2", 1 and "2" or  3.0 or  {} );
print( "op", 1,   1 or  "2" and 3.0 and {} );
print( "op", 1,   1 or  "2" and 3.0 or  {} );
print( "op", 1,   1 or  "2" or  3.0 and {} );
print( "op", 1,   1 or  "2" or  3.0 or  {} );

for index = 1, 4 {
    switch index {
        case 1, 2 {       
            print( "hoge", index );
        }   
        case 3 {
            print( "foo", index );
        }   
        default {
            print( "bar", index );
        }   
    }   
}

fn func( val: int! ): int {
    let! val2 = val { return 0; };
    
    return val2 + 2;
}

print( 3, func( 1 ) );
print( 0, func( nil ) );

macro _test() {
    print( "macro hoge" );
}
_test();

macro _test2( val:int, funcxx:sym ) {
    {
        fn func(val2:int):str {
            return "mfunc%d" (val2);
        }
        let message = "hello %d %s" ( val, ,,,,funcxx );
        let stat = `{ print( "macro stat" ); };
        let stat2 = `{
            for index = 1, 10 {
                print( "hoge %d" ( index ) );
            }
        };
        let stat3:stat[] = [];
        for index = 1, 4 {
            table.insert( stat3, `{ print( "foo %d" ( ,,index ) ); } );
        }
        let stat4 = ,,,func( 1 );
        let stat5 = `{
            ,,stat4( 100 );
            _fcall( ,,,func( 1 ), ( ,,func( 2 ) ));
            _fcall( ,,,func( 1 ), ( ,,,,stat4 ));
        };
    }
    print( ,,message );
    ,,funcxx( "macro test2" );
    ,,stat;
    ,,stat2;
    ,,stat3;
    ,,stat4( 10 );
    ,,stat5;
}

fn mfunc1( val: int ) {
    print( "mfunc1", val );
}

_test2( 1, print );

macro _classtest( macroVal: int, fieldInfoList: Map<str,str>[] ) {
    {
        let name = ,,,"classTest%d" (macroVal);
        let field:stat[] = [];

        if fieldInfoList {
            foreach fieldInfo in fieldInfoList {
                foreach typeName, varName in fieldInfo {
                    table.insert( field, `{
                        pri let ,,,varName : ,,,typeName { pub };
                    });
                }
            }
        }
    }
    class ,,name {
        ,,field;
        pub fn func(): int {
            return ,,macroVal;
        }
    }
}

_classtest( 1, [ { "val": "int" }, { "val2": "str" } ] ) ;
_classtest( 2 );
_classtest( 3 );

let classObj = new classTest1( 1000, "2000" );
print( classObj.func(), classObj.get_val(), classObj.get_val2() );
classObj = new classTest2();
print( classObj.func() );
classObj = new classTest3();
print( classObj.func() );


macro _stattest( val: stat ) {
    ,,val;
}

_stattest(
    `{
        print( "1" );
        print( "2" );
    } );

macro _symboltest( symbol: sym, val:stem ) {
    print( ,,symbol( ,,val ) );
}

_symboltest( string.format, "test\n" );



class GetTest {
    let val: int { pub };
    pub fn __init() {
        self.val = 100;
    }
}
print( (new GetTest()).$val );

class GetTest2 {
    let val: int;
    pub fn __init() {
        self.val = 200;
    }
}
print( (new GetTest2()).$val );

