import test.simple;

let classA = new simple.ClassA();
print( classA.func( 0 ) );
print( classA.func( 0 ) );
print( classA.sub() );

let classB = new simple.ClassB();
print( "classB.func()", classB.func() );
print( "classB.sub()", classB.sub() );
let hoge = classB.func2();
print( "Hoge.func()", hoge.func() );

print( "12%d" ( 10 ) );

{
    let val = 1;
    print( "%g" (val@real));
}

print( "op", {},  1 and "2" and 3.0 and {} );
print( "op", 3.0, 1 and "2" and 3.0 or  {} );
print( "op", "2", 1 and "2" or  3.0 and {} );
print( "op", "2", 1 and "2" or  3.0 or  {} );
print( "op", 1,   1 or  "2" and 3.0 and {} );
print( "op", 1,   1 or  "2" and 3.0 or  {} );
print( "op", 1,   1 or  "2" or  3.0 and {} );
print( "op", 1,   1 or  "2" or  3.0 or  {} );

for index = 1, 4 {
    switch index {
        case 1, 2 {
            print( "hoge", index );
        }   
        case 3 {
            print( "foo", index );
        }   
        default {
            print( "bar", index );
        }   
    }   
}

fn func( val: int! ): int {
    let! val2 = val { return 0; };
    
    return val2 + 2;
}

print( 3, func( 1 ) );
print( 0, func( nil ) );

macro _test( sym: str, val: int ) {
    {
        let symbol = "%sfunc" (sym);
        let list: stat[] = [];
        for count = 1, val {
            table.insert( list, `{ ,,,"func%d" ( count ) (); } );
        }
    }
    {
        if foo {
            (,,,symbol)( 1 );
        } 
        else {
            ,,list;
        } 
    }
}

_test( "sub", 5 );
